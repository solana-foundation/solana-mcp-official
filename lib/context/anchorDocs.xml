<file_contents>
File: anchor/docs/content/docs/basics/cpi.mdx

````mdx
---
title: Cross Program Invocation
description:
  Learn how to implement Cross Program Invocations (CPIs) in Anchor programs to
  enable composability between different Solana programs.
---

Cross Program Invocations (CPI) refer to the process of one program invoking
instructions of another program, which enables the composibility of Solana
programs.

This section will cover the basics of implementing CPIs in an Anchor program,
using a simple SOL transfer instruction as a practical example. Once you
understand the basics of how to implement a CPI, you can apply the same concepts
for any instruction.

## Cross Program Invocations

Let's examine a program that implements a CPI to the System Program's transfer
instruction. Here is the example program on
[Solana Playground](https://beta.solpg.io/66df2751cffcf4b13384d35a).

The `lib.rs` file includes a single `sol_transfer` instruction. When the
`sol_transfer` instruction on the Anchor program is invoked, the program
internally invokes the transfer instruction of the System Program.

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");

#[program]
pub mod cpi {
    use super::*;

    // [!code word:sol_transfer]
    // [!code highlight]
    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        );
        // [!code word:transfer]
        // [!code highlight]
        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```
````

The `cpi.test.ts` file shows how to invoke the Anchor program's `sol_transfer`
instruction and logs a link to the transaction details on SolanaFM.

```ts title="cpi.test.ts"
it("SOL Transfer Anchor", async () => {
  const transactionSignature = await program.methods
    .solTransfer(new BN(transferAmount))
    .accounts({
      sender: sender.publicKey,
      recipient: recipient.publicKey,
    })
    .rpc();

  console.log(
    `\nTransaction Signature:` +
      `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

You can build, deploy, and run the test for this example on Playground to view
the transaction details on the [SolanaFM explorer](https://solana.fm/).

The transaction details will show that the Anchor program was first invoked
(instruction 1), which then invokes the System Program (instruction 1.1),
resulting in a successful SOL transfer.

![Transaction Details](/docs/core/cpi/transaction-details.png)

### Example Explanation

Cross Program Invocations (CPIs) allow one program to invoke instructions on
another program. The process of implementing a CPI is the same as that of
creating a instruction where you must specify:

1. The program ID of the program being called
2. The accounts required by the instruction
3. Any instruction data required as arguments

This pattern ensures the CPI has all the information needed to invoke the target
program's instruction.

The System Program's transfer instruction requires two accounts:

- `from`: The account sending SOL.
- `to`: The account receiving SOL.

In the example program, the `SolTransfer` struct specifies the accounts required
by the transfer instruction. The System Program is also included because the CPI
invokes the System Program.

```rust
// [!code word:sender]
// [!code word:recipient]
// [!code word:system_program]
#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>, // from account
    #[account(mut)]
    recipient: SystemAccount<'info>, // to account
    system_program: Program<'info, System>, // program ID
}
```

The following tabs present three approaches to implementing Cross Program
Invocations (CPIs), each at a different level of abstraction. All examples are
functionally equivalent. The main purpose is to illustrate the implementation
details of a CPI.

<Tabs groupId="language" items={['1', '2', '3']}>
<Tab value="1">

The `sol_transfer` instruction included in the example code shows a typical
approach for constructing CPIs using the Anchor framework.

This approach involves creating a
[`CpiContext`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/context.rs#L171),
which includes the `program_id` and accounts required for the instruction being
called. The `CpiContext` is then passed to an Anchor helper function
([`transfer`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/system_program.rs#L298))
to invoke a specific instruction.

```rust
use anchor_lang::system_program::{transfer, Transfer};
```

```rust
pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
    let from_pubkey = ctx.accounts.sender.to_account_info();
    let to_pubkey = ctx.accounts.recipient.to_account_info();
    let program_id = ctx.accounts.system_program.to_account_info();

    // [!code word:cpi_context]
    let cpi_context = CpiContext::new(
        program_id,
        Transfer {
            from: from_pubkey,
            to: to_pubkey,
        },
    );

    // [!code highlight]
    transfer(cpi_context, amount)?;
    Ok(())
}
```

The `cpi_context` variable specifies the program ID (System Program) and
accounts (sender and recipient) required by the transfer instruction.

```rust /program_id/ /from_pubkey/ /to_pubkey/
let cpi_context = CpiContext::new(
    program_id,
    Transfer {
        from: from_pubkey,
        to: to_pubkey,
    },
);
```

The `cpi_context` and `amount` are then passed into the `transfer` function to
execute the CPI invoking the transfer instruction of the System Program.

```rust
transfer(cpi_context, amount)?;
```

</Tab>
<Tab value="2">

This example shows a different approach to implementing a CPI using the `invoke`
function and
[`system_instruction::transfer`](https://github.com/anza-xyz/agave/blob/v1.18.26/sdk/program/src/system_instruction.rs#L881-L891),
which is generally seen in native Rust programs.

Under the hood, the previous example is an abstraction of this implementation.
The example below is functionally equivalent to the previous example.

```rust
use anchor_lang::solana_program::{program::invoke, system_instruction};
```

```rust
pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
    let from_pubkey = ctx.accounts.sender.to_account_info();
    let to_pubkey = ctx.accounts.recipient.to_account_info();
    let program_id = ctx.accounts.system_program.to_account_info();

    // [!code word:instruction:1]
    let instruction =
        &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

    // [!code highlight]
    // [!code word:instruction:1]
    invoke(instruction, &[from_pubkey, to_pubkey, program_id])?;
    Ok(())
}
```

</Tab>
<Tab value="3">

You can also manually build the instruction to pass into the `invoke()`
function. This is useful when there is no crate available to help build the
instruction you want to invoke. This approach requires you to specify the
`AccountMeta`s for the instruction and correctly create the instruction data
buffer.

The `sol_transfer` instruction below is a manual implementation of a CPI to the
System Program's transfer instruction.

```rust
pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
    let from_pubkey = ctx.accounts.sender.to_account_info();
    let to_pubkey = ctx.accounts.recipient.to_account_info();
    let program_id = ctx.accounts.system_program.to_account_info();

    // Prepare instruction AccountMetas
    let account_metas = vec![
        AccountMeta::new(from_pubkey.key(), true),
        AccountMeta::new(to_pubkey.key(), false),
    ];

    // SOL transfer instruction discriminator
    let instruction_discriminator: u32 = 2;

    // Prepare instruction data
    let mut instruction_data = Vec::with_capacity(4 + 8);
    instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
    instruction_data.extend_from_slice(&amount.to_le_bytes());

    // Create instruction
    // [!code word:instruction:1]
    let instruction = Instruction {
        program_id: program_id.key(),
        accounts: account_metas,
        data: instruction_data,
    };

    // Invoke instruction
    // [!code word:instruction:1]
    // [!code highlight]
    invoke(&instruction, &[from_pubkey, to_pubkey, program_id])?;
    Ok(())
}
```

When building an instruction in Rust, use the following syntax to specify the
`AccountMeta` for each account:

```rust
AccountMeta::new(account1_pubkey, true),           // writable, signer
AccountMeta::new(account2_pubkey, false),          // writable, not signer
AccountMeta::new_readonly(account3_pubkey, false), // not writable, not signer
AccountMeta::new_readonly(account4_pubkey, true),  // writable, signer
```

</Tab>
</Tabs>

Here is a reference program on
[Solana Playground](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/cpi)
which includes all 3 examples.

## Cross Program Invocations with PDA Signers

Next, let's examine a program that implements a CPI to the System Program's
transfer instruction where the sender is a Program Derived Address (PDA) that
must be "signed" for by the program. Here is the example program on
[Solana Playground](https://beta.solpg.io/66df2bd2cffcf4b13384d35b).

The `lib.rs` file includes the following program with a single `sol_transfer`
instruction.

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("3455LkCS85a4aYmSeNbRrJsduNQfYRY82A7eCD3yQfyR");

#[program]
pub mod cpi {
    use super::*;

    // [!code word:sol_transfer]
    // [!code highlight]
    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        )
        .with_signer(signer_seeds);

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

The `cpi.test.ts` file shows how to invoke the Anchor program's `sol_transfer`
instruction and logs a link to the transaction details on SolanaFM.

It shows how to derive the PDA using the seeds specified in the program:

```ts
// [!code word:pda]
// [!code word:wallet.publicKey]
const [PDA] = PublicKey.findProgramAddressSync(
  // [!code highlight]
  [Buffer.from("pda"), wallet.publicKey.toBuffer()],
  program.programId
);
```

The first step in this example is to fund the PDA account with a basic SOL
transfer from the Playground wallet.

```ts title="cpi.test.ts"
it("Fund PDA with SOL", async () => {
  const transferInstruction = SystemProgram.transfer({
    fromPubkey: wallet.publicKey,
    toPubkey: PDA,
    lamports: transferAmount,
  });

  const transaction = new Transaction().add(transferInstruction);

  const transactionSignature = await sendAndConfirmTransaction(
    connection,
    transaction,
    [wallet.payer] // signer
  );

  console.log(
    `\nTransaction Signature:` +
      `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

Once the PDA is funded with SOL, invoke the `sol_transfer` instruction. This
instruction transfers SOL from the PDA account back to the `wallet` account via
a CPI to the System Program, which is "signed" for by the program.

```ts
it("SOL Transfer with PDA signer", async () => {
  const transactionSignature = await program.methods
    .solTransfer(new BN(transferAmount))
    .accounts({
      pdaAccount: PDA,
      recipient: wallet.publicKey,
    })
    .rpc();

  console.log(
    `\nTransaction Signature: https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

You can build, deploy, and run the test to view the transaction details on the
[SolanaFM explorer](https://solana.fm/).

The transaction details will show that the custom program was first invoked
(instruction 1), which then invokes the System Program (instruction 1.1),
resulting in a successful SOL transfer.

![Transaction Details](/docs/core/cpi/transaction-details-pda.png)

### Example Explanation

In the example code, the `SolTransfer` struct specifies the accounts required by
the transfer instruction.

The sender is a PDA that the program must sign for. The `seeds` to derive the
address for the `pda_account` include the hardcoded string "pda" and the address
of the `recipient` account. This means the address for the `pda_account` is
unique for each `recipient`.

```rust
#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        // [!code highlight]
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    // [!code word:pda_account]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    // [!code word:recipient]
    recipient: SystemAccount<'info>,
    // [!code word:system_program]
    system_program: Program<'info, System>,
}
```

The Javascript equivalent to derive the PDA is included in the test file.

```ts
// [!code word:pda]
// [!code word:wallet.publicKey]
const [PDA] = PublicKey.findProgramAddressSync(
  // [!code highlight]
  [Buffer.from("pda"), wallet.publicKey.toBuffer()],
  program.programId
);
```

The following tabs present two approaches to implementing Cross Program
Invocations (CPIs), each at a different level of abstraction. Both examples are
functionally equivalent. The main purpose is to illustrate the implementation
details of the CPI.

<Tabs groupId="language" items={['1', '2']}>
<Tab value="1">

The `sol_transfer` instruction included in the example code shows a typical
approach for constructing CPIs using the Anchor framework.

This approach involves creating a
[`CpiContext`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/context.rs#L171),
which includes the `program_id` and accounts required for the instruction being
called, followed by a helper function (`transfer`) to invoke a specific
instruction.

```rust
pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
    let from_pubkey = ctx.accounts.pda_account.to_account_info();
    let to_pubkey = ctx.accounts.recipient.to_account_info();
    let program_id = ctx.accounts.system_program.to_account_info();

    let seed = to_pubkey.key();
    let bump_seed = ctx.bumps.pda_account;
    let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

    // [!code word:cpi_context]
    let cpi_context = CpiContext::new(
        program_id,
        Transfer {
            from: from_pubkey,
            to: to_pubkey,
        },
    )
    .with_signer(signer_seeds);

    // [!code highlight]
    transfer(cpi_context, amount)?;
    Ok(())
}
```

When signing with PDAs, the seeds and bump seed are included in the
`cpi_context` as `signer_seeds` using `with_signer()`. The bump seed for a PDA
can be accessed using `ctx.bumps` followed by the name of the PDA account.

```rust /signer_seeds/ /bump_seed/ {3}
let seed = to_pubkey.key();
let bump_seed = ctx.bumps.pda_account;
// [!code word:signer_seeds]
// [!code highlight]
let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

let cpi_context = CpiContext::new(
    program_id,
    Transfer {
        from: from_pubkey,
        to: to_pubkey,
    },
)
// [!code highlight]
.with_signer(signer_seeds);
```

The `cpi_context` and `amount` are then passed into the `transfer` function to
execute the CPI.

```rust
transfer(cpi_context, amount)?;
```

When the CPI is processed, the Solana runtime will validate that the provided
seeds and caller program ID derive a valid PDA. The PDA is then added as a
signer on the invocation. This mechanism allows for programs to sign for PDAs
that are derived from their program ID.

</Tab>
<Tab value="2">

Under the hood, the previous example is a wrapper around the `invoke_signed()`
function which uses
[`system_instruction::transfer`](https://github.com/anza-xyz/agave/blob/v1.18.26/sdk/program/src/system_instruction.rs#L881-L891)
to build the instruction.

This example shows how to use the `invoke_signed()` function to make a CPI
signed for by a PDA.

```rust
use anchor_lang::solana_program::{program::invoke_signed, system_instruction};
```

```rust
pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
    let from_pubkey = ctx.accounts.pda_account.to_account_info();
    let to_pubkey = ctx.accounts.recipient.to_account_info();
    let program_id = ctx.accounts.system_program.to_account_info();

    let seed = to_pubkey.key();
    let bump_seed = ctx.bumps.pda_account;

    // [!code word:signer_seeds]
    let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

    // [!code word:instruction:1]
    let instruction =
        &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

    // [!code word:instruction:1]
    // [!code highlight]
    invoke_signed(instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
    Ok(())
}
```

This implementation is functionally equivalent to the previous example. The
`signer_seeds` are passed into the `invoke_signed` function.

</Tab>
</Tabs>

Here is a reference program on
[Solana Playground](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/cpi-pda)
which includes both examples.

````

File: anchor/docs/content/docs/basics/idl.mdx
```mdx
---
title: Program IDL File
description:
  Learn about the Interface Description Language (IDL) file in Anchor, its
  purpose, benefits, and how it simplifies program-client interactions
---

An Interface Description Language (IDL) file for an Anchor program provides a
standardized JSON file describing the program's instructions and accounts. This
file simplifies the process of integrating your on-chain program with client
applications.

Key Benefits of the IDL:

- Standardization: Provides a consistent format for describing the program's
  instructions and accounts
- Client Generation: Used to generate client code to interact with the program

<Callout type="info">
The `anchor build` command generates an IDL file located at
`/target/idl/<program-name>.json`.
</Callout>

The code snippets in the sections below highlight how the program, IDL, and
client relate to each other.

## Program Instructions

The `instructions` array in the IDL corresponds directly to the instructions
defined in your program. It specifies the required accounts and parameters for
each instruction.

<Tabs items={['Program', 'IDL', 'Client']}>
<Tab value="Program">

The program below includes an `initialize` instruction, specifying the accounts
and parameters it requires.

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("BYFW1vhC1ohxwRbYoLbAWs86STa25i9sD5uEusVjTYNd");

#[program]
mod hello_anchor {
    use super::*;
    // [!code word:initialize]
    // [!code word:Initialize]
    // [!code highlight:5]
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

 // [!code highlight:8]
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NewAccount {
    data: u64,
}
````

</Tab>
<Tab value="IDL">

The generated IDL file includes the instruction in a standardized JSON format,
including its name, discriminator, accounts, and arguments.

```json title="JSON"
{
  "address": "BYFW1vhC1ohxwRbYoLbAWs86STa25i9sD5uEusVjTYNd",
  "metadata": {
    "name": "hello_anchor",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      // [!code word:initialize]
      // [!code highlight]
      "name": "initialize",
      // [!code word:discriminator:1]
      // [!code highlight]
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
      // [!code word:accounts:1]
      "accounts": [
        // [!code highlight:14]
        {
          "name": "new_account",
          "writable": true,
          "signer": true
        },
        {
          "name": "signer",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      // [!code word:args:1]
      "args": [
        // [!code highlight:4]
        {
          "name": "data",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "NewAccount",
      "discriminator": [176, 95, 4, 118, 91, 177, 125, 232]
    }
  ],
  "types": [
    {
      "name": "NewAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "data",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

</Tab>
<Tab value="Client">

The IDL file is then used to generate a client for interacting with the program,
simplifying the process of invoking the program instruction.

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program, BN } from "@coral-xyz/anchor";
import { HelloAnchor } from "../target/types/hello_anchor";
import { Keypair } from "@solana/web3.js";
import assert from "assert";

describe("hello_anchor", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const wallet = provider.wallet as anchor.Wallet;
  const program = anchor.workspace.HelloAnchor as Program<HelloAnchor>;

  it("initialize", async () => {
    // Generate keypair for the new account
    const newAccountKp = new Keypair();

    // Send transaction
    const data = new BN(42);
    // [!code word:initialize]
    // [!code highlight:8]
    const transactionSignature = await program.methods
      .initialize(data)
      .accounts({
        newAccount: newAccountKp.publicKey,
        signer: wallet.publicKey,
      })
      .signers([newAccountKp])
      .rpc();

    // Fetch the created account
    const newAccount = await program.account.newAccount.fetch(
      newAccountKp.publicKey
    );

    console.log("Transaction signature: ", transactionSignature);
    console.log("On-chain data is:", newAccount.data.toString());
    assert(data.eq(newAccount.data));
  });
});
```

</Tab>
</Tabs>

## Program Accounts

The `accounts` array in the IDL corresponds to the structs in a program
annotated with the `#[account]` attribute. These structs define the data stored
on accounts created by the program.

<Tabs items={['Program', 'IDL', 'Client']}>
<Tab value="Program">

The program below defines a `NewAccount` struct with a single `data` field of
type `u64`.

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("BYFW1vhC1ohxwRbYoLbAWs86STa25i9sD5uEusVjTYNd");

#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

// [!code word:NewAccount]
// [!code highlight:4]
#[account]
pub struct NewAccount {
    data: u64,
}
```

</Tab>
<Tab value="IDL">

The generated IDL file includes the account in a standardized JSON format,
including its name, discriminator, and fields.

```json title="JSON"
{
  "address": "BYFW1vhC1ohxwRbYoLbAWs86STa25i9sD5uEusVjTYNd",
  "metadata": {
    "name": "hello_anchor",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "initialize",
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
      "accounts": [
        {
          "name": "new_account",
          "writable": true,
          "signer": true
        },
        {
          "name": "signer",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": [
        {
          "name": "data",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      // [!code word:discriminator]
      // [!code word:NewAccount]
      // [!code highlight:2]
      "name": "NewAccount",
      "discriminator": [176, 95, 4, 118, 91, 177, 125, 232]
    }
  ],
  "types": [
    // [!code highlight:12]
    {
      "name": "NewAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "data",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

</Tab>
<Tab value="Client">

The IDL file is then used to generate a client for interacting with the program,
simplifying the process of fetching and deserializing account data.

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program, BN } from "@coral-xyz/anchor";
import { HelloAnchor } from "../target/types/hello_anchor";
import { Keypair } from "@solana/web3.js";
import assert from "assert";

describe("hello_anchor", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const wallet = provider.wallet as anchor.Wallet;
  const program = anchor.workspace.HelloAnchor as Program<HelloAnchor>;

  it("initialize", async () => {
    // Generate keypair for the new account
    const newAccountKp = new Keypair();

    // Send transaction
    const data = new BN(42);
    const transactionSignature = await program.methods
      .initialize(data)
      .accounts({
        newAccount: newAccountKp.publicKey,
        signer: wallet.publicKey,
      })
      .signers([newAccountKp])
      .rpc();

    // Fetch the created account
    // [!code word:.newAccount.:1]
    // [!code highlight:3]
    const newAccount = await program.account.newAccount.fetch(
      newAccountKp.publicKey
    );

    console.log("Transaction signature: ", transactionSignature);
    console.log("On-chain data is:", newAccount.data.toString());
    assert(data.eq(newAccount.data));
  });
});
```

</Tab>
</Tabs>

## Discriminators

Anchor assigns a unique 8 byte discriminator to each instruction and account
type in a program. These discriminators serve as identifiers to distinguish
between different instructions or account types.

The discriminator is generated using the first 8 bytes of the Sha256 hash of a
prefix combined with the instruction or account name. As of Anchor v0.30, these
discriminators are included in the IDL file.

<Callout type="info">
  Note that when working with Anchor, you typically won't need to interact
  directly with these discriminators. This section is primarily to provide
  context on how the discriminator is generated and used.
</Callout>

<Tabs items={['Instructions', 'Accounts']}>
<Tab value="Instructions">

The instruction discriminator is used by the program to determine which specific
instruction to execute when called.

When an Anchor program instruction is invoked, the discriminator is included as
the first 8 bytes of the instruction data. This is done automatically by the
Anchor client.

```json title="IDL"
  "instructions": [
    {
      "name": "initialize",
      // [!code word:discriminator]
      // [!code highlight]
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
       ...
    }
  ]
```

The discriminator for an instruction is the first 8 bytes of the Sha256 hash of
the prefix `global` plus the instruction name.

For example:

```
sha256("global:initialize")
```

Hexadecimal output:

```
af af 6d 1f 0d 98 9b ed d4 6a 95 07 32 81 ad c2 1b b5 e0 e1 d7 73 b2 fb bd 7a b5 04 cd d4 aa 30
```

The first 8 bytes are used as the discriminator for the instruction.

```
af = 175
af = 175
6d = 109
1f = 31
0d = 13
98 = 152
9b = 155
ed = 237
```

You can find the implementation of the discriminator generation in the Anchor
codebase
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/program/common.rs#L5-L19),
for the [`gen_discriminator` method here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/program/common.rs#L21-L24),
which is used
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/program/instruction.rs#L33).

</Tab>
<Tab value="Accounts">

The account discriminator is used to identify the specific account type when
deserializing on-chain data and is set when the account is created.

```json title="IDL"
  "accounts": [
    {
      "name": "NewAccount",
      // [!code word:discriminator]
      // [!code highlight]
      "discriminator": [176, 95, 4, 118, 91, 177, 125, 232]
    }
  ]
```

The discriminator for an account is the first 8 bytes of the Sha256 hash of the
prefix `account` plus the account name.

For example:

```
sha256("account:NewAccount")
```

Hexadecimal output:

```
b0 5f 04 76 5b b1 7d e8 a1 93 57 2a d3 5e b1 ae e5 f0 69 e2 09 7e 5c d2 64 56 55 2a cb 4a e9 57
```

The first 8 bytes are used as the discriminator for the account.

```
b0 = 176
5f = 95
04 = 4
76 = 118
5b = 91
b1 = 177
7d = 125
e8 = 232
```

You can find the implementation of the discriminator generation in the Anchor
codebase
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L101-L117).

<Callout type="info">
  Note that different programs using identical account names will generate the
  same discriminator. When deserializing account data, Anchor programs will also
  check an account is owned by the expected program for a specified account
  type.
</Callout>

</Tab>
</Tabs>

````

File: anchor/docs/content/docs/basics/index.mdx
```mdx
---
title: Anchor Framework Basics
description:
  Learn how to use the Anchor framework to build secure Solana programs.
index: true
---

Before diving into Anchor, it's recommended to have a basic understanding of
[Solana's core concepts](https://solana.com/docs/core).

````

File: anchor/docs/content/docs/basics/meta.json

```json
{
  "title": "The Basics",
  "pages": ["program-structure", "idl", "client", "pda", "cpi"]
}
```

File: anchor/docs/content/docs/clients/index.mdx

```mdx
---
title: Clients
description:
  Learn how to interact with Anchor programs using client libraries in
  TypeScript and Rust.
index: true
---
```

File: anchor/docs/content/docs/basics/program-structure.mdx

````mdx
---
title: Program Structure
description:
  Learn about the structure of Anchor programs, including key macros and their
  roles in simplifying Solana program development
---

The Anchor framework uses
[Rust macros](https://rust-book.cs.brown.edu/ch20-06-macros.html) to reduce
boilerplate code and simplify the implementation of common security checks
required for writing Solana programs.

The main macros found in an Anchor program include:

- [`declare_id`](#declare_id-macro): Specifies the program's on-chain address
- [`#[program]`](#program-attribute): Specifies the module containing the
  programâ€™s instruction logic
- [`#[derive(Accounts)]`](#deriveaccounts-macro): Applied to structs to indicate
  a list of accounts required by an instruction
- [`#[account]`](#account-attribute): Applied to structs to create custom
  account types for the program

## Example Program

Let's examine a simple program that demonstrates the usage of the macros
mentioned above to understand the basic structure of an Anchor program.

The program below includes a single instruction called `initialize` that creates
a new account (`NewAccount`) and initializes it with a `u64` value.

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NewAccount {
    data: u64,
}
```
````

## declare_id! macro

The
[`declare_id`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L537)
macro specifies the on-chain address of the program, known as the program ID.
You can find the implementation of the code generated by the `declare_id!` macro
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/id.rs#L37-L70).

```rust title="lib.rs"
use anchor_lang::prelude::*;

// [!code highlight]
declare_id!("11111111111111111111111111111111");
```

By default, the program ID is the public key of the keypair generated at
`/target/deploy/your_program_name.json`.

To update the value of the program ID in the `declare_id` macro with the public
key of the keypair in the `/target/deploy/your_program_name.json` file, run the
following command:

```shell title="Terminal"
anchor keys sync
```

The `anchor keys sync` command is useful to run when cloning a repository where
the value of the program ID in a cloned repo's `declare_id` macro won't match
the one generated when you run `anchor build` locally.

## #[program] attribute

The
[`#[program]`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/lib.rs#L12)
attribute annotates the module containing all the instruction handlers for your
program. Each public function within this module corresponds to an instruction
that can be invoked.

You can find the implementation of the code generated by the `#[program]`
attribute
[here](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/program).

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

// [!code highlight]
#[program]
mod hello_anchor {
    use super::*;
    // [!code highlight:5]
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NewAccount {
    data: u64,
}
```

### Instruction Context

Instruction handlers are functions that define the logic executed when an
instruction is invoked. The first parameter of each handler is a `Context<T>`
type, where `T` is a struct implementing the
[`Accounts`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/lib.rs#L108)
trait and specifies the accounts the instruction requires.

The
[`Context`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/context.rs#L24)
type provides the instruction with access to the following non-argument inputs:

```rust
pub struct Context<'a, 'b, 'c, 'info, T: Bumps> {
    /// Currently executing program id.
    pub program_id: &'a Pubkey,
    /// Deserialized accounts.
    pub accounts: &'b mut T,
    /// Remaining accounts given but not deserialized or validated.
    /// Be very careful when using this directly.
    pub remaining_accounts: &'c [AccountInfo<'info>],
    /// Bump seeds found during constraint validation. This is provided as a
    /// convenience so that handlers don't have to recalculate bump seeds or
    /// pass them in as arguments.
    /// Type is the bumps struct generated by #[derive(Accounts)]
    pub bumps: T::Bumps,
}
```

The `Context` fields can be accessed in an instruction using dot notation:

- `ctx.accounts`: The accounts required for the instruction
- `ctx.program_id`: The program's public key (address)
- `ctx.remaining_accounts`: Additional accounts not specified in the `Accounts`
  struct.
- `ctx.bumps`: Bump seeds for any Program Derived Address (PDA) accounts
  specified in the `Accounts` struct

Additional parameters are optional and can be included to specify arguments that
must be provided when the instruction is invoked.

```rust title="lib.rs"
// [!code word:Context]
// [!code word:data:1]
pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
    ctx.accounts.new_account.data = data;
    msg!("Changed data to: {}!", data);
    Ok(())
}
```

In this example, the `Initialize` struct implements the `Accounts` trait where
each field in the struct represents an account required by the `initialize`
instruction.

```rust title="lib.rs"
// [!code word:Initialize]
// [!code word:Accounts]
#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

## #[derive(Accounts)] macro

The
[`#[derive(Accounts)]`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/derive/accounts/src/lib.rs#L631)
macro is applied to a struct to specify the accounts that must be provided when
an instruction is invoked. This macro implements the
[`Accounts`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/lib.rs#L108)
trait, which simplifies account validation and serialization and deserialization
of account data.

You can find the implementation of the code generated by the
`#[derive(Accounts)]` macro
[here](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/accounts).

```rust
// [!code word:Accounts]
#[derive(Accounts)]
// [!code highlight]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

Each field in the struct represents an account required by an instruction. The
naming of each field is arbitrary, but it is recommended to use a descriptive
name that indicates the purpose of the account.

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    // [!code word:new_account]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    // [!code word:signer]
    pub signer: Signer<'info>,
    // [!code word:system_program]
    pub system_program: Program<'info, System>,
}
```

### Account Validation

To prevent security vulnerabilities, it's important to verify that accounts
provided to an instruction are the expected accounts. Accounts are validated in
Anchor programs in two ways that are generally used together:

- [Account Constraints](/docs/references/account-constraints): Constraints
  define additional conditions that an account must satisfy to be considered
  valid for the instruction. Constraints are applied using the `#[account(..)]`
  attribute, which is placed above a field in a struct that implements the
  `Accounts` trait.

  You can find a full list of the constraints
  [here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/parser/accounts/constraints.rs)
  and implementation
  [here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/accounts/constraints.rs).

  ```rust
  #[derive(Accounts)]
  pub struct Initialize<'info> {
      // [!code highlight]
      #[account(init, payer = signer, space = 8 + 8)]
      pub new_account: Account<'info, NewAccount>,
       // [!code highlight]
      #[account(mut)]
      pub signer: Signer<'info>,
      pub system_program: Program<'info, System>,
  }
  ```

- [Account Types](/docs/references/account-types): Anchor provides various
  account types to help ensure that the account provided by the client matches
  what the program expects.

  You can find the implementation of the account types
  [here](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts).

  ```rust
  #[derive(Accounts)]
  pub struct Initialize<'info> {
      #[account(init, payer = signer, space = 8 + 8)]
      // [!code word: Account]
      pub new_account: Account<'info, NewAccount>,
      #[account(mut)]
      // [!code word:Signer]
      pub signer: Signer<'info>,
      // [!code word:Program]
      pub system_program: Program<'info, System>,
  }
  ```

When an instruction in an Anchor program is invoked, the program first validates
the accounts provided before executing the instruction's logic. After
validation, these accounts can be accessed within the instruction using the
`ctx.accounts` syntax.

```rust title="lib.rs"
// [!code word:new_account]
// [!code word:Initialize]
use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NewAccount {
    data: u64,
}
```

## #[account] attribute

The
[`#[account]`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L97)
attribute is applied to structs that define the structure of the data stored in
custom accounts created by your program.

```rust
// [!code highlight]
#[account]
pub struct NewAccount {
    data: u64,
}
```

This macro implements various traits
[detailed here](https://docs.rs/anchor-lang/latest/anchor_lang/attr.account.html).
The key functionalities of the `#[account]` macro include:

- [Assign Program Owner](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L130-L143):
  When creating an account, the program owner of the account is automatically
  set to the program specified in `declare_id`.
- [Set Discriminator](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L111-L128):
  A unique 8 byte discriminator, specific to the account type, is added as the
  first 8 bytes of account data during its initialization. This helps in
  differentiating account types and is used for account validation.
- [Data Serialization and Deserialization](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L224-L270):
  Account data is automatically serialized and deserialized as the account type.

```rust title="lib.rs"
// [!code word:NewAccount]
use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
       // [!code word:data :1]
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

// [!code word:data]
// [!code highlight:4]
#[account]
pub struct NewAccount {
    data: u64,
}
```

### Account Discriminator

An account discriminator in an Anchor program refers to an 8 byte identifier
unique to each account type. You can find the implementation of the account
discriminator
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L111-L128).

The discriminator is the first 8 bytes of the SHA256 hash of the string
`account:<AccountName>`. This discriminator is stored as the first 8 bytes of
account data when an account is created.

When creating an account in an Anchor program, 8 bytes must be allocated for the
discriminator.

```rust
// [!code word:8 ]
#[account(init, payer = signer, space = 8 + 8)]
pub new_account: Account<'info, NewAccount>,
```

The discriminator is used during the following two scenarios:

- Initialization: When an account is created, the discriminator is set as the
  first 8 bytes of the account's data.
- Deserialization: When account data is deserialized, the first 8 bytes of
  account data is checked against the discriminator of the expected account
  type.

If there's a mismatch, it indicates that the client has provided an unexpected
account. This mechanism serves as an account validation check in Anchor
programs.

````

File: anchor/docs/content/docs/basics/pda.mdx
```mdx
---
title: Program Derived Address
description:
  Learn how to use Program Derived Addresses (PDAs) in Anchor programs to create
  deterministic account addresses.
---

Program Derived Addresses (PDA) refer to a feature of Solana development that
allows you to create a unique address derived deterministically from pre-defined
inputs (seeds) and a program ID.

This section will cover basic examples of how to use PDAs in an Anchor program.

## Anchor PDA Constraints

When using PDAs in an Anchor program, you generally use Anchor's account
constraints to define the seeds to derive the PDA. These constraints serve as
security checks to ensure that the correct address is derived.

The constraints used to define the PDA seeds include:

- `seeds`: An array of optional seeds used to derive the PDA. Seeds can be
  static values or dynamic references to account data.
- `bump`: The bump seed used to derive the PDA. Used to ensure the address falls
  off the Ed25519 curve and is a valid PDA.
- `seeds::program` - (Optional) The program ID used to derive the PDA address.
  This constraint is only used to derive a PDA where the program ID is not the
  current program.

<Callout type="info">
  The `seeds` and `bump` constraints are required to be used together.
</Callout>

### Usage Examples

Below are examples demonstrating how to use PDA constraints in an Anchor
program.

<Tabs items={['seeds', 'bump', 'seeds::program', 'init']}>
<Tab value="seeds">

The `seeds` constraint specifies the optional values used to derive the PDA.

#### No Optional Seeds

- Use an empty array `[]` to define a PDA without optional seeds.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    #[account(
        // [!code highlight]
        seeds = [],
        bump,
    )]
    pub pda_account: SystemAccount<'info>,
}
````

#### Single Static Seed

- Specify optional seeds in the `seeds` constraint.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    #[account(
        // [!code word:b"hello_world"]
        // [!code highlight]
        seeds = [b"hello_world"],
        bump,
    )]
    pub pda_account: SystemAccount<'info>,
}
```

#### Multiple Seeds and Account References

- Multiple seeds can be specified in the `seeds` constraint. The `seeds`
  constraint can also reference other account addresses or account data.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    pub signer: Signer<'info>,
    #[account(
        // [!code highlight]
        seeds = [b"hello_world", signer.key().as_ref()],
        bump,
    )]
    pub pda_account: SystemAccount<'info>,
}
```

The example above uses both a static seed (`b"hello_world"`) and a dynamic seed
(the signer's public key).

</Tab>
<Tab value="bump">

The `bump` constraint specifies the bump seed used to derive the PDA.

#### Automatic Bump Calculation

When using the `bump` constraint without a value, the bump is automatically
calculated each time the instruction is invoked.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    #[account(
        seeds = [b"hello_world"],
        // [!code highlight]
        bump,
    )]
    pub pda_account: SystemAccount<'info>,
}
```

#### Specify Bump Value

You can explicitly provide the bump value, which is useful for optimizing
compute unit usage. This assumes that the PDA account has been created and the
bump seed is stored as a field on an existing account.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    #[account(
        seeds = [b"hello_world"],
        // [!code highlight]
        bump = pda_account.bump_seed,
    )]
    pub pda_account: Account<'info, CustomAccount>,
}

#[account]
pub struct CustomAccount {
    pub bump_seed: u8,
}
```

By storing the bump value in the account's data, the program doesn't need to
recalculate it, saving compute units. The saved bump value can be stored on the
account itself or another account.

</Tab>
<Tab value="seeds::program">

The `seeds::program` constraint specifies the program ID used to derive the PDA.
This constraint is only used when deriving a PDA from a different program.

Use this constraint when your instruction needs to interact with PDA accounts
created by another program.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    #[account(
        seeds = [b"hello_world"],
        bump,
        // [!code word:other_program]
        // [!code highlight]
        seeds::program = other_program.key(),
    )]
    pub pda_account: SystemAccount<'info>,
    pub other_program: Program<'info, OtherProgram>,
}
```

</Tab>
<Tab value="init">

The `init` constraint is commonly used with `seeds` and `bump` to create a new
account with an address that is a PDA. Under the hood, the `init` constraint
invokes the System Program to create the account.

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        // [!code word:init]
        // [!code highlight:3]
        init,
        payer = signer,
        space = 8 + 1,
        seeds = [b"hello_world", signer.key().as_ref()],
        bump,
    )]
    pub pda_account: Account<'info, CustomAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct CustomAccount {
    pub bump_seed: u8,
}
```

<Callout type="info">
  The `init` constraint must be used with `payer` and `space`. The `payer`
  specifies the account that will pay for the account creation. The `space`
  specifies the bytes to allocate for the account (including the 8-byte
  discriminator).
</Callout>

</Tab>
</Tabs>

## PDA seeds in the IDL

Program Derived Address (PDA) seeds defined in the `seeds` constraint are
included in the program's IDL file. This allows the Anchor client to
automatically resolve account addresses using these seeds when constructing
instructions.

This example below shows the relationship between the program, IDL, and client.

<Tabs items={['Program', 'IDL', 'Client']}>
<Tab value="Program">

The program below defines a `pda_account` using a static seed (`b"hello_world"`)
and the signer's public key as a dynamic seed.

```rust
use anchor_lang::prelude::*;

declare_id!("BZLiJ62bzRryYp9mRobz47uA66WDgtfTXhhgM25tJyx5");

#[program]
mod hello_anchor {
    use super::*;
    pub fn test_instruction(ctx: Context<InstructionAccounts>) -> Result<()> {
        msg!("PDA: {}", ctx.accounts.pda_account.key());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:signer]
    pub signer: Signer<'info>,
    #[account(
        // [!code highlight]
        seeds = [b"hello_world", signer.key().as_ref()],
        bump,
    )]
    pub pda_account: SystemAccount<'info>,
}
```

</Tab>
<Tab value="IDL">

The program's IDL file includes the PDA seeds defined in the `seeds` constraint.

- The static seed `b"hello_world"` is converted to byte values.
- The dynamic seed is included as reference to the signer account.

```json
{
  "address": "BZLiJ62bzRryYp9mRobz47uA66WDgtfTXhhgM25tJyx5",
  "metadata": {
    "name": "hello_anchor",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "test_instruction",
      "discriminator": [33, 223, 61, 208, 32, 193, 201, 79],
      "accounts": [
        {
          "name": "signer",
          "signer": true
        },
        {
          "name": "pda_account",
          "pda": {
            // [!code word:seeds]
            "seeds": [
              {
                // [!code highlight:2]
                "kind": "const",
                "value": [104, 101, 108, 108, 111, 95, 119, 111, 114, 108, 100]
              },
              {
                // [!code highlight:2]
                "kind": "account",
                "path": "signer"
              }
            ]
          }
        }
      ],
      "args": []
    }
  ]
}
```

</Tab>
<Tab value="Client">

The Anchor client can automatically resolve the PDA address using the IDL file.

In the example below, Anchor automatically resolves the PDA address using the
provider wallet as the signer, and its public key as the dynamic seed for PDA
derivation. This removes the need to explicitly derive the PDA when building the
instruction.

```ts {13}
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { HelloAnchor } from "../target/types/hello_anchor";

describe("hello_anchor", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.HelloAnchor as Program<HelloAnchor>;

  it("Is initialized!", async () => {
    // Account address is automatically resolved using the IDL
    const tx = await program.methods.testInstruction().rpc();
    console.log("Your transaction signature", tx);
  });
});
```

When the instruction is invoked, the PDA is printed to program logs as defined
in the program instruction.

```{3}
Program BZLiJ62bzRryYp9mRobz47uA66WDgtfTXhhgM25tJyx5 invoke [1]
Program log: Instruction: TestInstruction
Program log: PDA: 3Hikt5mpKaSS4UNA5Du1TZJ8tp4o8VC8YWW6X9vtfVnJ
Program BZLiJ62bzRryYp9mRobz47uA66WDgtfTXhhgM25tJyx5 consumed 18505 of 200000 compute units
Program BZLiJ62bzRryYp9mRobz47uA66WDgtfTXhhgM25tJyx5 success
```

</Tab>
</Tabs>

````

File: anchor/docs/content/docs/clients/meta.json
```json
{
  "title": "Client Libraries",
  "pages": ["typescript", "rust"]
}

````

File: anchor/docs/content/docs/clients/rust.mdx

````mdx
---
title: Rust
description: Learn how to use Anchor's Rust client library to interact with Solana programs
---

The [`anchor-client`](https://docs.rs/anchor-client/latest/anchor_client/) crate
is the Rust client library for interacting with Anchor programs. You can find
the source code [here](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/client).

## Example

The example below demonstrates how to use the `anchor-client` crate to interact
with a simple Anchor program. The program client can be automatically generated
from the program's IDL using the `declare_program!` macro. This macro generates
dependency free modules that enable you to interact with the program's
instructions and accounts.

The program has two instructions:

- `initialize` â€“ Creates and initializes a counter account to store a value
- `increment` â€“ Increments the value stored on the counter account

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC");

#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let counter = &ctx.accounts.counter;
        msg!("Counter account created! Current count: {}", counter.count);
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        msg!("Previous counter: {}", counter.count);

        counter.count += 1;
        msg!("Counter incremented! Current count: {}", counter.count);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,

    #[account(
        init,
        payer = payer,
        space = 8 + 8
    )]
    pub counter: Account<'info, Counter>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub counter: Account<'info, Counter>,
}

#[account]
pub struct Counter {
    pub count: u64,
}
```
````

Below is an example folder structure for a Rust client that interacts with the
Anchor program:

<Files>
  <Folder name="client-example" defaultOpen={true}>
    <Folder name="idls" defaultOpen={true}>
      <File name="example.json" />
    </Folder>
    <Folder name="src" defaultOpen={true}>
      <File name="main.rs" />
    </Folder>
    <Folder name="target" />
    <File name="Cargo.toml" />
  </Folder>
</Files>

The program IDL must be in a `/idls` folder. The `declare_program!` macro
searches for the IDL in the `/idls` folder to generate the client modules.

```json title="idls/example.json"
{
  "address": "6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC",
  "metadata": {
    "name": "example",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "increment",
      "discriminator": [11, 18, 104, 9, 104, 174, 59, 33],
      "accounts": [
        {
          "name": "counter",
          "writable": true
        }
      ],
      "args": []
    },
    {
      "name": "initialize",
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
      "accounts": [
        {
          "name": "payer",
          "writable": true,
          "signer": true
        },
        {
          "name": "counter",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "Counter",
      "discriminator": [255, 176, 4, 245, 188, 253, 124, 25]
    }
  ],
  "types": [
    {
      "name": "Counter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "count",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

Below is the `src/main.rs` file for interacting with the program:

1. The `declare_program!` macro - Generates client modules for the program using
   the IDL file

2. The `anchor_client` crate - Provides utilities for interacting with the
   program, including:
   - Building program instructions
   - Sending transactions
   - Fetching program accounts

```rust title="src/main.rs"
use anchor_client::{
    solana_client::rpc_client::RpcClient,
    solana_sdk::{
        commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Keypair,
        signer::Signer, system_program,
    },
    Client, Cluster,
};
use anchor_lang::prelude::*;
use std::rc::Rc;

declare_program!(example);
use example::{accounts::Counter, client::accounts, client::args};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://127.0.0.1:8899", // Local validator URL
        CommitmentConfig::confirmed(),
    );

    // Generate Keypairs and request airdrop
    let payer = Keypair::new();
    let counter = Keypair::new();
    println!("Generated Keypairs:");
    println!("   Payer: {}", payer.pubkey());
    println!("   Counter: {}", counter.pubkey());

    println!("\nRequesting 1 SOL airdrop to payer");
    let airdrop_signature = connection.request_airdrop(&payer.pubkey(), LAMPORTS_PER_SOL)?;

    // Wait for airdrop confirmation
    while !connection.confirm_transaction(&airdrop_signature)? {
        std::thread::sleep(std::time::Duration::from_millis(100));
    }
    println!("   Airdrop confirmed!");

    // Create program client
    let provider = Client::new_with_options(
        Cluster::Localnet,
        Rc::new(payer),
        CommitmentConfig::confirmed(),
    );
    let program = provider.program(example::ID)?;

    // Build and send instructions
    println!("\nSend transaction with initialize and increment instructions");
    let initialize_ix = program
        .request()
        .accounts(accounts::Initialize {
            counter: counter.pubkey(),
            payer: program.payer(),
            system_program: system_program::ID,
        })
        .args(args::Initialize)
        .instructions()?
        .remove(0);

    let increment_ix = program
        .request()
        .accounts(accounts::Increment {
            counter: counter.pubkey(),
        })
        .args(args::Increment)
        .instructions()?
        .remove(0);

    let signature = program
        .request()
        .instruction(initialize_ix)
        .instruction(increment_ix)
        .signer(&counter)
        .send()
        .await?;
    println!("   Transaction confirmed: {}", signature);

    println!("\nFetch counter account data");
    let counter_account: Counter = program.account::<Counter>(counter.pubkey()).await?;
    println!("   Counter value: {}", counter_account.count);
    Ok(())
}
```

Below are the dependencies for the `Cargo.toml` file:

```toml title="Cargo.toml"
[package]
name = "rs"
version = "0.1.0"
edition = "2021"

[dependencies]
anchor-client = { version = "0.31.0", features = ["async"] }
anchor-lang = "0.31.0"
anyhow = "1.0.93"
tokio = { version = "1.0", features = ["full"] }
```

````

File: anchor/docs/content/docs/clients/typescript.mdx
```mdx
---
title: TypeScript
description:
  Learn how to use Anchor's TypeScript client library to interact with Solana
  programs
---

Anchor provides a Typescript client library
([@coral-xyz/anchor](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor))
that simplifies the process of interacting with Solana programs from the client
in JavaScript or TypeScript.

<Callout type="info">
  The `@coral-xyz/anchor` library is only compatible with the legacy version
  (v1) of `@solana/web3.js` and `@solana/spl-token`. It is not compatible with
  the new version (v2) of `@solana/web3.js`.
</Callout>

## Client Program

To interact with an Anchor program using `@coral-xyz/anchor`, you'll need to
create a
[`Program`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/index.ts#L58)
instance using the program's [IDL file](/docs/basics/idl).

Creating an instance of the `Program` requires the program's IDL and an
[`AnchorProvider`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/provider.ts#L59).
An `AnchorProvider` is an abstraction that combines two things:

- `Connection` - the connection to a Solana cluster (i.e. localhost, devnet,
  mainnet)
- `Wallet` - (optional) a default wallet used to pay for and sign transactions

<Tabs items={['Frontend/Node', 'Test File']}>
<Tab value="Frontend/Node">

When integrating with a frontend using the
[Solana wallet adapter](https://github.com/anza-xyz/wallet-adapter), you'll need
to set up the `AnchorProvider` and `Program`.

```ts title="example"
import { Program, AnchorProvider, setProvider } from "@coral-xyz/anchor";
import { useAnchorWallet, useConnection } from "@solana/wallet-adapter-react";
import type { HelloAnchor } from "./idlType";
import idl from "./idl.json";

const { connection } = useConnection();
const wallet = useAnchorWallet();

// [!code word:AnchorProvider]
// [!code highlight:2]
const provider = new AnchorProvider(connection, wallet, {});
setProvider(provider);

// [!code word:Program]
// [!code highlight:3]
export const program = new Program(idl as HelloAnchor, {
  connection,
});
````

In the code snippet above:

- `idl.json` is the IDL file generated by Anchor, found at
  `/target/idl/<program-name>.json` in an Anchor project.
- `idlType.ts` is the IDL type (for use with TypeScript), found at
  `/target/types/<program-name>.ts` in an Anchor project.

Alternatively, you can create an `Program` instance using only the IDL and the
`Connection` to a Solana cluster. This means there is no default `Wallet`, but
allows you to use the `Program` to fetch accounts or build instructions without
a connected wallet.

```ts
import { clusterApiUrl, Connection, PublicKey } from "@solana/web3.js";
import { Program } from "@coral-xyz/anchor";
import type { HelloAnchor } from "./idlType";
import idl from "./idl.json";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// [!code word:Program]
// [!code highlight:3]
export const program = new Program(idl as HelloAnchor, {
  connection,
});
```

</Tab>
<Tab value="Test File">

When creating a new Anchor project, a default test file is generated that
includes a `Program` instance. This setup differs from applications outside the
Anchor workspace (like React or Node.js) where you'll need to manually create
the `Program` instance.

```ts
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { HelloAnchor } from "../target/types/hello_anchor";

describe("hello_anchor", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  // [!code highlight]
  const program = anchor.workspace.HelloAnchor as Program<HelloAnchor>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.methods.initialize().rpc();
    console.log("Your transaction signature", tx);
  });
});
```

</Tab>
</Tabs>

## Invoke Instructions

Once the `Program` is set up using a program's IDL file, you can use the Anchor
[`MethodsBuilder`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/methods.ts#L155)
to:

- Build individual instructions
- Build transactions
- Build and send transactions

The basic format looks like the following:

<Tabs items={['methods', 'instruction', 'accounts', `signers`]}>
<Tab value="methods">

`program.methods` - This is the builder API for creating instruction calls from
the program's IDL

```ts
// [!code word:methods]
// [!code highlight]
await program.methods
  .instructionName(instructionData)
  .accounts({})
  .signers([])
  .rpc();
```

</Tab>
<Tab value="instruction">

Following `.methods`, specify the name of an instruction from the program IDL,
passing in any required arguments as comma-separated values.

```ts
// [!code word:instructionName]
await program.methods
  // [!code highlight]
  .instructionName(instructionData1, instructionData2)
  .accounts({})
  .signers([])
  .rpc();
```

</Tab>
<Tab value="accounts">

`.accounts` - Pass in the address of the accounts required by the instruction as
specified in the IDL

```ts
// [!code word:accounts]
await program.methods
  .instructionName(instructionData)
  // [!code highlight]
  .accounts({})
  .signers([])
  .rpc();
```

Note that certain account addresses don't need to be explicitly provided, as
they can automatically resolve using information included in the IDL. These
typically include:

- Common accounts (ex. the System Program)
- Accounts where the address is a PDA (Program Derived Address)

</Tab>
<Tab value="signers">

`.signers` - Optionally pass in an array of keypairs required as additional
signers by the instruction. This is commonly used when creating new accounts
where the account address is the public key of a newly generated keypair.

```ts
// [!code word:signers]
await program.methods
  .instructionName(instructionData)
  .accounts({})
  // [!code highlight]
  .signers([])
  .rpc();
```

<Callout type="info">
  Note that `.signers` should only be used when also using `.rpc()`. When using
  `.transaction()` or `.instruction()`, signers should be added to the
  transaction before sending.
</Callout>

</Tab>
</Tabs>

Anchor provides multiple methods for building program instructions:

<Tabs items={['.rpc', '.transaction', '.instruction']}>
<Tab value=".rpc">

The
[`rpc()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/methods.ts#L428)
method
[sends a signed transaction](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/rpc.ts#L29)
with the specified instruction and returns a `TransactionSignature`.

When using `.rpc`, the `Wallet` from the `Provider` is automatically included as
a signer.

```ts
// Generate keypair for the new account
const newAccountKp = new Keypair();

const data = new BN(42);
const transactionSignature = await program.methods
  .initialize(data)
  .accounts({
    newAccount: newAccountKp.publicKey,
    signer: wallet.publicKey,
    systemProgram: SystemProgram.programId,
  })
  .signers([newAccountKp])
  // [!code word:rpc]
  // [!code highlight]
  .rpc();
```

</Tab>
<Tab value=".transaction">

The
[`transaction()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/methods.ts#L348)
method
[builds a `Transaction`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/transaction.ts#L18-L26)
with the specified instruction without sending the transaction.

```ts
// Generate keypair for the new account
const newAccountKp = new Keypair();

const data = new BN(42);
const transaction = await program.methods
  .initialize(data)
  .accounts({
    newAccount: newAccountKp.publicKey,
    signer: wallet.publicKey,
    systemProgram: SystemProgram.programId,
  })
  // [!code word:transaction:1]
  // [!code highlight]
  .transaction();

const transactionSignature = await connection.sendTransaction(transaction, [
  wallet.payer,
  newAccountKp,
]);
```

</Tab>
<Tab value=".instruction">

The
[`instruction()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/methods.ts#L323)
method
[builds a `TransactionInstruction`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/instruction.ts#L57-L61)
using the specified instruction. This is useful if you want to manually add the
instruction to a transaction and combine it with other instructions.

```ts
// Generate keypair for the new account
const newAccountKp = new Keypair();

const data = new BN(42);
const instruction = await program.methods
  .initialize(data)
  .accounts({
    newAccount: newAccountKp.publicKey,
    signer: wallet.publicKey,
    systemProgram: SystemProgram.programId,
  })
  // [!code word:instruction:1]
  // [!code highlight]
  .instruction();

const transaction = new Transaction().add(instruction);

const transactionSignature = await connection.sendTransaction(transaction, [
  wallet.payer,
  newAccountKp,
]);
```

</Tab> 
</Tabs>

## Fetch Accounts

The `Program` client simplifies the process of fetching and deserializing
accounts created by your Anchor program.

Use `program.account` followed by the name of the account type defined in the
IDL. Anchor provides multiple methods for fetching accounts.

<Tabs items={['all', 'memcmp', 'fetch', 'fetchMultiple']}>
<Tab value="all">

Use
[`all()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/account.ts#L251)
to fetch all existing accounts for a specific account type.

```ts
// [!code word:all]
const accounts = await program.account.newAccount.all();
```

</Tab>
<Tab value="memcmp">

Use `memcmp` (memory compare) to filter for account data that matches a specific
value at a specific offset. Using `memcmp` requires you to understand the byte
layout of the data field for the account type you are fetching.

When calculating the offset, remember that the first 8 bytes in accounts created
by an Anchor program are reserved for the account discriminator.

```ts
// [!code word:memcmp]
const accounts = await program.account.newAccount.all([
  {
    // [!code highlight:4]
    memcmp: {
      offset: 8,
      bytes: "",
    },
  },
]);
```

</Tab>
<Tab value="fetch">

Use
[`fetch()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/account.ts#L165)
to fetch the account data for a single account

```ts
// [!code word:fetch]
const account = await program.account.newAccount.fetch(ACCOUNT_ADDRESS);
```

</Tab>
<Tab value="fetchMultiple">

Use
[`fetchMultiple()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/namespace/account.ts#L200)
to fetch the account data for multiple accounts by passing in an array of
account addresses

```ts
// [!code word:fetchMultiple]
const accounts = await program.account.newAccount.fetchMultiple([
  ACCOUNT_ADDRESS_ONE,
  ACCOUNT_ADDRESS_TWO,
]);
```

</Tab>
</Tabs>

## Example

The example below demonstrates how to use `@coral-xyz/anchor` to interact with a
simple Anchor program. The program has two instructions:

- `initialize` â€“ Creates and initializes a counter account to store a value
- `increment` â€“ Increments the value stored on the counter account

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC");

#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let counter = &ctx.accounts.counter;
        msg!("Counter account created! Current count: {}", counter.count);
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        msg!("Previous counter: {}", counter.count);

        counter.count += 1;
        msg!("Counter incremented! Current count: {}", counter.count);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,

    #[account(
        init,
        payer = payer,
        space = 8 + 8
    )]
    pub counter: Account<'info, Counter>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub counter: Account<'info, Counter>,
}

#[account]
pub struct Counter {
    pub count: u64,
}
```

Below is an example folder structure for a TypeScript client that interacts with
the Anchor program:

<Files>
  <Folder name="ts" defaultOpen={true}>
    <Folder name="idl" defaultOpen={true}>
      <File name="example.json" />
      <File name="example.ts" />
    </Folder>
    <File name="example.ts" />
    <File name="package.json" />
  </Folder>
</Files>

The `/idl` directory in the example includes two files:

- `example.json`: The IDL file for the program
- `example.ts`: A TypeScript type definition file generated for the IDL

The tabs below include the `example.json` and `example.ts` files as a reference
of what these files look like.

<Tabs items={["example.json", "example.ts"]}>

```json tab="example.json"
{
  "address": "6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC",
  "metadata": {
    "name": "example",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "increment",
      "discriminator": [11, 18, 104, 9, 104, 174, 59, 33],
      "accounts": [
        {
          "name": "counter",
          "writable": true
        }
      ],
      "args": []
    },
    {
      "name": "initialize",
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
      "accounts": [
        {
          "name": "payer",
          "writable": true,
          "signer": true
        },
        {
          "name": "counter",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "Counter",
      "discriminator": [255, 176, 4, 245, 188, 253, 124, 25]
    }
  ],
  "types": [
    {
      "name": "Counter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "count",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

```ts tab="example.ts"
/**
 * Program IDL in camelCase format in order to be used in JS/TS.
 *
 * Note that this is only a type helper and is not the actual IDL. The original
 * IDL can be found at `target/idl/example.json`.
 */
export type Example = {
  address: "6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC";
  metadata: {
    name: "example";
    version: "0.1.0";
    spec: "0.1.0";
    description: "Created with Anchor";
  };
  instructions: [
    {
      name: "increment";
      discriminator: [11, 18, 104, 9, 104, 174, 59, 33];
      accounts: [
        {
          name: "counter";
          writable: true;
        }
      ];
      args: [];
    },
    {
      name: "initialize";
      discriminator: [175, 175, 109, 31, 13, 152, 155, 237];
      accounts: [
        {
          name: "payer";
          writable: true;
          signer: true;
        },
        {
          name: "counter";
          writable: true;
          signer: true;
        },
        {
          name: "systemProgram";
          address: "11111111111111111111111111111111";
        }
      ];
      args: [];
    }
  ];
  accounts: [
    {
      name: "counter";
      discriminator: [255, 176, 4, 245, 188, 253, 124, 25];
    }
  ];
  types: [
    {
      name: "counter";
      type: {
        kind: "struct";
        fields: [
          {
            name: "count";
            type: "u64";
          }
        ];
      };
    }
  ];
};
```

</Tabs>

<Callout type="info">

When you run `anchor build` in an Anchor project, the Anchor CLI automatically
generates:

- The IDL file (`.json`) in the `target/idl` folder (ex.
  `target/idl/example.json`)

- The TypeScript type definitions (`.ts`) in the `target/types` folder (ex.
  `target/types/example.ts`)

</Callout>

The `example.ts` file below includes the script to interact with the program.

```ts title="example.ts"
import {
  Connection,
  Keypair,
  LAMPORTS_PER_SOL,
  Transaction,
  sendAndConfirmTransaction,
} from "@solana/web3.js";
import { Program } from "@coral-xyz/anchor";
import type { Example } from "./idl/example.ts";
import idl from "./idl/example.json";

// Set up a connection to the cluster
const connection = new Connection("http://127.0.0.1:8899", "confirmed");

// Create a Program instance using the IDL and connection
const program = new Program(idl as Example, {
  connection,
});

// Generate new Keypairs for the payer and the counter account
const payer = Keypair.generate();
const counter = Keypair.generate();

// Airdrop SOL to fund the payer's account for transaction fees
const airdropTransactionSignature = await connection.requestAirdrop(
  payer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropTransactionSignature);

// Build the initialize instruction
const initializeInstruction = await program.methods
  .initialize()
  .accounts({
    payer: payer.publicKey,
    counter: counter.publicKey,
  })
  .instruction();

// Build the increment instruction
const incrementInstruction = await program.methods
  .increment()
  .accounts({
    counter: counter.publicKey,
  })
  .instruction();

// Add both instructions to a single transaction
const transaction = new Transaction().add(
  initializeInstruction,
  incrementInstruction
);

// Send the transaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [payer, counter]
);
console.log("Transaction Signature", transactionSignature);

// Fetch the counter account
const counterAccount = await program.account.counter.fetch(counter.publicKey);
console.log("Count:", counterAccount.count);
```

````

File: anchor/docs/content/docs/features/declare-program.mdx
```mdx
---
title: Dependency Free Composability
description:
  Learn how to use Anchor's declare_program macro to interact with programs
  without additional dependencies.
---

The
[`declare_program!()`](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program)
macro simplifies the process of interacting with Anchor programs by generating
Rust modules (from a program's IDL) that can be used in both on-chain and
off-chain code. You can find an example program
[here](https://github.com/coral-xyz/anchor/tree/master/tests/declare-program).

The following modules are generated by the `declare_program!()` macro:

| Module                                                                                                                                                        | Description                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| [`cpi`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/cpi.rs)             | Helper functions for making cross-program invocations (CPIs) to the program from other on-chain programs |
| [`client`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/client.rs)       | Accounts and arguments required to build program instructions to add to client-side transactions         |
| [`account`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/accounts.rs)    | Account data types (program state) defined in the program                                                |
| [`program`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/program.rs)     | Program ID constant used to identify the program                                                         |
| [`constants`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/constants.rs) | Program constants defined in the program                                                                 |
| [`events`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/events.rs)       | Program events defined in the program                                                                    |
| [`types`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/program/src/declare_program/mods/types.rs)         | Program types defined in the program                                                                     |

## Examples

The following examples demonstrate how to use the `declare_program!()` macro in
two scenarios:

1. Making Cross Program Invocations (CPIs) from one program to another program
2. Building client-side transactions to invoke a program's instructions

Both examples show how the modules generated by the `declare_program!()` macro
simplify program interactions, whether you're writing on-chain or off-chain
code.

### On-chain CPI

To use the `declare_program!()` macro, you need the IDL file for the target
program. The IDL file must be placed in a directory named `/idls` in your
project. The `/idls` directory can be located at any level in your project
structure. For example, your project could have this layout:

<Files>
  <Folder name="idls" defaultOpen={true}>
    <File name="example.json" />
  </Folder>
  <Folder name="programs" defaultOpen={true}>
    <Folder name="example-cpi" defaultOpen={true}>
      <Folder name="src" defaultOpen={true}>
        <File name="lib.rs" />
      </Folder>
      <File name="Cargo.toml" />
    </Folder>
  </Folder>
</Files>

Below is the source code (`lib.rs`) for the target (callee) program that
generates the `example.json` IDL file shown above.

Using the program's IDL file, another program can use the `declare_program!()`
macro to generate a CPI module, enabling it to make CPIs to this program's
instructions.

<Tabs items={["Callee Program", "IDL"]}>

```rust tab="Callee Program"
use anchor_lang::prelude::*;

declare_id!("8HupNBr7SBhBLcBsLhbtes3tCarBm6Bvpqp5AfVjHuj8");

#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let counter = &ctx.accounts.counter;
        msg!("Counter account created! Current count: {}", counter.count);
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        msg!("Previous counter: {}", counter.count);

        counter.count += 1;
        msg!("Counter incremented! Current count: {}", counter.count);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,

    #[account(
        init,
        payer = payer,
        space = 8 + 8
    )]
    pub counter: Account<'info, Counter>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub counter: Account<'info, Counter>,
}

#[account]
pub struct Counter {
    pub count: u64,
}
````

```ts tab="IDL"
{
  "address": "8HupNBr7SBhBLcBsLhbtes3tCarBm6Bvpqp5AfVjHuj8",
  "metadata": {
    "name": "example",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "increment",
      "discriminator": [
        11,
        18,
        104,
        9,
        104,
        174,
        59,
        33
      ],
      "accounts": [
        {
          "name": "counter",
          "writable": true
        }
      ],
      "args": []
    },
    {
      "name": "initialize",
      "discriminator": [
        175,
        175,
        109,
        31,
        13,
        152,
        155,
        237
      ],
      "accounts": [
        {
          "name": "payer",
          "writable": true,
          "signer": true
        },
        {
          "name": "counter",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "Counter",
      "discriminator": [
        255,
        176,
        4,
        245,
        188,
        253,
        124,
        25
      ]
    }
  ],
  "types": [
    {
      "name": "Counter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "count",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

</Tabs>

Below is the source code (`lib.rs`) for the caller program (example-cpi) that
uses the `declare_program!()` macro to generate a CPI module to invoke the
instructions defined in the callee program above.

<Tabs items={["Caller Program", "Test"]}>

```rust tab="Caller Program"
use anchor_lang::prelude::*;

declare_id!("GENmb1D59wqCKRwujq4PJ8461EccQ5srLHrXyXp4HMTH");

// [!code word:declare_program]
// [!code highlight:9]
declare_program!(example);
use example::{
    accounts::Counter,
    cpi::{
        self,
        accounts::{Increment, Initialize},
    },
    program::Example,
};

#[program]
pub mod example_cpi {

    use super::*;

    pub fn initialize_cpi(ctx: Context<InitializeCpi>) -> Result<()> {
        // Create CPI context for initialize
        let cpi_ctx = CpiContext::new(
            ctx.accounts.example_program.to_account_info(),
            Initialize {
                payer: ctx.accounts.payer.to_account_info(),
                counter: ctx.accounts.counter.to_account_info(),
                system_program: ctx.accounts.system_program.to_account_info(),
            },
        );

        // Invoke the initialize instruction
        cpi::initialize(cpi_ctx)?;
        Ok(())
    }

    pub fn increment_cpi(ctx: Context<IncrementCpi>) -> Result<()> {
        // Create CPI context for increment
        let cpi_ctx = CpiContext::new(
            ctx.accounts.example_program.to_account_info(),
            Increment {
                counter: ctx.accounts.counter.to_account_info(),
            },
        );

        // Invoke the increment instruction
        cpi::increment(cpi_ctx)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeCpi<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(mut)]
    pub counter: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub example_program: Program<'info, Example>,
}

#[derive(Accounts)]
pub struct IncrementCpi<'info> {
    #[account(mut)]
    pub counter: Account<'info, Counter>,
    pub example_program: Program<'info, Example>,
}
```

```ts tab="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Example } from "../target/types/example";
import { ExampleCpi } from "../target/types/example_cpi";
import { Keypair } from "@solana/web3.js";

describe("example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.Example as Program<Example>;
  const cpiProgram = anchor.workspace.ExampleCpi as Program<ExampleCpi>;

  const counterAccount = Keypair.generate();

  it("Is initialized!", async () => {
    const transactionSignature = await cpiProgram.methods
      .initializeCpi()
      .accounts({
        counter: counterAccount.publicKey,
      })
      .signers([counterAccount])
      .rpc({ skipPreflight: true });

    const accountData = await program.account.counter.fetch(
      counterAccount.publicKey
    );

    console.log(`Transaction Signature: ${transactionSignature}`);
    console.log(`Count: ${accountData.count}`);
  });

  it("Increment", async () => {
    const transactionSignature = await cpiProgram.methods
      .incrementCpi()
      .accounts({
        counter: counterAccount.publicKey,
      })
      .rpc();

    const accountData = await program.account.counter.fetch(
      counterAccount.publicKey
    );

    console.log(`Transaction Signature: ${transactionSignature}`);
    console.log(`Count: ${accountData.count}`);
  });
});
```

</Tabs>

#### Explanation

<Steps>

<Step>

The `declare_program!()` macro takes a single argument - the name of the
program's IDL file (e.g. `example.json`):

```rust
declare_program!(example);  // Looks for /idls/example.json
```

</Step>

<Step>

Bring into scope the generated modules:

```rust
use example::{
    accounts::Counter, // Account types
    cpi::{             // Cross program invocation helpers
        self,
        accounts::{Increment, Initialize},
    },
    program::Example,  // Program type
};
```

</Step>

<Step>

Use the imported types in the account validation structs:

```rust
#[derive(Accounts)]
pub struct IncrementCpi<'info> {
    // Counter type from accounts module
    #[account(mut)]
    // [!code word:Counter]
    // [!code highlight]
    pub counter: Account<'info, Counter>,

    // Example type from program module
    // [!code word:Example]
    // [!code highlight]
    pub example_program: Program<'info, Example>,
}
```

</Step>

<Step>

Use the CPI module to invoke the program's instructions:

```rust
pub fn initialize_cpi(ctx: Context<InitializeCpi>) -> Result<()> {
    // Create CPI context for initialize
    let cpi_ctx = CpiContext::new(
        ctx.accounts.example_program.to_account_info(),
        Initialize {
            payer: ctx.accounts.payer.to_account_info(),
            counter: ctx.accounts.counter.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
        },
    );

    // Invoke the initialize instruction
    // [!code highlight]
    cpi::initialize(cpi_ctx)?;
    Ok(())
}
```

```rust
pub fn increment_cpi(ctx: Context<IncrementCpi>) -> Result<()> {
    // Create CPI context for increment
    let cpi_ctx = CpiContext::new(
        ctx.accounts.example_program.to_account_info(),
        Increment {
            counter: ctx.accounts.counter.to_account_info(),
        },
    );

    // Invoke the increment instruction
    // [!code highlight]
    cpi::increment(cpi_ctx)?;
    Ok(())
}
```

</Step>

</Steps>

### Off-chain Client

To use the `declare_program!()` macro, you need the IDL file for the target
program. The IDL file must be placed in a directory named `/idls` in your
project. The `/idls` directory can be located at any level in your project
structure. For example, your project could have this layout:

<Files>
  <Folder name="idls" defaultOpen={true}>
    <File name="example.json" />
  </Folder>
  <Folder name="src" defaultOpen={true}>
    <File name="main.rs" />
  </Folder>
  <File name="Cargo.toml" />
</Files>

Below is the source code (`lib.rs`) for the target program that generates the
`example.json` IDL file shown above. The program's IDL can then be used in a
client script along with the `declare_program!()` macro to generate a Client
module to build the program's instructions.

<Tabs items={["Callee Program", "IDL"]}>

```rust tab="Callee Program"
use anchor_lang::prelude::*;

declare_id!("6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC");

#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let counter = &ctx.accounts.counter;
        msg!("Counter account created! Current count: {}", counter.count);
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        msg!("Previous counter: {}", counter.count);

        counter.count += 1;
        msg!("Counter incremented! Current count: {}", counter.count);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,

    #[account(
        init,
        payer = payer,
        space = 8 + 8
    )]
    pub counter: Account<'info, Counter>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub counter: Account<'info, Counter>,
}

#[account]
pub struct Counter {
    pub count: u64,
}
```

```ts tab="IDL"
{
  "address": "6khKp4BeJpCjBY1Eh39ybiqbfRnrn2UzWeUARjQLXYRC",
  "metadata": {
    "name": "example",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "increment",
      "discriminator": [11, 18, 104, 9, 104, 174, 59, 33],
      "accounts": [
        {
          "name": "counter",
          "writable": true
        }
      ],
      "args": []
    },
    {
      "name": "initialize",
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
      "accounts": [
        {
          "name": "payer",
          "writable": true,
          "signer": true
        },
        {
          "name": "counter",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "Counter",
      "discriminator": [255, 176, 4, 245, 188, 253, 124, 25]
    }
  ],
  "types": [
    {
      "name": "Counter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "count",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

</Tabs>

Below is the client script (main.rs) that uses the `declare_program!()` macro to
generate a Client module to build the program's instructions.

<Tabs items={["Client Script", "Dependencies"]}>

```rust tab="Client Script"
use anchor_client::{
    solana_client::rpc_client::RpcClient,
    solana_sdk::{
        commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Keypair,
        signer::Signer, system_program,
    },
    Client, Cluster,
};
use anchor_lang::prelude::*;
use std::rc::Rc;

declare_program!(example);
use example::{accounts::Counter, client::accounts, client::args};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://127.0.0.1:8899", // Local validator URL
        CommitmentConfig::confirmed(),
    );

    // Generate Keypairs and request airdrop
    let payer = Keypair::new();
    let counter = Keypair::new();
    println!("Generated Keypairs:");
    println!("   Payer: {}", payer.pubkey());
    println!("   Counter: {}", counter.pubkey());

    println!("\nRequesting 1 SOL airdrop to payer");
    let airdrop_signature = connection.request_airdrop(&payer.pubkey(), LAMPORTS_PER_SOL)?;

    // Wait for airdrop confirmation
    while !connection.confirm_transaction(&airdrop_signature)? {
        std::thread::sleep(std::time::Duration::from_millis(100));
    }
    println!("   Airdrop confirmed!");

    // Create program client
    let provider = Client::new_with_options(
        Cluster::Localnet,
        Rc::new(payer),
        CommitmentConfig::confirmed(),
    );
    let program = provider.program(example::ID)?;

    // Build and send instructions
    println!("\nSend transaction with initialize and increment instructions");
    let initialize_ix = program
        .request()
        .accounts(accounts::Initialize {
            counter: counter.pubkey(),
            payer: program.payer(),
            system_program: system_program::ID,
        })
        .args(args::Initialize)
        .instructions()?
        .remove(0);

    let increment_ix = program
        .request()
        .accounts(accounts::Increment {
            counter: counter.pubkey(),
        })
        .args(args::Increment)
        .instructions()?
        .remove(0);

    let signature = program
        .request()
        .instruction(initialize_ix)
        .instruction(increment_ix)
        .signer(&counter)
        .send()
        .await?;
    println!("   Transaction confirmed: {}", signature);

    println!("\nFetch counter account data");
    let counter_account: Counter = program.account::<Counter>(counter.pubkey()).await?;
    println!("   Counter value: {}", counter_account.count);
    Ok(())
}
```

```toml tab="Dependencies"
[package]
name = "rs"
version = "0.1.0"
edition = "2021"

[dependencies]
anchor-client = { version = "0.31.0", features = ["async"] }
anchor-lang = "0.31.0"
anyhow = "1.0.93"
tokio = { version = "1.0", features = ["full"] }
```

</Tabs>

<Steps>

<Step>

The `declare_program!()` macro takes a single argument - the name of the
program's IDL file (e.g. `example.json`):

```rust
declare_program!(example);  // Looks for /idls/example.json
```

</Step>

<Step>

Bring into scope the generated modules:

```rust
use example::{
  accounts::Counter,  // Program Account types
  client::accounts,   // Accounts for program instructions
  client::args,       // Arguments for program instructions
};
```

</Step>

<Step>

Use the Client module to build the program's instructions:

```rust
// Build initialize instruction
let initialize_ix = program
    .request()
    // Accounts required for initialize instruction
    .accounts(accounts::Initialize {
        counter: counter.pubkey(),
        payer: program.payer(),
        system_program: system_program::ID,
    })
    // Arguments for initialize instruction (discriminator)
    .args(args::Initialize)
    .instructions()?
    .remove(0);
```

```rust
// Build increment instruction
let increment_ix = program
    .request()
    // Accounts required for increment instruction
    .accounts(accounts::Increment {
        counter: counter.pubkey(),
    })
    // Arguments for increment instruction (discriminator)
    .args(args::Increment)
    .instructions()?
    .remove(0);
```

</Step>
<Step>

Add the program's instructions to a transaction and send the transaction:

```rust
let signature = program
    .request()
    .instruction(initialize_ix)
    .instruction(increment_ix)
    .signer(&counter)
    .send()
    .await?;
```

</Step>

<Step>

Use the Account module to fetch and deserialize the program's account types:

```rust
// Counter type from accounts module
let counter_account: Counter = program.account::<Counter>(counter.pubkey()).await?;
```

</Step>

</Steps>

````

File: anchor/docs/content/docs/features/errors.mdx
```mdx
---
title: Custom Errors
description: Learn how to implement custom error handling in Anchor programs.
---

All instruction handlers in Anchor programs return a custom `Result<T>` type
that allows you to handle successful execution with `Ok(T)` and error cases with
`Err(Error)`.

```rust
// [!code word:Result]
pub fn custom_instruction(ctx: Context<CustomInstruction>) -> Result<()> {
    // --snip--
    Ok(())
}
````

The
[`Result<T>`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/lib.rs#L77)
type in Anchor programs is a type alias that wraps the standard Rust
`Result<T, E>`. In this case, `T` represents the successful return type, while
`E` is Anchor's custom `Error` type.

```rust
pub type Result<T> = std::result::Result<T, error::Error>;
```

## Anchor Error

When an error occurs in an Anchor program, it returns a custom
[`Error`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/error.rs#L277-L281)
type defined as:

```rust
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    AnchorError(Box<AnchorError>),
    ProgramError(Box<ProgramErrorWithOrigin>),
}
```

The `Error` type in Anchor programs can be one of two variants:

1. [`ProgramErrorWithOrigin`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/error.rs#L389-L394):
   Custom type that wraps a standard Solana
   [`ProgramError`](https://github.com/anza-xyz/agave/blob/v1.18.26/sdk/program/src/program_error.rs#L12-L66)
   type. These errors come from the `solana_program` crate.

```rust
#[derive(Debug)]
pub struct ProgramErrorWithOrigin {
    pub program_error: ProgramError,
    pub error_origin: Option<ErrorOrigin>,
    pub compared_values: Option<ComparedValues>,
}
```

2. [`AnchorError`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/error.rs#L490-L497):
   Errors defined by the Anchor framework.

```rust
#[derive(Debug)]
pub struct AnchorError {
    pub error_name: String,
    pub error_code_number: u32,
    pub error_msg: String,
    pub error_origin: Option<ErrorOrigin>,
    pub compared_values: Option<ComparedValues>,
}
```

An `AnchorError` can be thought of as having two categories:

1. Internal Anchor Errors - These are built-in errors included with the Anchor
   framework. They are defined in the
   [`ErrorCode`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/error.rs#L10-L275)
   enum.

2. Custom Program Errors - These are program specific errors that developers
   define to handle custom error cases.

The `error_code_number` from an `AnchorError` has the following numbering
scheme:

| Error Code | Description                           |
| ---------- | ------------------------------------- |
| >= 100     | Instruction error codes               |
| >= 1000    | IDL error codes                       |
| >= 2000    | Constraint error codes                |
| >= 3000    | Account error codes                   |
| >= 4100    | Misc error codes                      |
| = 5000     | Deprecated error code                 |
| >= 6000    | Starting point for custom user errors |

## Usage

Anchor provides a convenient way to define custom errors through the
`error_code` attribute. The implementation details can be found
[here](https://github.com/coral-xyz/anchor/blob/master/lang/syn/src/codegen/error.rs).

When you define an enum with the `error_code` attribute, Anchor automatically:

- Assigns an error code starting from 6000
- Generates the necessary boilerplate for error handling
- Enables the use of custom error messages via the `msg` attribute

```rust
#[error_code]
pub enum MyError {
    #[msg("My custom error message")]
    MyCustomError,
    #[msg("My second custom error message")]
    MySecondCustomError,
}
```

### err!

To throw an error, use the
[`err!`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/lib.rs#L735-L743)
macro. The `err!` macro provides a convenient way to return custom errors from
your program. Under the hood, `err!` uses the `error!` macro to construct
`AnchorError`. The implementation can be found
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/error/src/lib.rs#L84-L116).

```rust
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: MyAccount) - Result<()> {
        if data.data = 100 {
            // [!code word:MyError]
            // [!code highlight]
            return err!(MyError::DataTooLarge);
        }
        ctx.accounts.my_account.set_inner(data);
        Ok(())
    }
}


#[error_code]
pub enum MyError {
    #[msg("MyAccount may only hold data below 100")]
    DataTooLarge
}
```

### require!

The
[`require!`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/lib.rs#L525-L537)
macro provides a more concise way to handle error conditions. It combines a
condition check with returning an error if the condition is false. Here's how we
can rewrite the previous example using `require!`:

```rust
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: MyAccount) - Result<()> {
        // [!code word:MyError]
        // [!code highlight]
        require!(data.data < 100, MyError::DataTooLarge);
        ctx.accounts.my_account.set_inner(data);
        Ok(())
    }
}


#[error_code]
pub enum MyError {
    #[msg("MyAccount may only hold data below 100")]
    DataTooLarge
}
```

Anchor provides several "require" macros for different validation needs. You can
find the implementation of these macros
[here](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/lib.rs).

| Macro               | Description                                                                                 |
| ------------------- | ------------------------------------------------------------------------------------------- |
| `require!`          | Ensures a condition is true, otherwise returns with the given error.                        |
| `require_eq!`       | Ensures two NON-PUBKEY values are equal.                                                    |
| `require_neq!`      | Ensures two NON-PUBKEY values are not equal.                                                |
| `require_keys_eq!`  | Ensures two pubkeys values are equal.                                                       |
| `require_keys_neq!` | Ensures two pubkeys are not equal.                                                          |
| `require_gt!`       | Ensures the first NON-PUBKEY value is greater than the second NON-PUBKEY value.             |
| `require_gte!`      | Ensures the first NON-PUBKEY value is greater than or equal to the second NON-PUBKEY value. |

## Example

Here's a simple example demonstrating how to define and handle custom errors in
an Anchor program. The program below validates that an input amount falls within
an acceptable range, showing how to:

- Define custom error types with messages
- Use the `require!` macro to check conditions and return errors

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("9oECKMeeyf1fWNPKzyrB2x1AbLjHDFjs139kEyFwBpoV");

#[program]
pub mod custom_error {
    use super::*;

    pub fn validate_amount(_ctx: Context<ValidateAmount>, amount: u64) - Result<()> {
        // [!code word:CustomError]
        // [!code highlight:2]
        require!(amount >= 10, CustomError::AmountTooSmall);
        require!(amount <= 100, CustomError::AmountTooLarge);

        msg!("Amount validated successfully: {}", amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct ValidateAmount {}

#[error_code]
pub enum CustomError {
    #[msg("Amount must be greater than or equal to 10")]
    AmountTooSmall,
    #[msg("Amount must be less than or equal to 100")]
    AmountTooLarge,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { CustomError } from "../target/types/custom_error";
import assert from "assert";

describe("custom-error", () = {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.CustomError as Program<CustomError;

  it("Successfully validates amount within range", async () = {
    const tx = await program.methods.validateAmount(new anchor.BN(50)).rpc();

    console.log("Transaction signature:", tx);
  });

  it("Fails with amount too small", async () => {
    try {
      await program.methods.validateAmount(new anchor.BN(5)).rpc();

      assert.fail("Expected an error to be thrown");
    } catch (error) {
      assert.strictEqual(error.error.errorCode.code, "AmountTooSmall");
      assert.strictEqual(
        error.error.errorMessage,
        "Amount must be greater than or equal to 10",
      );
    }
  });

  it("Fails with amount too large", async () => {
    try {
      await program.methods.validateAmount(new anchor.BN(150)).rpc();

      assert.fail("Expected an error to be thrown");
    } catch (error) {
      assert.strictEqual(error.error.errorCode.code, "AmountTooLarge");
      assert.strictEqual(
        error.error.errorMessage,
        "Amount must be less than or equal to 100",
      );
    }
  });
});
```

</Tab>
</Tabs>

When a program error occurs, Anchor's TypeScript Client SDK returns a detailed
[error response](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/error.ts#L51-L71)
containing information about the error. Here's an example error response showing
the structure and available fields:

```shell title="Error Response"
{
  errorLogs: [
    'Program log: AnchorError thrown in programs/custom-error/src/lib.rs:11. Error Code: AmountTooLarge. Error Number: 6001. Error Message: Amount must be less than or equal to 100.'
  ],
  logs: [
    'Program 9oECKMeeyf1fWNPKzyrB2x1AbLjHDFjs139kEyFwBpoV invoke [1]',
    'Program log: Instruction: ValidateAmount',
    'Program log: AnchorError thrown in programs/custom-error/src/lib.rs:11. Error Code: AmountTooLarge. Error Number: 6001. Error Message: Amount must be less than or equal to 100.',
    'Program 9oECKMeeyf1fWNPKzyrB2x1AbLjHDFjs139kEyFwBpoV consumed 2153 of 200000 compute units',
    'Program 9oECKMeeyf1fWNPKzyrB2x1AbLjHDFjs139kEyFwBpoV failed: custom program error: 0x1771'
  ],
  error: {
    errorCode: { code: 'AmountTooLarge', number: 6001 },
    errorMessage: 'Amount must be less than or equal to 100',
    comparedValues: undefined,
    origin: { file: 'programs/custom-error/src/lib.rs', line: 11 }
  },
  _programErrorStack: ProgramErrorStack {
    stack: [
      [PublicKey [PublicKey(9oECKMeeyf1fWNPKzyrB2x1AbLjHDFjs139kEyFwBpoV)]]
    ]
  }
}
```

For a more comprehensive example, you can also reference the
[errors test program](https://github.com/coral-xyz/anchor/blob/master/tests/errors/programs/errors/src/lib.rs)
in the Anchor repository.

````

File: anchor/docs/content/docs/features/events.mdx
```mdx
---
title: Emit Events
description:
  Learn how to emit events in Anchor programs using emit! and emit_cpi! macros.
---

## Examples

Anchor provides two macros for emitting events in your programs:

1. `emit!()` - Emits events directly to program logs. This is the simpler,
   though program logs may be truncated by data providers in some cases
2. `emit_cpi!()` - Emits events through a Cross Program Invocation (CPI) by
   including the event data in the instruction data.

<Callout type="info">

The `emit_cpi()` approach was introduced an alternative to program logs, which
can sometimes be truncated by data providers. While CPI instruction data is less
likely to be truncated, this approach does incur additional compute costs from
the Cross Program Invocation.

</Callout>

<Callout type="info">

For more robust solutions for events, consider geyser gRPC services by
[Triton](https://docs.triton.one/project-yellowstone/dragons-mouth-grpc-subscriptions)
or [Helius](https://docs.helius.dev/data-streaming/geyser-yellowstone).

</Callout>

### `emit`

The
[`emit!()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/event/src/lib.rs#L101-L109)
macro provides a way to emit events through program logs. When called, it:

1. Uses the
   [`sol_log_data()`](https://github.com/anza-xyz/agave/blob/c2b350023ba849d1b33142592264aaa51fcb7f1e/sdk/program/src/log.rs#L115-L124)
   syscall to write the data to program logs
2. Encodes the event data as a
   [base64 string](https://github.com/anza-xyz/agave/blob/c2b350023ba849d1b33142592264aaa51fcb7f1e/program-runtime/src/stable_log.rs#L46-L61)
   prefixed with `Program Data:`

To receive emitted events in your client application, use the
[`addEventListener()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/event.ts#L74-L123)
method. This method automatically
[parses and decodes](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/ts/packages/anchor/src/program/event.ts#L232-L253)
event data from the program logs.

Example usage:

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("8T7MsCZyzxboviPJg5Rc7d8iqEcDReYR2pkQKrmbg7dy");

#[program]
pub mod event {
    use super::*;

    pub fn emit_event(_ctx: Context<EmitEvent>, input: String) -> Result<()> {
        // [!code word:emit!]
        // [!code highlight]
        emit!(CustomEvent { message: input });
        Ok(())
    }
}

#[derive(Accounts)]
pub struct EmitEvent {}

// [!code highlight:4]
#[event]
pub struct CustomEvent {
    pub message: String,
}
````

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Event } from "../target/types/event";

describe("event", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.Event as Program<Event>;

  it("Emits custom event", async () => {
    // Set up listener before sending transaction
    // [!code word:addEventListener]
    // [!code highlight:4]
    const listenerId = program.addEventListener("customEvent", (event) => {
      // Do something with the event data
      console.log("Event Data:", event);
    });

    // Message to be emitted in the event
    const message = "Hello, Solana!";
    // Send transaction
    await program.methods.emitEvent(message).rpc();

    // Remove listener
    await program.removeEventListener(listenerId);
  });
});
```

</Tab>
</Tabs>

The following is the output of the program logs. The event data is base64
encoded as `Zb1eU3aiYdwOAAAASGVsbG8sIFNvbGFuYSE=`.

```shell title="Program Logs"
Log Messages:
  Program 8T7MsCZyzxboviPJg5Rc7d8iqEcDReYR2pkQKrmbg7dy invoke [1]
  Program log: Instruction: EmitEvent
  Program data: Zb1eU3aiYdwOAAAASGVsbG8sIFNvbGFuYSE=
  Program 8T7MsCZyzxboviPJg5Rc7d8iqEcDReYR2pkQKrmbg7dy consumed 1012 of 200000 compute units
  Program 8T7MsCZyzxboviPJg5Rc7d8iqEcDReYR2pkQKrmbg7dy success
```

<Callout type="info">
  Ensure the RPC provider you use does not truncate the program logs from the
  transaction data.
</Callout>

### `emit_cpi`

The
[`emit_cpi!()`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/event/src/lib.rs#L155-L195)
macro emits events through Cross Program Invocations (CPIs) to the program
itself. The event data is encoded and included in the CPI's instruction data
(instead of program logs).

To emit events through CPIs, you need to enable the `event-cpi` feature in your
program's `Cargo.toml`:

```toml title="Cargo.toml"
[dependencies]
anchor-lang = { version = "0.31.0", features = ["event-cpi"] }
```

Example usage:

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1");

#[program]
pub mod event_cpi {
    use super::*;

    pub fn emit_event(ctx: Context<EmitEvent>, input: String) -> Result<()> {
        // [!code word:emit_cpi!]
        // [!code highlight]
        emit_cpi!(CustomEvent { message: input });
        Ok(())
    }
}

// [!code highlight]
#[event_cpi]
#[derive(Accounts)]
pub struct EmitEvent {}

// [!code highlight:4]
#[event]
pub struct CustomEvent {
    pub message: String,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { EventCpi } from "../target/types/event_cpi";

describe("event-cpi", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.EventCpi as Program<EventCpi>;

  it("Emits custom event", async () => {
    const message = "Hello, Solana!";
    const transactionSignature = await program.methods.emitEvent(message).rpc();

    // Wait for the transaction to be confirmed
    await program.provider.connection.confirmTransaction(
      transactionSignature,
      "confirmed"
    );

    // Fetch the transaction data
    // [!code highlight:4]
    const transactionData = await program.provider.connection.getTransaction(
      transactionSignature,
      { commitment: "confirmed" }
    );

    // Decode the event data from the CPI instruction data
    // [!code highlight:4]
    const eventIx = transactionData.meta.innerInstructions[0].instructions[0];
    const rawData = anchor.utils.bytes.bs58.decode(eventIx.data);
    const base64Data = anchor.utils.bytes.base64.encode(rawData.subarray(8));
    const event = program.coder.events.decode(base64Data);
    console.log(event);
  });
});
```

</Tab>
</Tabs>

The
[`event_cpi`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/event/src/lib.rs#L228-L237)
attribute must be added to the `#[derive(Accounts)]` struct for the instruction
instruction that emits events using the `emit_cpi!()` macro. This attribute
[automatically includes additional accounts](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/parser/accounts/event_cpi.rs#L28-L70)
that are required for the self CPI.

```rust title="lib.rs"
// [!code highlight]
#[event_cpi]
#[derive(Accounts)]
pub struct RequiredAccounts {
  // --snip--
}
```

To get the emitted event data in your client application, you need to fetch the
transaction using the transaction signature and parse the event data from the
CPI instruction data.

```ts title="test.ts"
// 1. Fetch the full transaction data using the transaction signature
const transactionData = await program.provider.connection.getTransaction(
  transactionSignature,
  { commitment: "confirmed" }
);

// 2. Extract the CPI (inner instruction) that contains the event data
const eventIx = transactionData.meta.innerInstructions[0].instructions[0];

// 3. Decode the event data
const rawData = anchor.utils.bytes.bs58.decode(eventIx.data);
const base64Data = anchor.utils.bytes.base64.encode(rawData.subarray(8));
const event = program.coder.events.decode(base64Data);
console.log(event);
```

Below is an example transaction showing how event data appears in the
transaction details. When using `emit_cpi!()`, the event data is encoded and
included in the `data` field of an inner instruction (CPI).

In the example transaction below, the encoded event data is
`"data": "6AJcBqZP8afBKheoif1oA6UAiLAcqYr2RaR33pFnEY1taQp"` in the
`innerInstructions` array.

```shell title="Transaction Data"
{
  "blockTime": 1735854530,
  "meta": {
    "computeUnitsConsumed": 13018,
    "err": null,
    "fee": 5000,
    "innerInstructions": [
      {
        "index": 0,
        "instructions": [
          {
            "accounts": [
              1
            ],
            "data": "6AJcBqZP8afBKheoif1oA6UAiLAcqYr2RaR33pFnEY1taQp",
            "programIdIndex": 2,
            "stackHeight": 2
          }
        ]
      }
    ],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1 invoke [1]",
      "Program log: Instruction: EmitEvent",
      "Program 2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1 invoke [2]",
      "Program 2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1 consumed 5000 of 192103 compute units",
      "Program 2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1 success",
      "Program 2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1 consumed 13018 of 200000 compute units",
      "Program 2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1 success"
    ],
    "postBalances": [
      499999999999995000,
      0,
      1141440
    ],
    "postTokenBalances": [],
    "preBalances": [
      500000000000000000,
      0,
      1141440
    ],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 3,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 2,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "4kh6HxYZiAebF8HWLsUWod2EaQQ6iWHpHYCz8UcmFbM1",
        "2brZf9PQqEvv17xtbj5WNhZJULgVZuLZT6FgH1Cqpro2",
        "2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1"
      ],
      "recentBlockhash": "2QtnU35RXTo7uuQEVARYJgWYRYtbqUxWQkK8WywUnVdY",
      "instructions": [
        {
          "accounts": [
            1,
            2
          ],
          "data": "3XZZ984toC4WXCLkxBsLimpEGgH75TKXRJnk",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3gFbKahSSbitRSos4MH3cqeVv2FiTNaLCuWaLPo6R98FEbHnTshoYxopGcx74nFLqt1pbZK9i8dnr4NFXayrMndZ"
    ]
  }
}
```

<Callout type="info">
  Currently, event data emitted through CPIs cannot be directly subscribed to.
  To access this data, you must fetch the complete transaction data and manually
  decode the event information from the instruction data of the CPI.
</Callout>

````

File: anchor/docs/content/docs/features/index.mdx
```mdx
---
title: Features
description: Learn how to use additional features of the Anchor framework
index: true
---

````

File: anchor/docs/content/docs/features/meta.json

```json
{
  "title": "Additional Features",
  "pages": ["declare-program", "errors", "events", "zero-copy"]
}
```

File: anchor/docs/content/docs/features/zero-copy.mdx

````mdx
---
title: Zero Copy
description:
  Learn how to use Anchor's zero-copy deserialization feature to handle large
  account data in Solana programs.
---

## Usage

Zero copy is a deserialization feature that allows programs to read account data
directly from memory without copying it. This is particularly useful when
working with large accounts.

To use zero-copy add the `bytemuck` crate to your dependencies. Add the
`min_const_generics` feature to allow working with arrays of any size in your
zero-copy types.

```toml title="Cargo.toml"
[dependencies]
bytemuck = { version = "1.20.0", features = ["min_const_generics"] }
anchor-lang = "0.31.0"
```
````

### Define a Zero Copy Account

To define an account type that uses zero-copy, annotate the struct with
[`#[account(zero_copy)]`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/attribute/account/src/lib.rs#L417).

```rust
// [!code highlight]
#[account(zero_copy)]
pub struct Data {
    // 10240 bytes - 8 bytes account discriminator
    pub data: [u8; 10232],
}
```

The `#[account(zero_copy)]` attribute automatically implements several traits
required for zero-copy deserialization:

```rust
// [!code highlight:4]
#[derive(Copy, Clone)]
#[derive(bytemuck::Zeroable)]
#[derive(bytemuck::Pod)]
#[repr(C)]
struct Data {
  // --snip--
}
```

### Use AccountLoader for Zero Copy Accounts

To deserialize a zero-copy account, use
[`AccountLoader<'info, T>`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts/account_loader.rs#L95-L99),
where `T` is the zero-copy account type defined with the `#[account(zero_copy)]`
attribute.

For example:

```rust
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:AccountLoader]
    // [!code highlight]
    pub zero_copy_account: AccountLoader<'info, Data>,
}
```

#### Initialize a Zero Copy Account

The `init` constraint can be used with the `AccountLoader` type to create a
zero-copy account.

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        // [!code word:init:1]
        // [!code highlight:4]
        init,
        // 10240 bytes is max space to allocate with init constraint
        space = 8 + 10232,
        payer = payer,
    )]
    pub data_account: AccountLoader<'info, Data>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

<Callout type="info">
  The `init` constraint is limited to allocating a maximum of 10240 bytes due to
  CPI limitations. Under the hood, the `init` constraint makes a CPI call to the
  SystemProgram to create the account.
</Callout>

When initializing a zero-copy account for the first time, use
[`load_init`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts/account_loader.rs#L199-L221)
to get a mutable reference to the account data. The `load_init` method also sets
the account discriminator.

```rust
pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    // [!code word:load_init]
    // [!code highlight]
    let account = &mut ctx.accounts.data_account.load_init()?;
    account.data = [1; 10232];
    Ok(())
}
```

For accounts that require more than 10240 bytes, use the
[`zero`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/accounts/constraints.rs#L200-L264)
constraint instead of `init`. The `zero` constraint verifies the account has not
been initialized by checking that its discriminator has not been set.

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    // [!code word:zero]
    // [!code highlight]
    #[account(zero)]
    pub data_account: AccountLoader<'info, Data>,
}
```

With the `zero` constraint, you'll need to first create the account in a
separate instruction by directly calling the System Program. This allows you to
create accounts up to Solana's maximum account size of 10MB (10_485_760 bytes),
bypassing the CPI limitation.

Just as before, use `load_init` to get a mutable reference to the account data
and set the account discriminator. Since 8 bytes are reserved for the account
discriminator, the maximum data size is 10_485_752 bytes (10MB - 8 bytes).

```rust
pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    // [!code word:load_init]
    // [!code highlight]
    let account = &mut ctx.accounts.data_account.load_init()?;
    account.data = [1; 10_485_752];
    Ok(())
}
```

#### Update a Zero Copy Account

Use
[`load_mut`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts/account_loader.rs#L172-L195)
when you need mutable access to update an existing zero-copy account:

```rust
#[derive(Accounts)]
pub struct Update<'info> {
    // [!code highlight]
    #[account(mut)]
    pub data_account: AccountLoader<'info, Data>,
}
```

```rust
pub fn update(ctx: Context<Update>) -> Result<()> {
    // [!code word:load_mut]
    // [!code highlight]
    let account = &mut ctx.accounts.data_account.load_mut()?;
    account.data = [2; 10232];
    Ok(())
}
```

#### Read a Zero Copy Account

Use
[`load`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts/account_loader.rs#L154-L169)
to only read the account data.

```rust
#[derive(Accounts)]
pub struct ReadOnly<'info> {
    pub data_account: AccountLoader<'info, Data>,
}
```

```rust
pub fn read_only(ctx: Context<ReadOnly>) -> Result<()> {
    // [!code word:load]
    // [!code highlight]
    let account = &ctx.accounts.data_account.load()?;
    msg!("First 10 bytes: {:?}", &account.data[..10]);
    Ok(())
}
```

## Examples

The examples below demonstrate two approaches for initializing zero-copy
accounts in Anchor:

1. Using the `init` constraint to initialize the account in a single instruction
2. Using the `zero` constraint to initialize an account with data greater than
   10240 bytes

### Zero Copy

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("8B7XpDXjPWodpDUWDSzv4q9k73jB5WdNQXZxNBj1hqw1");

#[program]
pub mod zero_copy {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account = &mut ctx.accounts.data_account.load_init()?;
        account.data = [1; 10232];
        Ok(())
    }

    pub fn update(ctx: Context<Update>) -> Result<()> {
        let account = &mut ctx.accounts.data_account.load_mut()?;
        account.data = [2; 10232];
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        // 10240 bytes is max space to allocate with init constraint
        space = 8 + 10232,
        payer = payer,
    )]
    pub data_account: AccountLoader<'info, Data>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub data_account: AccountLoader<'info, Data>,
}

#[account(zero_copy)]
pub struct Data {
    // 10240 bytes - 8 bytes account discriminator
    pub data: [u8; 10232],
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { ZeroCopy } from "../target/types/zero_copy";

describe("zero-copy", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.ZeroCopy as Program<ZeroCopy>;
  const dataAccount = anchor.web3.Keypair.generate();

  it("Is initialized!", async () => {
    const tx = await program.methods
      .initialize()
      .accounts({
        dataAccount: dataAccount.publicKey,
      })
      .signers([dataAccount])
      .rpc();
    console.log("Your transaction signature", tx);

    const account = await program.account.data.fetch(dataAccount.publicKey);
    console.log("Account", account);
  });

  it("Update!", async () => {
    const tx = await program.methods
      .update()
      .accounts({
        dataAccount: dataAccount.publicKey,
      })
      .rpc();
    console.log("Your transaction signature", tx);

    const account = await program.account.data.fetch(dataAccount.publicKey);
    console.log("Account", account);
  });
});
```

</Tab>
</Tabs>

### Initialize Large Account

When initializing an account that requires more than 10,240 bytes of space, you
must split the initialization into two steps:

1. Create the account in a separate instruction invoking the System Program
2. Initialize the account data in your program instruction

Note that the maximum Solana account size is 10MB (10_485_760 bytes), 8 bytes
are reserved for the account discriminator.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("CZgWhy3FYPFgKE5v9atSGaiQzbSB7cM38ofwX1XxeCFH");

#[program]
pub mod zero_copy_two {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account = &mut ctx.accounts.data_account.load_init()?;
        account.data = [1; 10_485_752];
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(zero)]
    pub data_account: AccountLoader<'info, Data>,
}

#[account(zero_copy)]
pub struct Data {
    // 10240 bytes - 8 bytes account discriminator
    pub data: [u8; 10_485_752],
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { ZeroCopyTwo } from "../target/types/zero_copy_two";

describe("zero-copy-two", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.ZeroCopyTwo as Program<ZeroCopyTwo>;
  const dataAccount = anchor.web3.Keypair.generate();

  it("Is initialized!", async () => {
    const space = 10_485_760; // 10MB max account size
    const lamports =
      await program.provider.connection.getMinimumBalanceForRentExemption(
        space
      );

    // [!code highlight:7]
    const createAccountInstruction = anchor.web3.SystemProgram.createAccount({
      fromPubkey: program.provider.publicKey,
      newAccountPubkey: dataAccount.publicKey,
      space,
      lamports,
      programId: program.programId,
    });

    // [!code highlight:6]
    const initializeInstruction = await program.methods
      .initialize()
      .accounts({
        dataAccount: dataAccount.publicKey,
      })
      .instruction();

    const transaction = new anchor.web3.Transaction().add(
      createAccountInstruction,
      initializeInstruction
    );

    const tx = await program.provider.sendAndConfirm(transaction, [
      dataAccount,
    ]);

    console.log("Your transaction signature", tx);

    const account = await program.account.data.fetch(dataAccount.publicKey);
    console.log("Account", account);
  });
});
```

</Tab>
</Tabs>

````

File: anchor/docs/content/docs/quickstart/index.mdx
```mdx
---
title: Quickstart
description:
  Learn how to quickly get started with Anchor, the leading Solana smart
  contract development framework.
index: true
---

````

File: anchor/docs/content/docs/quickstart/local.mdx

````mdx
---
title: Local Development
description:
  Learn how to build Solana programs using the Anchor framework on your local
  machine.
---

The Anchor framework is a tool that simplifies the process of building Solana
programs. Whether you're new to blockchain development or an experienced
programmer, Anchor simplifies the process of writing, testing, and deploying
Solana programs.

In this section, we'll walk through:

- Creating a new Anchor project
- Building and testing your program
- Deploying to Solana clusters
- Understanding the project file structure

## Prerequisites

For detailed installation instructions, visit the
[installation](/docs/installation) page.

Before you begin, ensure you have the following installed:

- Rust: The programming language for building Solana programs.
- Solana CLI: Command-line tool for Solana development.
- Anchor CLI: Command-line tool for the Anchor framework.

To verify Anchor CLI installation, open your terminal and run:

```shell filename="Terminal"
anchor --version
```
````

Expected output:

```shell filename="Terminal"
anchor-cli 0.31.0
```

## Getting Started

This section covers the basic steps to create, build, and test your first local
Anchor program.

<Steps>

<Step>

### Create a new Project

To start a new project, use the `anchor init` command followed by your project's
name. This command creates a new directory with the specified name and sets up a
default program and test file.

```shell filename="Terminal"
anchor init my-program
```

Navigate to the new project directory and open it in your code editor.

```shell filename="Terminal" copy
cd my-project
```

The default Anchor program is located at `/programs/my-project/src/lib.rs`.

<Accordions>
<Accordion title="Default Program">

The value in the `declare_id!` macro is the program ID, a unique identifier for
your program.

By default, it is the public key of the keypair generated in
`/target/deploy/my_project-keypair.json`.

```rust filename="lib.rs"
use anchor_lang::prelude::*;

declare_id!("3ynNB373Q3VAzKp7m4x238po36hjAGFXFJB4ybN2iTyg");

#[program]
pub mod my_project {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        msg!("Greetings from: {:?}", ctx.program_id);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```

</Accordion>
</Accordions>

The default Typescript test file is located at `/tests/my-project.ts`.

<Accordions>
<Accordion title="Default Test File">

This file demonstrates how to invoke the default program's `initialize`
instruction in Typescript.

```ts filename="my-project.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { MyProject } from "../target/types/my_project";

describe("my-project", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MyProject as Program<MyProject>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.methods.initialize().rpc();
    console.log("Your transaction signature", tx);
  });
});
```

</Accordion>
</Accordions>

If you prefer Rust for testing, initialize your project with the
`--test-template rust` ([Anchor Rust client](/docs/clients/rust)) or
`--test-template mollusk` ([Mollusk test library](/docs/testing/mollusk)) flag.

```shell
anchor init --test-template rust my-program
```

The Rust test file will be at `/tests/src/test_initialize.rs`.

<Accordions>
<Accordion title="Rust Test File">

```rust filename="test_initialize.rs"
use std::str::FromStr;

use anchor_client::{
    solana_sdk::{
        commitment_config::CommitmentConfig, pubkey::Pubkey, signature::read_keypair_file,
    },
    Client, Cluster,
};

#[test]
fn test_initialize() {
    let program_id = "3ynNB373Q3VAzKp7m4x238po36hjAGFXFJB4ybN2iTyg";
    let anchor_wallet = std::env::var("ANCHOR_WALLET").unwrap();
    let payer = read_keypair_file(&anchor_wallet).unwrap();

    let client = Client::new_with_options(Cluster::Localnet, &payer, CommitmentConfig::confirmed());
    let program_id = Pubkey::from_str(program_id).unwrap();
    let program = client.program(program_id).unwrap();

    let tx = program
        .request()
        .accounts(my_program::accounts::Initialize {})
        .args(my_program::instruction::Initialize {})
        .send()
        .expect("");

    println!("Your transaction signature {}", tx);
}
```

</Accordion>
</Accordions>

</Step>
<Step>

### Build the Program

Build the program by running `anchor build`.

```shell filename="Terminal" copy
anchor build
```

The compiled program will be at `/target/deploy/my_project.so`. The content of
this file is what gets stored on the Solana network (as an executable account)
when you deploy your program.

</Step>
<Step>

### Test the Program

To test the program, run `anchor test`.

```shell filename="Terminal" copy
anchor test
```

By default, the `Anchor.toml` config file specifies the `localnet` cluster. When
developing on `localnet`, `anchor test` will automatically:

1. Start a local Solana validator
2. Build and deploy your program to the local cluster
3. Run the tests in the `tests` folder
4. Stop the local Solana validator

Alternatively, you can manually start a local Solana validator and run tests
against it. This is useful if you want to keep the validator running while you
iterate on your program. It allows you to inspect accounts and transaction logs
on the [Solana Explorer](https://explorer.solana.com/?cluster=custom) while
developing locally.

Open a new terminal and start a local Solana validator by running the
`solana-test-validator` command.

```shell filename="Terminal" copy
solana-test-validator
```

In a separate terminal, run the tests against the local cluster. Use the
`--skip-local-validator` flag to skip starting the local validator since it's
already running.

```shell filename="Terminal" copy
anchor test --skip-local-validator
```

</Step>
<Step>

### Deploy to Devnet

By default, the `Anchor.toml` config file in an Anchor project specifies the
localnet cluster.

```toml filename="Anchor.toml" {14}
[toolchain]

[features]
resolution = true
skip-lint = false

[programs.localnet]
my_program = "3ynNB373Q3VAzKp7m4x238po36hjAGFXFJB4ybN2iTyg"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "Localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```

To deploy your program to devnet, change the `cluster` value to `Devnet`.

<Callout type="info">

Note that deploying to devnet requires your wallet to have enough SOL to cover
deployment cost. You can get devnet SOL using the
[Web Faucet](https://faucet.solana.com/).

</Callout>

```diff
-cluster = "Localnet"
+cluster = "Devnet"
```

```toml filename="Anchor.toml"
[provider]
cluster = "Devnet"
wallet = "~/.config/solana/id.json"
```

Now when you run `anchor deploy`, your program will be deployed to the devnet
cluster. The `anchor test` command will also use the cluster specified in the
`Anchor.toml` file.

```shell
anchor deploy
```

To deploy to mainnet, simply update the `Anchor.toml` file to specify the
mainnet cluster.

```toml filename="Anchor.toml"
[provider]
cluster = "Mainnet"
wallet = "~/.config/solana/id.json"
```

</Step>
<Step>

### Update the Program

Solana programs can be updated by redeploying the program to the same program
ID.

To update a program, simply make changes to your program's code and run the
`anchor build` command to generated an updated `.so` file.

```shell
anchor build
```

Then run the `anchor deploy` command to redeploy the updated program.

```shell
anchor deploy
```

</Step>
<Step>

### Close the Program

To reclaim the SOL allocated to a program account, you can close your Solana
program.

To close a program, use the `solana program close <PROGRAM_ID>` command. For
example:

```shell
solana program close 3ynNB373Q3VAzKp7m4x238po36hjAGFXFJB4ybN2iTyg --bypass-warning
```

Note that once a program is closed, the program ID cannot be reused to deploy a
new program.

</Step>

</Steps>

## Project File Structure

Below is an overview of default file structure in an Anchor workspace:

<Files>
  <Folder name=".anchor">
    <File name="program-logs" />
  </Folder>
  <Folder name="app" />
  <Folder name="migrations" />
  <Folder name="programs" defaultOpen={true}>
    <Folder name="[project-name]" defaultOpen={true}>
      <Folder name="src" defaultOpen={true}>
        <File name="lib.rs" />
        <File name="Cargo.toml" />
        <File name="Xargo.toml" />
      </Folder>
    </Folder>
  </Folder>
  <Folder name="target" defaultOpen={true}>
    <Folder name="deploy">
      <File name="[project-name]-keypair.json" />
    </Folder>
    <Folder name="idl">
      <File name="[project-name].json" />
    </Folder>
    <Folder name="types">
      <File name="[project-name].ts" />
    </Folder>
  </Folder>
  <Folder name="tests" defaultOpen={true}>
    <File name="[project-name].ts" />
  </Folder>
  <File name="Anchor.toml" />
  <File name="Cargo.toml" />
  <File name="package.json" />
</Files>

### Programs Folder

The `/programs` directory contains your project's Anchor programs. A single
workspace can contain multiple programs.

### Tests Folder

The `/tests` directory contains test files for your project. A default test file
is created for you when you create your project.

### Target Folder

The `/target` directory contains build outputs. The main subfolders include:

- `/deploy`: Contains the keypair and program binary for your programs.
- `/idl`: Contains the JSON IDL for your programs.
- `/types`: Contains the TypeScript type for the IDL.

### Anchor.toml File

The `Anchor.toml` file configures workspace settings for your project.

### .anchor Folder

Includes a `program-logs` file that contains transaction logs from the last run
of test files.

### App Folder

The `/app` folder is an empty folder that can be optionally used for your
frontend code.

````

File: anchor/docs/content/docs/quickstart/solpg.mdx
```mdx
---
title: Solana Playground
description:
  Learn how to build your first Solana program using the Anchor framework
  directly in your browser.
---

In this section, we'll build, deploy, and test a simple Solana program using the
Anchor framework. By the end, you'll have deployed your first program to the
Solana blockchain!

Solana Playground (Solpg) is a browser-based development environment that allows
you to quickly develop, deploy, and test Solana programs!

## Getting Started

Open a new tab in your web browser and navigate to https://beta.solpg.io/.

<Steps>

<Step>
### Create Playground Wallet

If you're new to Solana Playground, the first step is to create your Playground
Wallet. This wallet will allow you to interact with the Solana network right
from your browser.

#### Step 1. Connect to Playground

Click the "Not connected" button at the bottom left of the screen.

![Not Connected](/docs/quickstart/pg-not-connected.png)

#### Step 2. Create Your Wallet

You'll see an option to save your wallet's keypair. Optionally, save your
wallet's keypair for backup and then click "Continue".

![Create Playground Wallet](/docs/quickstart/pg-create-wallet.png)

You should now see your wallet's address, SOL balance, and connected cluster
(devnet by default) at the bottom of the window.

![Connected](/docs/quickstart/pg-connected.png)

<Callout>
  Your Playground Wallet will be saved in your browser's local storage. Clearing
  your browser cache will remove your saved wallet.
</Callout>

Some definitions you may find helpful:

- _wallet address_: a public key that serves as your unique identity on the
  Solana blockchain. Just like an email address is used to receive emails, your
  wallet address is used to receive SOL.
- _connection cluster_: a network of Solana nodes (computers running Solana
  validator client). Devnet is the cluster for developer testing.

</Step>
<Step>

### Get Devnet SOL

Before we start building, we first need some devnet SOL.

From a developer's perspective, SOL is required for two main use cases:

- To create accounts on the network where we store data or deploy programs
- To pay for transaction fees when we interact with the network

Below are two methods to fund your wallet with devnet SOL:

#### Option 1: Using the Playground Terminal

To fund your Playground wallet with devnet SOL. In the Playground terminal, run:

```shell filename="Terminal"
solana airdrop 5
````

#### Option 2: Using the Devnet Faucet

If the airdrop command doesn't work (due to rate limits or errors), you can use
the [Web Faucet](https://faucet.solana.com/).

- Enter your wallet address (found at the bottom of the Playground screen) and
  select an amount
- Click "Confirm Airdrop" to receive your devnet SOL

![Faucet Airdrop](/docs/quickstart/faucet-airdrop.gif)

</Step>

<Step>

### Create Anchor Project

First, open https://beta.solpg.io in a new browser tab.

- Click the "Create a new project" button on the left-side panel.

- Enter a project name, select Anchor as the framework, then click the "Create"
  button.

![New Project](/docs/quickstart/pg-new-project.gif)

You'll see a new project created with the program code in the `src/lib.rs` file.

```rust filename="lib.rs"
use anchor_lang::prelude::*;

// This is your program's public key and it will update
// automatically when you build the project.
declare_id!("11111111111111111111111111111111");

#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data); // Message will show up in the tx logs
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    // We must specify the space in order to initialize an account.
    // First 8 bytes are default account discriminator,
    // next 8 bytes come from NewAccount.data being type u64.
    // (u64 = 64 bits unsigned integer = 8 bytes)
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NewAccount {
    data: u64
}
```

<Accordions>
<Accordion title="Explanation">

For now, we'll only cover the high-level overview of the program code:

- The `declare_id!` macro specifies the on-chain address of your program. It
  will be automatically updated when we build the program in the next step.

  ```rust
  declare_id!("11111111111111111111111111111111");
  ```

- The `#[program]` attribute annotates a module containing functions that
  represent the program's instructions.

  ```rust
  #[program]
  mod hello_anchor {
      use super::*;
      pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
          ctx.accounts.new_account.data = data;
          msg!("Changed data to: {}!", data); // Message will show up in the tx logs
          Ok(())
      }
  }
  ```

  In this example, the `initialize` instruction takes two parameters:

  1. `ctx: Context<Initialize>` - Provides access to the accounts required for
     this instruction, as specified in the `Initialize` struct.
  2. `data: u64` - An instruction parameter that will be passed in when the
     instruction is invoked.

  The function body sets the `data` field of `new_account` to the provided
  `data` argument and then prints a message to the program logs.

- The `#[derive(Accounts)]` macro is used to annotate a struct that specifies
  the accounts required for a particular instruction, where each field
  represents a separate account.

  The field types (ex. `Signer<'info>`) and constraints (ex. `#[account(mut)]`)
  are used by Anchor to automatically handle common security checks related to
  account validation.

  ```rust
  #[derive(Accounts)]
  pub struct Initialize<'info> {
      #[account(init, payer = signer, space = 8 + 8)]
      pub new_account: Account<'info, NewAccount>,
      #[account(mut)]
      pub signer: Signer<'info>,
      pub system_program: Program<'info, System>,
  }
  ```

- The `#[account]` attribute is used to annotate a struct that represents the
  data structure of an account created and owned by the program.

  ```rust
  #[account]
  pub struct NewAccount {
    data: u64
  }
  ```

</Accordion>
</Accordions>

</Step>
<Step>
### Build and Deploy Program

To build the program, simply run `build` in the terminal.

```shell filename="Terminal"
build
```

Notice that the address in `declare_id!()` has been updated. This is your
program's on-chain address.

<Accordions>
<Accordion title="Output">

```shell filename="Terminal"
$ build
Building...
Build successful. Completed in 1.46s.
```

</Accordion>
</Accordions>

Once the program is built, run `deploy` in the terminal to deploy the program to
the network (devnet by default). To deploy a program, SOL must be allocated to
the on-chain account that stores the program.

Before deployment, ensure you have enough SOL. You can get devnet SOL by either
running `solana airdrop 5` in the Playground terminal or using the
[Web Faucet](https://faucet.solana.com/).

```shell filename="Terminal"
deploy
```

<Accordions>
<Accordion title="Output">

```shell filename="Terminal"
$ deploy
Deploying... This could take a while depending on the program size and network conditions.
Warning: 1 transaction not confirmed, retrying...
Deployment successful. Completed in 19s.
```

</Accordion>
</Accordions>

Alternatively, you can also use the `Build` and `Deploy` buttons on the
left-side panel.

![Build and Deploy](/docs/quickstart/pg-build-deploy.png)

Once the program is deployed, you can now invoke its instructions.

</Step>
<Step>
### Test Program

Included with the starter code is a test file found in `tests/anchor.test.ts`.
This file demonstrates how to invoke the `initialize` instruction on the starter
program from the client.

```ts filename="anchor.test.ts"
// No imports needed: web3, anchor, pg and more are globally available

describe("Test", () => {
  it("initialize", async () => {
    // Generate keypair for the new account
    const newAccountKp = new web3.Keypair();

    // Send transaction
    const data = new BN(42);
    const txHash = await pg.program.methods
      .initialize(data)
      .accounts({
        newAccount: newAccountKp.publicKey,
        signer: pg.wallet.publicKey,
        systemProgram: web3.SystemProgram.programId,
      })
      .signers([newAccountKp])
      .rpc();
    console.log(`Use 'solana confirm -v ${txHash}' to see the logs`);

    // Confirm transaction
    await pg.connection.confirmTransaction(txHash);

    // Fetch the created account
    const newAccount = await pg.program.account.newAccount.fetch(
      newAccountKp.publicKey
    );

    console.log("On-chain data is:", newAccount.data.toString());

    // Check whether the data on-chain is equal to local 'data'
    assert(data.eq(newAccount.data));
  });
});
```

To run the test file once the program is deployed, run `test` in the terminal.

```shell filename="Terminal"
test
```

You should see an output indicating that the test passed successfully.

<Accordions>
<Accordion title="Output">

```shell filename="Terminal"
$ test
Running tests...
  hello_anchor.test.ts:
  hello_anchor
    Use 'solana confirm -v 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc' to see the logs
    On-chain data is: 42
    âœ” initialize (961ms)
  1 passing (963ms)
```

</Accordion>
</Accordions>

You can also use the `Test` button on the left-side panel.

![Run Test](/docs/quickstart/pg-test.png)

You can then view the transaction logs by running the `solana confirm -v`
command and specifying the transaction hash (signature) from the test output:

```shell filename="Terminal"
solana confirm -v [TxHash]
```

For example:

```shell filename="Terminal"
solana confirm -v 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc
```

<Accordions>
<Accordion title="Output">

```shell filename="Terminal" {29-35}
$ solana confirm -v 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc
RPC URL: https://api.devnet.solana.com
Default Signer: Playground Wallet
Commitment: confirmed

Transaction executed in slot 308150984:
  Block Time: 2024-06-25T12:52:05-05:00
  Version: legacy
  Recent Blockhash: 7AnZvY37nMhCybTyVXJ1umcfHSZGbngnm4GZx6jNRTNH
  Signature 0: 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc
  Signature 1: 3TrRbqeMYFCkjsxdPExxBkLAi9SB2pNUyg87ryBaTHzzYtGjbsAz9udfT9AkrjSo1ZjByJgJHBAdRVVTZv6B87PQ
  Account 0: srw- 3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R (fee payer)
  Account 1: srw- c7yy8zdP8oeZ2ewbSb8WWY2yWjDpg3B43jk3478Nv7J
  Account 2: -r-- 11111111111111111111111111111111
  Account 3: -r-x 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r
  Instruction 0
    Program:   2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r (3)
    Account 0: c7yy8zdP8oeZ2ewbSb8WWY2yWjDpg3B43jk3478Nv7J (1)
    Account 1: 3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R (0)
    Account 2: 11111111111111111111111111111111 (2)
    Data: [175, 175, 109, 31, 13, 152, 155, 237, 42, 0, 0, 0, 0, 0, 0, 0]
  Status: Ok
    Fee: â—Ž0.00001
    Account 0 balance: â—Ž5.47001376 -> â—Ž5.46900152
    Account 1 balance: â—Ž0 -> â—Ž0.00100224
    Account 2 balance: â—Ž0.000000001
    Account 3 balance: â—Ž0.00139896
  Log Messages:
    Program 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Changed data to: 42!
    Program 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r consumed 5661 of 200000 compute units
    Program 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r success

Confirmed
```

</Accordion>
</Accordions>

Alternatively, you can view the transaction details on
[SolanaFM](https://solana.fm/) or
[Solana Explorer](https://explorer.solana.com/?cluster=devnet) by searching for
the transaction signature (hash).

<Callout>
  Reminder to update the cluster (network) connection on the Explorer you are
  using to match Solana Playground. Solana Playground's default cluster is
  devnet.
</Callout>

### Close Program

Lastly, the SOL allocated to the on-chain program can be fully recovered by
closing the program.

You can close a program by running the following command and specifying the
program address found in `declare_id!()`:

```shell filename="Terminal"
solana program close [ProgramID]
```

For example:

```shell filename="Terminal"
solana program close 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r
```

<Accordions>
<Accordion title="Output">

```shell filename="Terminal"
$ solana program close 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r
Closed Program Id 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r, 2.79511512 SOL reclaimed
```

</Accordion>
</Accordions>

<Accordions>
<Accordion title="Explanation">

Only the upgrade authority of the program can close it. The upgrade authority is
set when the program is deployed, and it's the only account with permission to
modify or close the program. If the upgrade authority is revoked, then the
program becomes immutable and can never be closed or upgraded.

When deploying programs on Solana Playground, your Playground wallet is the
upgrade authority for all your programs.

</Accordion>
</Accordions>

Congratulations! You've just built and deployed your first Solana program using
the Anchor framework!

</Step>
</Steps>

````

File: anchor/docs/content/docs/quickstart/meta.json
```json
{
  "title": "Quickstart",
  "pages": ["solpg", "local"]
}

````

File: anchor/docs/content/docs/references/account-constraints.mdx

````mdx
---
title: Account Constraints
description: Anchor Account Constraints Examples
---

Minimal reference examples for Anchor account
[constraints](https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html).

See the account constraints
[source code](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/syn/src/codegen/accounts/constraints.rs)
for implementation details.

## Normal Constraints

### `#[account(signer)]`

Description: Checks the given account signed the transaction. Consider using the
Signer type if you would only have this constraint on the account.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/signer)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/signer)

```rust title="attribute"
#[account(signer)]
#[account(signer @ <custom_error>)]
```
````

### `#[account(mut)]`

Description: Checks the given account is mutable. Makes anchor persist any state
changes.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/mut)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/mut)

```rust title="attribute"
#[account(mut)]
#[account(mut @ <custom_error>)]
```

### `#[account(init)]`

Description: Creates the account via a CPI to the system program and initializes
it (sets its account discriminator).  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/init)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/init)

```rust title="attribute"
#[account(
    init,
    payer = <target_account>,
    space = <num_bytes>
)]
```

### `#[account(init_if_needed)]`

Description: Same as init but only runs if the account does not exist yet.
Requires init-if-needed cargo feature.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/init_if_needed)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/init_if_needed)

```rust title="attribute"
#[account(
    init_if_needed,
    payer = <target_account>
)]

#[account(
    init_if_needed,
    payer = <target_account>,
    space = <num_bytes>
)]
```

### `#[account(seeds, bump)]`

Description: Checks that given account is a PDA derived from the currently
executing program, the seeds, and if provided, the bump.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/seed-bump)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/seed-bump)

```rust title="attribute"
#[account(
    seeds = <seeds>,
    bump
)]

#[account(
    seeds = <seeds>,
    bump,
    seeds::program = <expr>
)]

#[account(
    seeds = <seeds>,
    bump = <expr>
)]

#[account(
    seeds = <seeds>,
    bump = <expr>,
    seeds::program = <expr>
)]
```

### `#[account(has_one = target)]`

Description: Checks the target field on the account matches the key of the
target field in the Accounts struct.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/has_one)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/has_one)

```rust title="attribute"
#[account(
    has_one = <target_account>
)]

#[account(
    has_one = <target_account> @ <custom_error>
)]
```

### `#[account(address = expr)]`

Description: Checks the account key matches the pubkey.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/address)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/address)

```rust title="attribute"
#[account(address = <expr>)]
#[account(address = <expr> @ <custom_error>)]
```

### `#[account(owner = expr)]`

Description: Checks the account owner matches expr.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/owner)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/owner)

```rust title="attribute"
#[account(owner = <expr>)]
#[account(owner = <expr> @ <custom_error>)]
```

### `#[account(executable)]`

Description: Checks the account is executable (i.e. the account is a program).  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/executable)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/executable)

```rust title="attribute"
#[account(executable)]
```

### `#[account(zero)]`

Description: Checks the account discriminator is zero. Use for accounts larger
than 10 Kibibyte.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/zero)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/zero)

```rust title="attribute"
#[account(zero)]
```

### `#[account(close = target)]`

Description: Closes the account by sending lamports to target and resetting
data.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/close)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/close)

```rust title="attribute"
#[account(close = <target_account>)]
```

### `#[account(constraint = expr)]`

Description: Custom constraint that checks whether the given expression
evaluates to true.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/constraint)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/constraint)

```rust title="attribute"
#[account(constraint = <expr>)]
#[account(
    constraint = <expr> @ <custom_error>
)]
```

### `#[account(realloc)]`

Description: Used to realloc program account space at the beginning of an
instruction.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/realloc)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/realloc)

```rust title="attribute"
#[account(
    realloc = <space>,
    realloc::payer = <target>,
    realloc::zero = <bool>
)]
```

## SPL Constraints

### `#[account(token::*)]`

Description: Create or validate token accounts with specified mint and
authority.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/token)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/token)

```rust title="attribute"
#[account(
    token::mint = <target_account>,
    token::authority = <target_account>
)]

#[account(
    token::mint = <target_account>,
    token::authority = <target_account>,
    token::token_program = <target_account>
)]
```

### `#[account(mint::*)]`

Description: Create or validate mint accounts with specified parameters.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/mint)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/mint)

```rust title="attribute"
#[account(
    mint::authority = <target_account>,
    mint::decimals = <expr>
)]

#[account(
    mint::authority = <target_account>,
    mint::decimals = <expr>,
    mint::freeze_authority = <target_account>
)]
```

### `#[account(associated_token::*)]`

Description: Create or validate associated token accounts.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/associated_token)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/associated_token)

```rust title="attribute"
#[account(
    associated_token::mint = <target_account>,
    associated_token::authority = <target_account>
)]

#[account(
    associated_token::mint = <target_account>,
    associated_token::authority = <target_account>,
    associated_token::token_program = <target_account>
)]
```

### `#[account(*::token_program = expr)]`

Description: The token_program can optionally be overridden.  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/token_program)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/token_program)

```rust title="attribute"
#[account(*::token_program = <target_account>)]
```

## Instruction Attribute

### `#[instruction(...)]`

Description: You can access the instruction's arguments with the
`#[instruction(..)]` attribute. You must list them in the same order as in the
instruction handler but you can omit all arguments after the last one you need.
Skipping arguments will result in an error.

Examples:
[Github](https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/instruction)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-constraints/instruction)

```rust title="snippet"
// [!code word:input]
#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, input: String) -> Result<()> {
        // --snip--
    }
}

#[derive(Accounts)]
// [!code highlight]
#[instruction(input: String)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 4 + input.len(),
    )]
    pub new_account: Account<'info, DataAccount>,
    // --snip--
}
```

Valid Usage:

```rust title="snippet"
// [!code word:input_one]
// [!code word:input_two]
#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, input_one: String, input_two: String) -> Result<()> {
        // --snip--
    }
}

#[derive(Accounts)]
// [!code highlight]
#[instruction(input_one: String, input_two: String)]
pub struct Initialize<'info> {
    // --snip--
}
```

```rust title="snippet"
// [!code word:input_one]
#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, input_one: String, input_two: String) -> Result<()> {
        // --snip--
    }
}

#[derive(Accounts)]
// [!code highlight]
#[instruction(input_one: String)]
pub struct Initialize<'info> {
    // --snip--
}
```

Invalid Usage, will result in an error:

```rust title="snippet"
// [!code word:input_two]
#[program]
pub mod example {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, input_one: String, input_two: String) -> Result<()> {
        // --snip--
    }
}

#[derive(Accounts)]
// [!code highlight]
#[instruction(input_two: String)]
pub struct Initialize<'info> {
    // --snip--
}
```

````

File: anchor/docs/content/docs/references/anchor-toml.mdx
```mdx
---
title: Anchor.toml Configuration
description: Anchor workspace config reference documentation
---

## provider (required)

A wallet and cluster that are used for all commands.

Example:

```toml
[provider]
cluster = "localnet"                    # The cluster used for all commands.
wallet = "~/.config/solana/id.json"     # The keypair used for all commands.
````

## scripts (required for testing)

Scripts that can be run with `anchor run <script>`. The `test` script is
executed by `anchor test`.

Example:

```toml
[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```

## features

### resolution

This tells the IDL to support account resolution. The default is `true`.

Example:

```
[features]
resolution = true
```

## workspace

### types

Adds a directory where you want the `<idl>.ts` file to be copied when running
`anchor build`. This is helpful when you want to keep this file in version
control, like when using it on the frontend, which will probably not have access
to the `target` directory generated by anchor.

Example:

```toml
[workspace]
types = "app/src/idl/"
```

### members

Sets the paths --relative to the `Anchor.toml`-- to all programs in the local
workspace, i.e., the path to the `Cargo.toml` manifest associated with each
program that can be compiled by the `anchor` CLI. For programs using the
standard Anchor workflow, this can be omitted. For programs not written in
Anchor but still want to publish, this should be added.

Example:

```toml
[workspace]
members = [
    "programs/*",
    "other_place/my_program"
]
```

### exclude

Opposite of `workspace.members`.

Example:

```toml
[workspace]
exclude = [
    "programs/my_program"
]
```

## programs

Example:

```toml
[programs.localnet]
my_program = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
```

The addresses of the programs in the workspace.

`programs.localnet` is used during testing on localnet where it's possible to
load a program at genesis with the `--bpf-program` option on
`solana-test-validator`.

## test

### startup_wait

Increases the time anchor waits for the `solana-test-validator` to start up.
This is, for example, useful if you're cloning (see `test.validator.clone`) many
accounts which increases the validator's startup time.

Example:

```toml
[test]
startup_wait = 10000
```

### genesis

Makes commands like `anchor test` start `solana-test-validator` with a given
program already loaded.

Example

```toml
[[test.genesis]]
address = "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"
program = "dex.so"

[[test.genesis]]
address = "22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD"
program = "swap.so"
upgradeable = true
```

### upgradeable

Deploys the program-to-test using `--upgradeable-program`. This makes it
possible to test that certain instructions can only be executed by the program's
upgrade authority. The initial upgrade authority will be set to
`provider.wallet`.

If unspecified or explicitly set to false, then the test program will be
deployed with `--bpf-program`, disabling upgrades to it.

Example:

```toml
[test]
upgradeable = true
```

## test.validator

These options are passed into the options with the same name in the
`solana-test-validator` cli (see `solana-test-validator --help`) in commands
like `anchor test`.

```toml
[test.validator]
url = "https://api.mainnet-beta.solana.com"     # This is the url of the cluster that accounts are cloned from (See `test.validator.clone`).
warp_slot = 1337                                # Warp the ledger to `warp_slot` after starting the validator.
slots_per_epoch = 5                             # Override the number of slots in an epoch.
rpc_port = 1337                                 # Set JSON RPC on this port, and the next port for the RPC websocket.
limit_ledger_size = 1337                        # Keep this amount of shreds in root slots.
ledger = "test-ledger"                          # Set ledger location.
gossip_port = 1337                              # Gossip port number for the validator.
gossip_host = "127.0.0.1"                       # Gossip DNS name or IP address for the validator to advertise in gossip.
faucet_sol = 1337                               # Give the faucet address this much SOL in genesis.
faucet_port = 1337                              # Enable the faucet on this port.
dynamic_port_range = "1337 - 13337"             # Range to use for dynamically assigned ports.
bind_address = "0.0.0.0"                        # IP address to bind the validator ports.
```

### test.validator.clone

Use this to clone an account from the `test.validator.clone.url` cluster to the
cluster of your test. If `address` points to a program owned by the "BPF
upgradeable loader", anchor (`>= 0.23.0`) will clone the program data account of
the program for you automatically.

Example:

```toml
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "7NL2qWArf2BbEBBH1vTRZCsoNqFATTddH6h8GkVvrLpG"
[[test.validator.clone]]
address = "2RaN5auQwMdg5efgCaVqpETBV8sacWGR8tkK4m9kjo5r"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s" # implicitly also clones PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT
```

### test.validator.account

Use this to upload an account from a `.json` file.

Example:

```toml
[[test.validator.account]]
address = "Ev8WSPQsGb4wfjybqff5eZNcS3n6HaMsBkMk9suAiuM"
filename = "some_account.json"

[[test.validator.account]]
address = "Ev8WSPQsGb4wfjybqff5eZNcS3n6HaMsBkMk9suAiuM"
filename = "some_other_account.json"
```

## toolchain

Override toolchain data in the workspace similar to
[`rust-toolchain.toml`](https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file).

```toml
[toolchain]
anchor_version = "0.31.0"    # `anchor-cli` version to use(requires `avm`)
solana_version = "2.1.0"     # Solana version to use(applies to all Solana tools)
package_manager = "yarn"     # JS package manager to use
```

````

File: anchor/docs/content/docs/references/account-types.mdx
```mdx
---
title: Account Types
description: Anchor Account Type Examples
---

Minimal reference examples for Anchor
[account types](https://docs.rs/anchor-lang/latest/anchor_lang/accounts/index.html).

See the account types
[source code](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts)
for implementation details.

## Account Types

### `Account<'info, T>`

Description: Account container that checks ownership on deserialization
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Account)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Account)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word: Account]
    // [!code highlight]
    pub account: Account<'info, CustomAccountType>,
}

#[account]
pub struct CustomAccountType {
    data: u64,
}
````

### `AccountInfo<'info>`

Description: AccountInfo can be used as a type but Unchecked Account should be
used instead  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/AccountInfo)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/AccountInfo)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    /// CHECK: AccountInfo is an unchecked account
    // [!code word:AccountInfo]
    // [!code highlight]
    pub unchecked_account: AccountInfo<'info>,
}
```

### `AccountLoader<'info, T>`

Description: Type facilitating on demand zero copy deserialization  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/AccountLoader)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/AccountLoader)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:AccountLoader]
    // [!code highlight]
    pub account: AccountLoader<'info, ZeroCopyAccountType>,
}

#[account(zero_copy)]
pub struct ZeroCopyAccountType {
    data: u64,
}
```

### `Box<Account<'info, T>>`

Description: Box type to save stack space  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Box)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Box)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:Box]
    // [!code highlight]
    pub account: Box<Account<'info, AccountType>>,
}
```

### `Interface<'info, T>`

Description: Type validating that the account is one of a set of given
Programs  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Interface)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Interface)

```rust title="snippet"
// Token program or Token2022 program
use anchor_spl::token_interface::TokenInterface;

#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word: Interface]
    // [!code highlight]
    pub program: Interface<'info, TokenInterface>,
}
```

### `InterfaceAccount<'info, T>`

Description: Account container that checks ownership on deserialization  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/InterfaceAccount)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/InterfaceAccount)

```rust title="snippet"
// Token program or Token2022 program Mint/TokenAccount
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};

#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:InterfaceAccount]
    // [!code highlight:2]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token: InterfaceAccount<'info, TokenAccount>,
    pub program: Interface<'info, TokenInterface>,
}
```

### `Option<Account<'info, T>>`

Description: Option type for optional accounts  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Option)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Option)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:Option]
    // [!code highlight]
    pub account: Option<Account<'info, AccountType>>,
}
```

### `Program<'info, T>`

Description: Type validating that the account is the given Program  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Program)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Program)

```rust title="snippet"
use anchor_spl::token::Token;

#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:Program]
    // [!code highlight:2]
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
}
```

### `Signer<'info>`

Description: Type validating that the account signed the transaction  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Signer)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Signer)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:Signer]
    // [!code highlight]
    pub signer: Signer<'info>,
}
```

### `SystemAccount<'info>`

Description: Type validating that the account is owned by the system program  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/SystemAccount)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/SystemAccount)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:SystemAccount]
    // [!code highlight]
    pub account: SystemAccount<'info>,
}
```

### `Sysvar<'info, T>`

Description: Type validating that the account is a sysvar and deserializing it  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/Sysvar)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/Sysvar)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // [!code word:Sysvar]
    // [!code highlight:2]
    pub rent: Sysvar<'info, Rent>,
    pub clock: Sysvar<'info, Clock>,
}
```

### `UncheckedAccount<'info>`

Description: Explicit wrapper for AccountInfo types to emphasize that no checks
are performed  
Examples: [Github](https://github.com/solana-developers/anchor-examples/tree/main/account-types/UncheckedAccount)
|
[Solpg](https://beta.solpg.io/https://github.com/solana-developers/anchor-examples/tree/main/account-types/UncheckedAccount)

```rust title="snippet"
#[derive(Accounts)]
pub struct InstructionAccounts<'info> {
    // CHECK: No checks are performed
    // [!code word:UncheckedAccount]
    // [!code highlight]
    pub account: UncheckedAccount<'info>,
}
```

````

File: anchor/docs/content/docs/references/avm.mdx
```mdx
---
title: Anchor Version Manager
description: AVM reference documentation
---

Anchor Version Manager (avm) is provided to manage multiple installations of the
anchor-cli binary. This may be required to produce verifiable builds, or if
you'd prefer to work with an alternate version.

---

```shell
Anchor version manager

USAGE:
    avm <SUBCOMMAND>

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    help         Print this message or the help of the given subcommand(s)
    install      Install a version of Anchor
    list         List available versions of Anchor
    uninstall    Uninstall a version of Anchor
    use          Use a specific version of Anchor
````

## Install

```shell
avm install <VERSION_OR_COMMIT>
```

Install the specified version of anchor-cli. The version argument should follow
semver versioning. It is also possible to use `latest` as the version argument
to install the latest version.

It's also possible to install based on a specific commit hash:

```shell
# <VERSION>-<COMMIT>
avm install 0.30.1-cfe82aa682138f7c6c58bf7a78f48f7d63e9e466

# Full commit hash
avm install cfe82aa682138f7c6c58bf7a78f48f7d63e9e466

# Short commit hash
avm install cfe82aa
```

## List

```shell
avm list
```

## Uninstall

```shell
avm uninstall <version>
```

## Use

```shell
avm use <version>
```

Use a specific version. This version will remain in use until you change it by
calling the same command again. Similarly to `avm install`, you can also use
`latest` for the version.

````

File: anchor/docs/content/docs/references/cli.mdx
```mdx
---
title: Anchor CLI
description: Anchor CLI reference documentation
---

A CLI is provided to support building and managing an Anchor workspace. For a
comprehensive list of commands and options, run `anchor -h` on any of the
following subcommands.

---

```shell
anchor-cli

USAGE:
    anchor <SUBCOMMAND>

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    account    Fetch and deserialize an account using the IDL provided
    build      Builds the workspace
    cluster    Cluster commands
    deploy     Deploys each program in the workspace
    expand     Expands the macros of a program or the workspace
    help       Prints this message or the help of the given subcommand(s)
    idl        Commands for interacting with interface definitions
    init       Initializes a workspace
    keys       Program keypair commands
    migrate    Runs the deploy migration script
    new        Creates a new program
    shell      Starts a node shell with an Anchor client setup according to the local config
    test       Runs integration tests against a localnetwork
    upgrade    Upgrades a single program. The configured wallet must be the upgrade authority
    verify     Verifies the on-chain bytecode matches the locally compiled artifact. Run this
               command inside a program subdirectory, i.e., in the dir containing the program's
               Cargo.toml
````

## Account

```
anchor account <program-name>.<AccountTypeName> <account_pubkey>
```

Fetches an account with the given public key and deserializes the data to JSON
using the type name provided. If this command is run from within a workspace,
the workspace's IDL files will be used to get the data types. Otherwise, the
path to the IDL file must be provided.

The `program-name` is the name of the program where the account struct resides,
usually under `programs/<program-name>`. `program-name` should be provided in a
case-sensitive manner exactly as the folder name, usually in kebab-case.

The `AccountTypeName` is the name of the account struct, usually in PascalCase.

The `account_pubkey` refers to the Pubkey of the account to deserialize, in
Base58.

Example Usage:
`anchor account anchor-escrow.EscrowAccount 3PNkzWKXCsbjijbasnx55NEpJe8DFXvEEbJKdRKpDcfK`,
deserializes an account in the given pubkey with the account struct
`EscrowAccount` defined in the `anchor-escrow` program.

```
anchor account <program-name>.<AccountTypeName> <account_pubkey> --idl <path/to/idl.json>
```

Deserializes the account with the data types provided in the given IDL file even
if inside a workspace.

## Build

```shell
anchor build
```

Builds programs in the workspace targeting Solana's BPF runtime and emitting
IDLs in the `target/idl` directory.

```shell
anchor build --verifiable
```

Runs the build inside a docker image so that the output binary is deterministic
(assuming a Cargo.lock file is used). This command must be run from within a
single crate subdirectory within the workspace. For example,
`programs/<my-program>/`.

<Callout title="Tip">
It's possible to pass arguments to the underlying `cargo build-sbf` command with `-- <ARGS>`. For example:

```
anchor build -- --features my-feature
```

</Callout>

## Cluster

### Cluster list

```shell
anchor cluster list
```

This lists cluster endpoints:

```shell
Cluster Endpoints:

* Mainnet - https://api.mainnet-beta.solana.com
* Devnet  - https://api.devnet.solana.com
* Testnet - https://api.testnet.solana.com
```

## Deploy

```shell
anchor deploy
```

Deploys all programs in the workspace to the configured cluster.

<Callout title="Tip">
  This is different from the `solana program deploy` command, because every time
  it's run it will generate a _new_ program address.
</Callout>

## Expand

```shell
anchor expand
```

If run inside a program folder, expands the macros of the program.

If run in the workspace but outside a program folder, expands the macros of the
workspace.

If run with the `--program-name` option, expand only the given program.

## Idl

The `idl` subcommand provides commands for interacting with interface definition
files. It's recommended to use these commands to store an IDL on chain, at a
deterministic address, as a function of nothing but the program's ID. This
allows us to generate clients for a program using nothing but the program ID.

### Idl Build

```shell
anchor idl build
```

Generates the IDL for the program using the compilation method.

### Idl Init

```shell
anchor idl init -f <target/idl/program.json> <program-id>
```

Creates an idl account, writing the given `<target/idl/program.json>` file into
a program owned account. By default, the size of the account is double the size
of the IDL, allowing room for growth in case the idl needs to be upgraded in the
future.

### Idl Fetch

```shell
anchor idl fetch -o <out-file.json> <program-id>
```

Fetches an IDL from the configured blockchain. For example, make sure your
`Anchor.toml` is pointing to the `mainnet` cluster and run

```shell
anchor idl fetch GrAkKfEpTKQuVHG2Y97Y2FF4i7y7Q5AHLK94JBy7Y5yv
```

### Idl Authority

```shell
anchor idl authority <program-id>
```

Outputs the IDL account's authority. This is the wallet that has the ability to
update the IDL.

### Idl Erase Authority

```shell
anchor idl erase-authority -p <program-id>
```

Erases the IDL account's authority so that upgrades can no longer occur. The
configured wallet must be the current authority.

### Idl Upgrade

```shell
anchor idl upgrade <program-id> -f <target/idl/program.json>
```

Upgrades the IDL file on chain to the new `target/idl/program.json` idl. The
configured wallet must be the current authority.

```shell
anchor idl set-authority -n <new-authority> -p <program-id>
```

Sets a new authority on the IDL account. Both the `new-authority` and
`program-id` must be encoded in base 58.

## Init

```shell
anchor init
```

Initializes a project workspace with the following structure.

- `Anchor.toml`: Anchor configuration file.
- `Cargo.toml`: Rust workspace configuration file.
- `package.json`: JavaScript dependencies file.
- `programs/`: Directory for Solana program crates.
- `app/`: Directory for your application frontend.
- `tests/`: Directory for JavaScript integration tests.
- `migrations/deploy.js`: Deploy script.

## Keys

Program keypair commands.

### Keys List

```shell
anchor keys list
```

List all of the program keys.

### Keys Sync

```shell
anchor keys sync
```

Sync program `declare_id!` pubkeys with the program's actual pubkey.

## Migrate

```shell
anchor migrate
```

Runs the deploy script located at `migrations/deploy.js`, injecting a provider
configured from the workspace's `Anchor.toml`. For example,

```javascript
// File: migrations/deploys.js

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  anchor.setProvider(provider);

  // Add your deploy script here.
};
```

Migrations are a new feature and only support this simple deploy script at the
moment.

## New

```shell
anchor new <program-name>
```

Creates a new program in the workspace's `programs/` directory initialized with
boilerplate.

## Shell

```shell
anchor shell
```

Starts a node js shell with an Anchor client setup according to the local
config. This client can be used to interact with deployed Solana programs in the
workspace.

## Test

```shell
anchor test
```

Run an integration test suit against the configured cluster, deploying new
versions of all workspace programs before running them.

If the configured network is a localnet, then automatically starts the
localnetwork and runs the test.

<Callout title="Note">
Be sure to shutdown any other local validators, otherwise `anchor test` will fail to run.

If you'd prefer to run the program against your local validator use
`anchor test --skip-local-validator`.

</Callout>

When running tests we stream program logs to
`.anchor/program-logs/<address>.<program-name>.log`

## Upgrade

```shell
anchor upgrade <target/deploy/program.so> --program-id <program-id>
```

Uses Solana's upgradeable BPF loader to upgrade the on chain program code.

## Verify

```shell
anchor verify <program-id>
```

Verifies the on-chain bytecode matches the locally compiled artifact.

````

File: anchor/docs/content/docs/references/examples.mdx
```mdx
---
title: Example Programs
description: Example Anchor programs references
---

## Basics

| Example                                                                                                                       | Description                                |
| ----------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| [checking-accounts](https://github.com/solana-developers/program-examples/tree/main/basics/checking-accounts)                 | Checking account example with Anchor       |
| [close-account](https://github.com/solana-developers/program-examples/tree/main/basics/close-account)                         | Close account example with Anchor          |
| [counter](https://github.com/solana-developers/program-examples/tree/main/basics/counter)                                     | Counter program using Anchor               |
| [create-account](https://github.com/solana-developers/program-examples/tree/main/basics/create-account)                       | Create accounts with Anchor                |
| [cross-program-invocation](https://github.com/solana-developers/program-examples/tree/main/basics/cross-program-invocation)   | Cross program invocation with Anchor       |
| [favorites](https://github.com/solana-developers/program-examples/tree/main/basics/favorites)                                 | Store user "favorites" with Anchor         |
| [hello-solana](https://github.com/solana-developers/program-examples/tree/main/basics/hello-solana)                           | Basic "Hello, Solana!" program with Anchor |
| [pda-rent-payer](https://github.com/solana-developers/program-examples/tree/main/basics/pda-rent-payer)                       | PDA rent payer example with Anchor         |
| [processing-instructions](https://github.com/solana-developers/program-examples/tree/main/basics/processing-instructions)     | Process instructions using Anchor          |
| [program-derived-addresses](https://github.com/solana-developers/program-examples/tree/main/basics/program-derived-addresses) | Program-derived addresses with Anchor      |
| [realloc](https://github.com/solana-developers/program-examples/tree/main/basics/realloc)                                     | Reallocate account data with Anchor        |
| [rent](https://github.com/solana-developers/program-examples/tree/main/basics/rent)                                           | Calculate account SOL rent with Anchor     |
| [transfer-sol](https://github.com/solana-developers/program-examples/tree/main/basics/transfer-sol)                           | Transfer SOL tokens with Anchor            |

## Tokens

| Example                                                                                                         | Description                       |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------- |
| [create-token](https://github.com/solana-developers/program-examples/tree/main/tokens/create-token)             | Create an SPL token with Anchor   |
| [escrow](https://github.com/solana-developers/program-examples/tree/main/tokens/escrow)                         | Escrow program using Anchor       |
| [nft-minter](https://github.com/solana-developers/program-examples/tree/main/tokens/nft-minter)                 | Mint NFTs using Anchor            |
| [nft-operations](https://github.com/solana-developers/program-examples/tree/main/tokens/nft-operations)         | NFT operations with Anchor        |
| [pda-mint-authority](https://github.com/solana-developers/program-examples/tree/main/tokens/pda-mint-authority) | PDA as mint authority with Anchor |
| [spl-token-minter](https://github.com/solana-developers/program-examples/tree/main/tokens/spl-token-minter)     | SPL token minting with Anchor     |
| [token-fundraiser](https://github.com/solana-developers/program-examples/tree/main/tokens/token-fundraiser)     | Token fundraiser using Anchor     |
| [token-swap](https://github.com/solana-developers/program-examples/tree/main/tokens/token-swap)                 | Swap tokens with Anchor           |
| [transfer-tokens](https://github.com/solana-developers/program-examples/tree/main/tokens/transfer-tokens)       | Transfer SPL tokens using Anchor  |

## Token Extensions

| Example                                                                                                                          | Description                             |
| -------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| [basics](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/basics)                               | Basics of Token 2022 with Anchor        |
| [cpi-guard](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/cpi-guard)                         | CPI guard example with Anchor           |
| [default-account-state](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/default-account-state) | Default account state setup with Anchor |
| [group](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/group)                                 | Token grouping example with Anchor      |
| [immutable-owner](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/immutable-owner)             | Immutable owner setup with Anchor       |
| [interest-bearing](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/interest-bearing)           | Interest-bearing tokens using Anchor    |
| [memo-transfer](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/memo-transfer)                 | Memo transfer with Anchor               |
| [metadata](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/metadata)                           | Token metadata with Anchor              |
| [mint-close-authority](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/mint-close-authority)   | Mint close authority with Anchor        |
| [multiple-extensions](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/multiple-extensions)     | Multiple extensions example with Anchor |
| [nft-meta-data-pointer](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/nft-meta-data-pointer) | NFT metadata pointer with Anchor        |
| [non-transferable](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/non-transferable)           | Non-transferable tokens using Anchor    |
| [permanent-delegate](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/permanent-delegate)       | Permanent delegate setup with Anchor    |
| [transfer-fee](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/transfer-fee)                   | Transfer fees example with Anchor       |
| [transfer-hook](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022/transfer-hook)                 | Transfer hook example with Anchor       |

````

File: anchor/docs/content/docs/references/index.mdx

```mdx
---
title: Anchor References
description: Reference documentation for the Anchor framework.
index: true
---
```

File: anchor/docs/content/docs/references/security-exploits.mdx

```mdx
---
title: Sealevel Attacks
description: Anchor - Sealevel Attacks
---

Anchor uses a lot of magic to help eliminate footguns, but if you're shipping
anything to mainnet, it's important you understand every bit of that magic and
the motivation behind it. A list of common attacks can be found
[here](https://github.com/coral-xyz/sealevel-attacks), providing three different
examples for each example attack

1. insecure - represents flawed code that may be insecure
2. secure - represents a fix
3. recommended - represents a fix with idiomatic Anchor code

Note that none of these examples are not necessarily secure, but they are meant
to showcase a specific issue and a recommended fix in isolation.
```

File: anchor/docs/content/docs/references/meta.json

```json
{
  "title": "Program Development",
  "pages": [
    "account-types",
    "account-constraints",
    "anchor-toml",
    "cli",
    "avm",
    "space",
    "type-conversion",
    "verifiable-builds",
    "security-exploits",
    "examples"
  ]
}
```

File: anchor/docs/content/docs/references/space.mdx

````mdx
---
title: Account Space
description:
  Reference guide for calculating account data size (bytes) requirements by Rust
  type
---

This reference tells you how much space you should allocate for an account.

This only applies to accounts that don't use `zero-copy`. `zero-copy` uses
`repr(C)` with a pointer cast, so there the `C` layout applies.

In addition to the space for the account data, you have to add `8` to the
`space` constraint for Anchor's internal discriminator (see the example).

## Type chart

| Types      | Space in bytes                | Details/Example                                                                                 |
| ---------- | ----------------------------- | ----------------------------------------------------------------------------------------------- |
| bool       | 1                             | would only require 1 bit but still uses 1 byte                                                  |
| u8/i8      | 1                             |
| u16/i16    | 2                             |
| u32/i32    | 4                             |
| u64/i64    | 8                             |
| u128/i128  | 16                            |
| [T;amount] | space(T) \* amount            | e.g. space([u16;32]) = 2 \* 32 = 64                                                             |
| Pubkey     | 32                            |
| Vec\<T>    | 4 + (space(T) \* amount)      | Account size is fixed so account should be initialized with sufficient space from the beginning |
| String     | 4 + length of string in bytes | Account size is fixed so account should be initialized with sufficient space from the beginning |
| Option\<T> | 1 + (space(T))                |
| Enum       | 1 \+ Largest Variant Size     | e.g. Enum \{ A, B \{ val: u8 \}, C \{ val: u16 \} \} \-\> 1 \+ space(u16) = 3                   |
| f32        | 4                             | serialization will fail for NaN                                                                 |
| f64        | 8                             | serialization will fail for NaN                                                                 |

## Example

```rust
#[account]
pub struct MyData {
    pub val: u16,
    pub state: GameState,
    pub players: Vec<Pubkey> // we want to support up to 10 players
}


impl MyData {
    // [!code highlight]
    pub const MAX_SIZE: usize = 2 + (1 + 32) + (4 + 10 * 32);
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum GameState {
    Active,
    Tie,
    Won { winner: Pubkey },
}

#[derive(Accounts)]
pub struct InitializeMyData<'info> {
    // Note that we have to add 8 to the space for the internal anchor
    // [!code highlight]
    #[account(init, payer = signer, space = 8 + MyData::MAX_SIZE)]
    pub acc: Account<'info, MyData>,
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
````

## The InitSpace macro

Sometimes it can be difficult to calculate the initial space of an account. This
macro will add an `INIT_SPACE` constant to the structure. It is not necessary
for the structure to contain the `#[account]` macro to generate the constant.
Here's an example:

```rust
#[account]
// [!code word:InitSpace]
// [!code highlight]
#[derive(InitSpace)]
pub struct ExampleAccount {
    pub data: u64,
    #[max_len(50)]
    pub string_one: String,
    #[max_len(10, 5)]
    pub nested: Vec<Vec<u8>>,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    // [!code word:INIT_SPACE]
    // [!code highlight]
    #[account(init, payer = payer, space = 8 + ExampleAccount::INIT_SPACE)]
    pub data: Account<'info, ExampleAccount>,
}
```

A few important things to know:

- Don't forget the discriminator when defining `space`
- The `max_len` length represents the length of the structure, not the total
  length. (ie: the `max_len` of a Vec\<u32\> will be `max_len` \* 4)

````

File: anchor/docs/content/docs/references/type-conversion.mdx
```mdx
---
title: Rust to JS Type Conversion
description: Reference for how Anchor converts between Rust and TypeScript types
---

This reference shows to converts between Rust and TypeScript types.

## Primitive Types

### Boolean

| Rust   | TypeScript | Example |
| ------ | ---------- | ------- |
| `bool` | `boolean`  | `true`  |

### Numbers

| Rust                    | TypeScript  | Example             |
| ----------------------- | ----------- | ------------------- |
| `u8/u16/u32/i8/i16/i32` | `number`    | `99`                |
| `u64/u128/i64/i128`     | `anchor.BN` | `new anchor.BN(99)` |
| `f32/f64`               | `number`    | `1.0`               |

### Strings

| Rust     | TypeScript | Example   |
| -------- | ---------- | --------- |
| `String` | `string`   | `"hello"` |

## Collections

### Arrays and Vectors

| Rust                   | TypeScript | Example     |
| ---------------------- | ---------- | ----------- |
| `[T; N]` (fixed array) | `Array<T>` | `[1, 2, 3]` |
| `Vec<T>` (vector)      | `Array<T>` | `[1, 2, 3]` |

### Optional Values

| Rust        | TypeScript               | Example                       |
| ----------- | ------------------------ | ----------------------------- |
| `Option<T>` | `T \| null \| undefined` | `null` (None)<br/>`42` (Some) |

## Complex Types

### Structs

```rust title="Rust"
// Rust
struct MyStruct {
    val: u16,
}
````

```typescript title="TypeScript"
// TypeScript
type MyStruct = {
  val: number;
};

// Example
const instance = { val: 99 };
```

### Enums

```rust title="Rust"
// Rust
enum MyEnum {
    One,
    Two { val: u32 },
    Three(u8, i16),
}
```

```typescript title="TypeScript"
// TypeScript Representations
// Unit variant
const one = { one: {} };

// Named variant
const two = {
  two: { val: 99 },
};

// Tuple variant
const three = {
  three: [12, -34],
};
```

## Notes

- Rust integers (`u8` through `i32`) map to JavaScript `number`
- Larger integers (`u64` and above) use Anchor's `BN` type for precision
- Rust's `Option<T>` maps to TypeScript's union type with `null`/`undefined`
- Structs and enums become JavaScript objects

````

File: anchor/docs/content/docs/references/verifiable-builds.mdx
```mdx
---
title: Verifiable Builds
description: Anchor - Verifiable Builds
---

Building programs with the Solana CLI may embed machine specific code into the
resulting binary. As a result, building the same program on different machines
may produce different executables. To get around this problem, one can build
inside a docker image with pinned dependencies to produce a verifiable build.

---

Anchor makes this easy by providing CLI commands to build and take care of
docker for you. To get started, first make sure you
[install](https://docs.docker.com/get-docker/) docker on your local machine.

## Building

To produce a verifiable build, run

```shell
anchor build --verifiable
````

## Verifying

To verify a build against a program deployed on mainnet, run

```shell
anchor verify -p <lib-name> <program-id>
```

where the `<lib-name>` is defined by your program's Cargo.toml.

If the program has an IDL, it will also check the IDL deployed on chain matches.

## Images

A docker image for each version of Anchor is published on
[Docker Hub](https://hub.docker.com/r/solanafoundation/anchor). They are tagged
in the form `solanafoundation/anchor:<version>`. For example, to get the image
for Anchor `v0.31.0` one can run

```shell
docker pull solanafoundation/anchor:v0.31.0
```

## Removing an Image

In the event you run a verifiable build from the CLI and exit prematurely, it's
possible the docker image may still be building in the background.

To remove, run

```shell
docker rm -f anchor-program
```

where `anchor-program` is the name of the image created by default from within
the Anchor CLI.

````

File: anchor/docs/content/docs/testing/index.mdx
```mdx
---
title: Testing
description:
  Learn how to test Anchor programs using various test frameworks in TypeScript
  and Rust.
index: true
---

````

File: anchor/docs/content/docs/testing/litesvm.mdx

````mdx
---
title: LiteSVM
description: Write tests for Solana programs in Rust, TS/JS or Python using LiteSVM.
---

## Overview

[`litesvm`](https://github.com/LiteSVM/litesvm) is a fast and lightweight library for testing Solana programs.
It works by creating an in-process Solana VM optimized for program developers.
This makes it much faster to run and compile than alternatives like `solana-program-test` and `solana-test-validator`.
`litesvm` is available in Rust, TS/JS and Python (as part of the [`solders`](https://pypi.org/project/solders/) library).

### Installation

import { Tab, Tabs } from "fumadocs-ui/components/tabs";

<Tabs items={["Rust", "TS/JS", "Python"]}>
```sh tab="Rust"
cargo add litesvm --dev
````

```sh tab="TS/JS"
npm i litesvm -D
```

```sh tab="Python"
uv add solders # from solders import litesvm
```

</Tabs>

### Minimal Example

<Tabs items={["Rust", "TypeScript", "Python"]}>

```rust tab="Rust"
use litesvm::LiteSVM;
use solana_message::Message;
use solana_pubkey::Pubkey;
use solana_system_interface::instruction::transfer;
use solana_keypair::Keypair;
use solana_signer::Signer;
use solana_transaction::Transaction;

let from_keypair = Keypair::new();
let from = from_keypair.pubkey();
let to = Pubkey::new_unique();

let mut svm = LiteSVM::new();
svm.airdrop(&from, 10_000).unwrap();

let instruction = transfer(&from, &to, 64);
let tx = Transaction::new(
    &[&from_keypair],
    Message::new(&[instruction], Some(&from)),
    svm.latest_blockhash(),
);
let tx_res = svm.send_transaction(tx).unwrap();

let from_account = svm.get_account(&from);
let to_account = svm.get_account(&to);
assert_eq!(from_account.unwrap().lamports, 4936);
assert_eq!(to_account.unwrap().lamports, 64);
```

```ts tab="TypeScript"
import { LiteSVM } from "litesvm";
import {
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";

test("one transfer", () => {
  const svm = new LiteSVM();
  const payer = new Keypair();
  svm.airdrop(payer.publicKey, BigInt(LAMPORTS_PER_SOL));
  const receiver = PublicKey.unique();
  const blockhash = svm.latestBlockhash();
  const transferLamports = 1_000_000n;
  const ixs = [
    SystemProgram.transfer({
      fromPubkey: payer.publicKey,
      toPubkey: receiver,
      lamports: transferLamports,
    }),
  ];
  const tx = new Transaction();
  tx.recentBlockhash = blockhash;
  tx.add(...ixs);
  tx.sign(payer);
  svm.sendTransaction(tx);
  const balanceAfter = svm.getBalance(receiver);
  expect(balanceAfter).toBe(transferLamports);
});
```

```python tab="Python"
from solders.keypair import Keypair
from solders.litesvm import LiteSVM
from solders.message import Message
from solders.pubkey import Pubkey
from solders.system_program import transfer
from solders.transaction import VersionedTransaction


def test_transfer() -> None:
    receiver = Pubkey.new_unique()
    client = LiteSVM()
    payer = Keypair()
    client.airdrop(payer.pubkey(), 1_000_000_000)
    blockhash = client.latest_blockhash()
    transfer_lamports = 1_000_000
    ixs = [
        transfer(
            {
                "from_pubkey": payer.pubkey(),
                "to_pubkey": receiver,
                "lamports": transfer_lamports,
            }
        )
    ]
    msg = Message.new_with_blockhash(ixs, payer.pubkey(), blockhash)
    tx = VersionedTransaction(msg, [payer])
    client.send_transaction(tx)
    balance_after = client.get_balance(receiver)
    assert balance_after == transfer_lamports
```

</Tabs>

## Deploying Programs

Most of the time we want to do more than just mess around with token transfers -
we want to test our own programs.

**Tip**: if you want to pull a Solana program from mainnet or devnet, use the `solana program dump` command from the Solana CLI.

To add a compiled program to our tests we can use [`.add_program_from_file`](https://docs.rs/litesvm/latest/litesvm/struct.LiteSVM.html#method.add_program_from_file).

Here's an example using a [simple program](https://github.com/solana-labs/solana-program-library/tree/bd216c8103cd8eb9f5f32e742973e7afb52f3b81/examples/rust/logging)
from the Solana Program Library that just does some logging:

<Tabs items={["Rust", "TypeScript", "Python"]}>

```rust tab="Rust"
use {
    litesvm::LiteSVM,
    solana_instruction::{account_meta::AccountMeta, Instruction},
    solana_keypair::Keypair,
    solana_pubkey::{pubkey, Pubkey},
    solana_message::{Message, VersionedMessage},
    solana_signer::Signer,
    solana_transaction::VersionedTransaction,
};

fn test_logging() {
    let program_id = pubkey!("Logging111111111111111111111111111111111111");
    let account_meta = AccountMeta {
        pubkey: Pubkey::new_unique(),
        is_signer: false,
        is_writable: true,
    };
    let ix = Instruction {
        program_id,
        accounts: vec![account_meta],
        data: vec![5, 10, 11, 12, 13, 14],
    };
    let mut svm = LiteSVM::new();
    let payer = Keypair::new();
    let bytes = include_bytes!("../../node-litesvm/program_bytes/spl_example_logging.so");
    svm.add_program(program_id, bytes);
    svm.airdrop(&payer.pubkey(), 1_000_000_000).unwrap();
    let blockhash = svm.latest_blockhash();
    let msg = Message::new_with_blockhash(&[ix], Some(&payer.pubkey()), &blockhash);
    let tx = VersionedTransaction::try_new(VersionedMessage::Legacy(msg), &[payer]).unwrap();
    // let's sim it first
    let sim_res = svm.simulate_transaction(tx.clone()).unwrap();
    let meta = svm.send_transaction(tx).unwrap();
    assert_eq!(sim_res.meta, meta);
    assert_eq!(meta.logs[1], "Program log: static string");
    assert!(meta.compute_units_consumed < 10_000) // not being precise here in case it changes
}
```

```ts tab="TypeScript"
import { LiteSVM, TransactionMetadata } from "litesvm";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  Transaction,
  TransactionInstruction,
} from "@solana/web3.js";

test("spl logging", () => {
  const programId = PublicKey.unique();
  const svm = new LiteSVM();
  svm.addProgramFromFile(programId, "program_bytes/spl_example_logging.so");
  const payer = new Keypair();
  svm.airdrop(payer.publicKey, BigInt(LAMPORTS_PER_SOL));
  const blockhash = svm.latestBlockhash();
  const ixs = [
    new TransactionInstruction({
      programId,
      keys: [
        { pubkey: PublicKey.unique(), isSigner: false, isWritable: false },
      ],
    }),
  ];
  const tx = new Transaction();
  tx.recentBlockhash = blockhash;
  tx.add(...ixs);
  tx.sign(payer);
  // let's sim it first
  const simRes = svm.simulateTransaction(tx);
  const sendRes = svm.sendTransaction(tx);
  if (sendRes instanceof TransactionMetadata) {
    expect(simRes.meta().logs()).toEqual(sendRes.logs());
    expect(sendRes.logs()[1]).toBe("Program log: static string");
  } else {
    throw new Error("Unexpected tx failure");
  }
});
```

```python tab="Python"
from pathlib import Path

from solders.instruction import AccountMeta, Instruction
from solders.keypair import Keypair
from solders.litesvm import LiteSVM
from solders.message import Message
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction
from solders.transaction_metadata import TransactionMetadata


def test_logging() -> None:
    program_id = Pubkey.from_string("Logging111111111111111111111111111111111111")
    ix = Instruction(
        program_id,
        bytes([5, 10, 11, 12, 13, 14]),
        [AccountMeta(Pubkey.new_unique(), is_signer=False, is_writable=True)],
    )
    client = LiteSVM()
    payer = Keypair()
    client.add_program_from_file(
        program_id, Path("tests/fixtures/spl_example_logging.so")
    )
    client.airdrop(payer.pubkey(), 1_000_000_000)
    blockhash = client.latest_blockhash()
    msg = Message.new_with_blockhash([ix], payer.pubkey(), blockhash)
    tx = VersionedTransaction(msg, [payer])
    # let's sim it first
    sim_res = client.simulate_transaction(tx)
    meta = client.send_transaction(tx)
    assert isinstance(meta, TransactionMetadata)
    assert sim_res.meta() == meta
    assert meta.logs()[1] == "Program log: static string"
    assert (
        meta.compute_units_consumed() < 10_000
    )  # not being precise here in case it changes
```

</Tabs>

## Time travel

Many programs rely on the `Clock` sysvar: for example, a mint that doesn't become available until after
a certain time. With `litesvm` you can dynamically overwrite the `Clock` sysvar
using [`svm.set_sysvar::<Clock>()`](https://docs.rs/litesvm/latest/litesvm/struct.LiteSVM.html#method.set_sysvar)
(or `.setClock` in TS, or `.set_clock` in Python).
Here's an example using a program that panics if `clock.unix_timestamp` is greater than 100
(which is on January 1st 1970):

<Tabs items={["Rust", "TypeScript", "Python"]}>

```rust tab="Rust"
use {
    litesvm::LiteSVM,
    solana_clock::Clock,
    solana_instruction::Instruction,
    use solana_keypair::Keypair,
    solana_message::{Message, VersionedMessage},
    solana_pubkey::Pubkey,
    solana_signer::Signer,
    solana_transaction::VersionedTransaction,
};

fn test_set_clock() {
    let program_id = Pubkey::new_unique();
    let mut svm = LiteSVM::new();
    let bytes = include_bytes!("../../node-litesvm/program_bytes/litesvm_clock_example.so");
    svm.add_program(program_id, bytes);
    let payer = Keypair::new();
    let payer_address = payer.pubkey();
    svm.airdrop(&payer.pubkey(), 1_000_000_000).unwrap();
    let blockhash = svm.latest_blockhash();
    let ixs = [Instruction {
        program_id,
        data: vec![],
        accounts: vec![],
    }];
    let msg = Message::new_with_blockhash(&ixs, Some(&payer_address), &blockhash);
    let versioned_msg = VersionedMessage::Legacy(msg);
    let tx = VersionedTransaction::try_new(versioned_msg, &[&payer]).unwrap();
    // set the time to January 1st 2000
    let mut initial_clock = svm.get_sysvar::<Clock>();
    initial_clock.unix_timestamp = 1735689600;
    svm.set_sysvar::<Clock>(&initial_clock);
    // this will fail because it's not January 1970 anymore
    svm.send_transaction(tx).unwrap_err();
    // so let's turn back time
    let mut clock = svm.get_sysvar::<Clock>();
    clock.unix_timestamp = 50;
    svm.set_sysvar::<Clock>(&clock);
    let ixs2 = [Instruction {
        program_id,
        data: vec![1], // unused, this is just to dedup the transaction
        accounts: vec![],
    }];
    let msg2 = Message::new_with_blockhash(&ixs2, Some(&payer_address), &blockhash);
    let versioned_msg2 = VersionedMessage::Legacy(msg2);
    let tx2 = VersionedTransaction::try_new(versioned_msg2, &[&payer]).unwrap();
    // now the transaction goes through
    svm.send_transaction(tx2).unwrap();
}

```

```ts tab="TypeScript"
import {
  FailedTransactionMetadata,
  LiteSVM,
  TransactionMetadata,
} from "litesvm";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  Transaction,
  TransactionInstruction,
} from "@solana/web3.js";

test("clock", () => {
  const programId = PublicKey.unique();
  const svm = new LiteSVM();
  svm.addProgramFromFile(programId, "program_bytes/litesvm_clock_example.so");
  const payer = new Keypair();
  svm.airdrop(payer.publicKey, BigInt(LAMPORTS_PER_SOL));
  const blockhash = svm.latestBlockhash();
  const ixs = [
    new TransactionInstruction({ keys: [], programId, data: Buffer.from("") }),
  ];
  const tx = new Transaction();
  tx.recentBlockhash = blockhash;
  tx.add(...ixs);
  tx.sign(payer);
  // set the time to January 1st 2000
  const initialClock = svm.getClock();
  initialClock.unixTimestamp = 1735689600n;
  svm.setClock(initialClock);
  // this will fail because the contract wants it to be January 1970
  const failed = svm.sendTransaction(tx);
  if (failed instanceof FailedTransactionMetadata) {
    expect(failed.err().toString()).toContain("ProgramFailedToComplete");
  } else {
    throw new Error("Expected transaction failure here");
  }
  // so let's turn back time
  const newClock = svm.getClock();
  newClock.unixTimestamp = 50n;
  svm.setClock(newClock);
  const ixs2 = [
    new TransactionInstruction({
      keys: [],
      programId,
      data: Buffer.from("foobar"), // unused, just here to dedup the tx
    }),
  ];
  const tx2 = new Transaction();
  tx2.recentBlockhash = blockhash;
  tx2.add(...ixs2);
  tx2.sign(payer);
  // now the transaction goes through
  const success = svm.sendTransaction(tx2);
  expect(success).toBeInstanceOf(TransactionMetadata);
});
```

```python tab="Python"
from pathlib import Path

from solders.instruction import Instruction
from solders.keypair import Keypair
from solders.litesvm import LiteSVM
from solders.message import Message
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction
from solders.transaction_metadata import FailedTransactionMetadata, TransactionMetadata


def test_set_clock() -> None:
    program_id = Pubkey.new_unique()
    client = LiteSVM()
    client.add_program_from_file(
        program_id, Path("tests/fixtures/solders_clock_example.so")
    )
    payer = Keypair()
    client.airdrop(payer.pubkey(), 1_000_000_000)
    blockhash = client.latest_blockhash()
    ixs = [Instruction(program_id=program_id, data=b"", accounts=[])]
    msg = Message.new_with_blockhash(ixs, payer.pubkey(), blockhash)
    tx = VersionedTransaction(msg, [payer])
    # set the time to January 1st 2000
    initial_clock = client.get_clock()
    initial_clock.unix_timestamp = 1735689600
    client.set_clock(initial_clock)
    # this will fail because it's not January 1970 anymore
    bad_res = client.send_transaction(tx)
    assert isinstance(bad_res, FailedTransactionMetadata)
    # so let's turn back time
    clock = client.get_clock()
    clock.unix_timestamp = 50
    client.set_clock(clock)
    ixs2 = [
        Instruction(
            program_id=program_id,
            data=b"foobar",  # unused, this is just to dedup the transaction
            accounts=[],
        )
    ]
    msg2 = Message.new_with_blockhash(ixs2, payer.pubkey(), blockhash)
    tx2 = VersionedTransaction(msg2, [payer])
    # now the transaction goes through
    good_res = client.send_transaction(tx2)
    assert isinstance(good_res, TransactionMetadata)

```

</Tabs>

See also: [`warp_to_slot`](https://docs.rs/litesvm/latest/litesvm/struct.LiteSVM.html#method.warp_to_slot), which lets you jump to a future slot.

## Writing arbitrary accounts

LiteSVM lets you write any account data you want, regardless of
whether the account state would even be possible.

Here's an example where we give an account a bunch of USDC,
even though we don't have the USDC mint keypair. This is
convenient for testing because it means we don't have to
work with fake USDC in our tests:

<Tabs items={["Rust", "TypeScript", "Python"]}>

```rust tab="Rust"
use {
    litesvm::LiteSVM,
    solana_account::Account,
    solana_program_option::COption,
    solana_program_pack::Pack,
    solana_pubkey::{pubkey, Pubkey},
    spl_associated_token_account_client::address::get_associated_token_address,
    spl_token::{
        state::{Account as TokenAccount, AccountState},
        ID as TOKEN_PROGRAM_ID,
    },
};

fn test_infinite_usdc_mint() {
    let owner = Pubkey::new_unique();
    let usdc_mint = pubkey!("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
    let ata = get_associated_token_address(&owner, &usdc_mint);
    let usdc_to_own = 1_000_000_000_000;
    let token_acc = TokenAccount {
        mint: usdc_mint,
        owner: owner,
        amount: usdc_to_own,
        delegate: COption::None,
        state: AccountState::Initialized,
        is_native: COption::None,
        delegated_amount: 0,
        close_authority: COption::None,
    };
    let mut svm = LiteSVM::new();
    let mut token_acc_bytes = [0u8; TokenAccount::LEN];
    TokenAccount::pack(token_acc, &mut token_acc_bytes).unwrap();
    svm.set_account(
        ata,
        Account {
            lamports: 1_000_000_000,
            data: token_acc_bytes.to_vec(),
            owner: TOKEN_PROGRAM_ID,
            executable: false,
            rent_epoch: 0,
        },
    )
    .unwrap();
    let raw_account = svm.get_account(&ata).unwrap();
    assert_eq!(
        TokenAccount::unpack(&raw_account.data).unwrap().amount,
        usdc_to_own
    )
}

```

```ts tab="TypeScript"
import { LiteSVM } from "litesvm";
import { PublicKey } from "@solana/web3.js";
import {
  getAssociatedTokenAddressSync,
  AccountLayout,
  ACCOUNT_SIZE,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";

test("infinite usdc mint", () => {
  const owner = PublicKey.unique();
  const usdcMint = new PublicKey(
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
  );
  const ata = getAssociatedTokenAddressSync(usdcMint, owner, true);
  const usdcToOwn = 1_000_000_000_000n;
  const tokenAccData = Buffer.alloc(ACCOUNT_SIZE);
  AccountLayout.encode(
    {
      mint: usdcMint,
      owner,
      amount: usdcToOwn,
      delegateOption: 0,
      delegate: PublicKey.default,
      delegatedAmount: 0n,
      state: 1,
      isNativeOption: 0,
      isNative: 0n,
      closeAuthorityOption: 0,
      closeAuthority: PublicKey.default,
    },
    tokenAccData
  );
  const svm = new LiteSVM();
  svm.setAccount(ata, {
    lamports: 1_000_000_000,
    data: tokenAccData,
    owner: TOKEN_PROGRAM_ID,
    executable: false,
  });
  const rawAccount = svm.getAccount(ata);
  expect(rawAccount).not.toBeNull();
  const rawAccountData = rawAccount?.data;
  const decoded = AccountLayout.decode(rawAccountData);
  expect(decoded.amount).toBe(usdcToOwn);
});
```

```python tab="Python"
from solders.account import Account
from solders.litesvm import LiteSVM
from solders.pubkey import Pubkey
from solders.token import ID as TOKEN_PROGRAM_ID
from solders.token.associated import get_associated_token_address
from solders.token.state import TokenAccount, TokenAccountState


def test_infinite_usdc_mint() -> None:
    owner = Pubkey.new_unique()
    usdc_mint = Pubkey.from_string("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")
    ata = get_associated_token_address(owner, usdc_mint)
    usdc_to_own = 1_000_000_000_000
    token_acc = TokenAccount(
        mint=usdc_mint,
        owner=owner,
        amount=usdc_to_own,
        delegate=None,
        state=TokenAccountState.Initialized,
        is_native=None,
        delegated_amount=0,
        close_authority=None,
    )
    client = LiteSVM()
    client.set_account(
        ata,
        Account(
            lamports=1_000_000_000,
            data=bytes(token_acc),
            owner=TOKEN_PROGRAM_ID,
            executable=False,
        ),
    )
    raw_account = client.get_account(ata)
    assert raw_account is not None
    raw_account_data = raw_account.data
    assert TokenAccount.from_bytes(raw_account_data).amount == usdc_to_own

```

</Tabs>

## Copying Accounts from a live environment

If you want to copy accounts from mainnet or devnet, you can use the `solana account` command in the Solana CLI to save account data to a file.

## Other features

Other things you can do with `litesvm` include:

- Changing the max compute units and other compute budget behaviour using [`.with_compute_budget`](https://docs.rs/litesvm/latest/litesvm/struct.LiteSVM.html#method.with_compute_budget).
- Disable transaction signature checking using [`.with_sigverify(false)`](https://docs.rs/litesvm/latest/litesvm/struct.LiteSVM.html#method.with_sigverify).
- Find previous transactions using [`.get_transaction`](https://docs.rs/litesvm/latest/litesvm/struct.LiteSVM.html#method.get_transaction).

## When should I use `solana-test-validator`?

While `litesvm` is faster and more convenient, it is also less like a real RPC node.
So `solana-test-validator` is still useful when you need to call RPC methods that LiteSVM
doesn't support, or when you want to test something that depends on real-life validator behaviour
rather than just testing your program and client code.

In general though it is recommended to use `litesvm` wherever possible, as it will make your life
much easier.

````

File: anchor/docs/content/docs/testing/meta.json
```json
{
  "title": "Testing Libraries",
  "pages": ["litesvm", "mollusk"]
}

````

File: anchor/docs/content/docs/testing/mollusk.mdx

````mdx
---
title: Mollusk
description: Write tests for Solana programs in Rust using Mollusk.
---

[Mollusk](https://github.com/anza-xyz/mollusk) is a lightweight test harness for
Solana programs. It provides a simple interface for testing Solana program
executions in a minified Solana Virtual Machine (SVM) environment.

```rust
mollusk.process_and_validate_instruction(
    &instruction,   // <-- Instruction to test
    &accounts,      // <-- Account states
    &checks,        // <-- Checks to run on the instruction result
);
```
````

It does not create any semblance of a validator runtime, but instead provisions
a program execution pipeline directly from lower-level SVM components.

In summary, the main processor - `process_instruction` - creates minified
instances of Agave's program cache, transaction context, and invoke context. It
uses these components to directly execute the provided program's ELF using the
BPF Loader.

Because it does not use AccountsDB, Bank, or any other large Agave components,
the harness is exceptionally fast. However, it does require the user to provide
an explicit list of accounts to use, since it has nowhere to load them from.

The test environment can be further configured by adjusting the compute budget,
feature set, or sysvars. These configurations are stored directly on the test
harness (the `Mollusk` struct), but can be manipulated through a handful of
helpers.

Four main API methods are offered:

- `process_instruction`: Process an instruction and return the result.
- `process_and_validate_instruction`: Process an instruction and perform a
  series of checks on the result, panicking if any checks fail.
- `process_instruction_chain`: Process a chain of instructions and return the
  result.
- `process_and_validate_instruction_chain`: Process a chain of instructions and
  perform a series of checks on each result, panicking if any checks fail.

## Single Instructions

Both `process_instruction` and `process_and_validate_instruction` deal with
single instructions. The former simply processes the instruction and returns the
result, while the latter processes the instruction and then performs a series of
checks on the result. In both cases, the result is also returned.

```rust
use {
    mollusk_svm::Mollusk,
    solana_sdk::{account::Account, instruction::{AccountMeta, Instruction}, pubkey::Pubkey},
};

let program_id = Pubkey::new_unique();
let key1 = Pubkey::new_unique();
let key2 = Pubkey::new_unique();

let instruction = Instruction::new_with_bytes(
    program_id,
    &[],
    vec![
        AccountMeta::new(key1, false),
        AccountMeta::new_readonly(key2, false),
    ],
);

let accounts = vec![
    (key1, Account::default()),
    (key2, Account::default()),
];

let mollusk = Mollusk::new(&program_id, "my_program");

// Execute the instruction and get the result.
let result = mollusk.process_instruction(&instruction, &accounts);
```

To apply checks via `process_and_validate_instruction`, developers can use the
`Check` enum, which provides a set of common checks.

```rust
use {
    mollusk_svm::{Mollusk, result::Check},
    solana_sdk::{
        account::Account,
        instruction::{AccountMeta, Instruction},
        pubkey::Pubkey
        system_instruction,
        system_program,
    },
};

let sender = Pubkey::new_unique();
let recipient = Pubkey::new_unique();

let base_lamports = 100_000_000u64;
let transfer_amount = 42_000u64;

let instruction = system_instruction::transfer(&sender, &recipient, transfer_amount);
let accounts = [
    (
        sender,
        Account::new(base_lamports, 0, &system_program::id()),
    ),
    (
        recipient,
        Account::new(base_lamports, 0, &system_program::id()),
    ),
];
let checks = vec![
    Check::success(),
    Check::compute_units(system_processor::DEFAULT_COMPUTE_UNITS),
    Check::account(&sender)
        .lamports(base_lamports - transfer_amount)
        .build(),
    Check::account(&recipient)
        .lamports(base_lamports + transfer_amount)
        .build(),
];

Mollusk::default().process_and_validate_instruction(
    &instruction,
    &accounts,
    &checks,
);
```

Note: `Mollusk::default()` will create a new `Mollusk` instance without adding
any provided BPF programs. It will still contain a subset of the default builtin
programs. For more builtin programs, you can add them yourself or use the
`all-builtins` feature.

## Instruction Chains

Both `process_instruction_chain` and `process_and_validate_instruction_chain`
deal with chains of instructions. The former processes each instruction in the
chain and returns the final result, while the latter processes each instruction
in the chain and then performs a series of checks on each result. In both cases,
the final result is also returned.

```rust
use {
    mollusk_svm::Mollusk,
    solana_sdk::{account::Account, pubkey::Pubkey, system_instruction},
};

let mollusk = Mollusk::default();

let alice = Pubkey::new_unique();
let bob = Pubkey::new_unique();
let carol = Pubkey::new_unique();
let dave = Pubkey::new_unique();

let starting_lamports = 500_000_000;

let alice_to_bob = 100_000_000;
let bob_to_carol = 50_000_000;
let bob_to_dave = 50_000_000;

mollusk.process_instruction_chain(
    &[
        system_instruction::transfer(&alice, &bob, alice_to_bob),
        system_instruction::transfer(&bob, &carol, bob_to_carol),
        system_instruction::transfer(&bob, &dave, bob_to_dave),
    ],
    &[
        (alice, system_account_with_lamports(starting_lamports)),
        (bob, system_account_with_lamports(starting_lamports)),
        (carol, system_account_with_lamports(starting_lamports)),
        (dave, system_account_with_lamports(starting_lamports)),
    ],
);
```

Just like with `process_and_validate_instruction`, developers can use the
`Check` enum to apply checks via `process_and_validate_instruction_chain`.
Notice that `process_and_validate_instruction_chain` takes a slice of tuples,
where each tuple contains an instruction and a slice of checks. This allows the
developer to apply specific checks to each instruction in the chain. The result
returned by the method is the final result of the last instruction in the chain.

```rust
use {
    mollusk_svm::{Mollusk, result::Check},
    solana_sdk::{account::Account, pubkey::Pubkey, system_instruction},
};

let mollusk = Mollusk::default();

let alice = Pubkey::new_unique();
let bob = Pubkey::new_unique();
let carol = Pubkey::new_unique();
let dave = Pubkey::new_unique();

let starting_lamports = 500_000_000;

let alice_to_bob = 100_000_000;
let bob_to_carol = 50_000_000;
let bob_to_dave = 50_000_000;

mollusk.process_and_validate_instruction_chain(
    &[
        (
            // 0: Alice to Bob
            &system_instruction::transfer(&alice, &bob, alice_to_bob),
            &[
                Check::success(),
                Check::account(&alice)
                    .lamports(starting_lamports - alice_to_bob) // Alice pays
                    .build(),
                Check::account(&bob)
                    .lamports(starting_lamports + alice_to_bob) // Bob receives
                    .build(),
                Check::account(&carol)
                    .lamports(starting_lamports) // Unchanged
                    .build(),
                Check::account(&dave)
                    .lamports(starting_lamports) // Unchanged
                    .build(),
            ],
        ),
        (
            // 1: Bob to Carol
            &system_instruction::transfer(&bob, &carol, bob_to_carol),
            &[
                Check::success(),
                Check::account(&alice)
                    .lamports(starting_lamports - alice_to_bob) // Unchanged
                    .build(),
                Check::account(&bob)
                    .lamports(starting_lamports + alice_to_bob - bob_to_carol) // Bob pays
                    .build(),
                Check::account(&carol)
                    .lamports(starting_lamports + bob_to_carol) // Carol receives
                    .build(),
                Check::account(&dave)
                    .lamports(starting_lamports) // Unchanged
                    .build(),
            ],
        ),
        (
            // 2: Bob to Dave
            &system_instruction::transfer(&bob, &dave, bob_to_dave),
            &[
                Check::success(),
                Check::account(&alice)
                    .lamports(starting_lamports - alice_to_bob) // Unchanged
                    .build(),
                Check::account(&bob)
                    .lamports(starting_lamports + alice_to_bob - bob_to_carol - bob_to_dave) // Bob pays
                    .build(),
                Check::account(&carol)
                    .lamports(starting_lamports + bob_to_carol) // Unchanged
                    .build(),
                Check::account(&dave)
                    .lamports(starting_lamports + bob_to_dave) // Dave receives
                    .build(),
            ],
        ),
    ],
    &[
        (alice, system_account_with_lamports(starting_lamports)),
        (bob, system_account_with_lamports(starting_lamports)),
        (carol, system_account_with_lamports(starting_lamports)),
        (dave, system_account_with_lamports(starting_lamports)),
    ],
);
```

It's important to understand that instruction chains _should not_ be considered
equivalent to Solana transactions. Mollusk does not impose constraints on
instruction chains, such as loaded account keys or size. Developers should
recognize that instruction chains are primarily used for testing program
execution.

## Benchmarking Compute Units

The Mollusk Compute Unit Bencher can be used to benchmark the compute unit usage
of Solana programs. It provides a simple API for developers to write benchmarks
for their programs, which can be checked while making changes to the program.

A markdown file is generated, which captures all of the compute unit benchmarks.
If a benchmark has a previous value, the delta is also recorded. This can be
useful for developers to check the implications of changes to the program on
compute unit usage.

```rust
use {
    mollusk_svm_bencher::MolluskComputeUnitBencher,
    mollusk_svm::Mollusk,
    /* ... */
};

// Optionally disable logging.
solana_logger::setup_with("");

/* Instruction & accounts setup ... */

let mollusk = Mollusk::new(&program_id, "my_program");

MolluskComputeUnitBencher::new(mollusk)
    .bench(("bench0", &instruction0, &accounts0))
    .bench(("bench1", &instruction1, &accounts1))
    .bench(("bench2", &instruction2, &accounts2))
    .bench(("bench3", &instruction3, &accounts3))
    .must_pass(true)
    .out_dir("../target/benches")
    .execute();

```

The `must_pass` argument can be provided to trigger a panic if any defined
benchmark tests do not pass. `out_dir` specifies the directory where the
markdown file will be written.

Developers can invoke this benchmark test with `cargo bench`. They may need to
add a bench to the project's `Cargo.toml`.

```toml
[[bench]]
name = "compute_units"
harness = false
```

The markdown file will contain entries according to the defined benchmarks.

```markdown
| Name   | CUs   | Delta  |
| ------ | ----- | ------ |
| bench0 | 450   | --     |
| bench1 | 579   | -129   |
| bench2 | 1,204 | +754   |
| bench3 | 2,811 | +2,361 |
```

````

File: anchor/docs/content/docs/tokens/basics/create-mint.mdx
```mdx
---
title: Create a Token Mint
description:
  Learn how to create and initialize token mint accounts in Solana programs
  using Anchor. Covers creating mint accounts with generated keypairs or PDAs
  with code examples.
---

## What is a Mint Account?

A mint account is an account type in Solana's Token Programs that uniquely
represents a token on the network and stores global metadata about the token.

```rust
/// Mint data.
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Mint {
  /// Optional authority used to mint new tokens. The mint authority may only
  /// be provided during mint creation. If no mint authority is present
  /// then the mint has a fixed supply and no further tokens may be
  /// minted.
  pub mint_authority: COption<Pubkey>,
  /// Total supply of tokens.
  pub supply: u64,
  /// Number of base 10 digits to the right of the decimal place.
  pub decimals: u8,
  /// Is `true` if this structure has been initialized
  pub is_initialized: bool,
  /// Optional authority to freeze token accounts.
  pub freeze_authority: COption<Pubkey>,
}
````

<Callout type="info">
  Note that both the [Token
  Program](https://github.com/solana-program/token/blob/main/program/src/state.rs#L18-L32)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/main/program/src/state.rs#L30-L43)
  have the same base implementation for the Mint account.
</Callout>

Every token on Solana is represented by a mint account where the address of the
mint account acts as its unique identifier on the network.

For example, the USDC stablecoin on Solana is identified by the mint address
`EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`. This mint address serves as
USDC's unique identifier across the entire Solana ecosystem. You can view
details about this mint account on
[Solana Explorer](https://explorer.solana.com/address/3emsAVdmGKERbHjmGfQ6oZ1e35dkf5iYcS6U4CPKFVaa).

## Usage

Use the `token_interface` module from the `anchor-spl` crate to interact with
both the Token Program and Token Extension Program. This module provides types
for working with both token programs, allowing you to write code that's
compatible with either program.

```rust title="snippet"
// [!code highlight]
use anchor_spl::token_interface::{Mint, TokenInterface};

// --snip--

#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = signer.key(),
        mint::freeze_authority = signer.key(),
    )]
    // [!code word:Mint]
    // [!code highlight]
    pub mint: InterfaceAccount<'info, Mint>,
    // [!code word:TokenInterface]
    // [!code highlight]
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

### Account Types

The
[`InterfaceAccount`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts/interface_account.rs#L161-L166)
type is a wrapper that accepts accounts from either the Token Program and Token
Extension Program.

The `Mint` type represents the base Mint data structure shared by both token
programs. When an account of this type is passed in, Anchor will automatically
deserialize the account data into the mint struct, regardless of which token
program created it.

```rust title="Account Type"
pub mint: InterfaceAccount<'info, Mint>,
```

### Account Constraints

The following account constraints are used in combination to create and
initialize a new mint account:

| Constraint               | Description                                                                                                                                                                                                                                        |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `init`                   | Creates a new account by making a cross program invocation (CPI) to the System Program. This allocates the required space for the mint account and transfers ownership to the appropriate token program.                                           |
| `payer`                  | Specifies which account will pay the rent (SOL deposit) required to create the new account.                                                                                                                                                        |
| `mint::decimals`         | Sets the number of decimal places for the token. For example, setting this to 6 means 1 token = 1,000,000 base units.                                                                                                                              |
| `mint::authority`        | Sets the mint authority - the account that has permission to mint new tokens. (Required)                                                                                                                                                           |
| `mint::freeze_authority` | Sets the freeze authority - the account that has permission to freeze token accounts. (Optional) Freezing a token account prevents the token program from processing instructions that include the frozen token account (ex. transfer, burn, etc.) |

```rust title="Account Constraints"
#[account(
    init,
    payer = <payer>,
    mint::decimals = <decimals>,
    mint::authority = <authority>,
    mint::freeze_authority = <freeze_authority>,
)]
pub mint: InterfaceAccount<'info, Mint>,
```

Alternatively, you can add the `seeds` and `bump` constraints to create a mint
account where the address of the account is a Program Derived Address (PDA). The
benefit of using a PDA is that the mint address can be derived from the same
seeds at any time.

```rust title="Account Constraints"
#[account(
    init,
    payer = <payer>,
    mint::decimals = <decimals>,
    mint::authority = <authority>,
    mint::freeze_authority = <freeze_authority>,
    seeds = [<seeds>],
    bump
)]
pub mint: InterfaceAccount<'info, Mint>,
```

<Callout type="info">
  Note that you can use the same PDA as both the `mint::authority` and the mint
  account address. Using a PDA as the `mint::authority` enables your program to
  "sign" CPI instructions to mint new units of the token. This pattern allows
  for a single deterministic address for both purposes.
</Callout>

## Examples

The following examples demonstrate how to create a mint account in an Anchor
program using two different approaches:

1. Using a generated Keypair - This is an approach where you generate a new
   keypair to use as the mint address. This is useful when you don't need
   deterministic mint addresses.

2. Using a Program Derived Address (PDA) - This approach creates the mint where
   the account address is a PDA derived from seeds. This allows for
   deterministic mint addresses and is useful when you need to find the mint
   address at a later time.

Both approaches are can be done entirely using account constraints.

### Create Mint using Keypair

Create a new mint account in using a generated Keypair.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::token_interface::{Mint, TokenInterface};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn create_mint(ctx: Context<CreateMint>) -> Result<()> {
        msg!("Created Mint Account: {:?}", ctx.accounts.mint.key());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        // [!code highlight:5]
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = signer.key(),
        mint::freeze_authority = signer.key(),
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

</Tab>

<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TokenExample } from "../target/types/token_example";
import { TOKEN_2022_PROGRAM_ID, getMint } from "@solana/spl-token";

describe("token-example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.TokenExample as Program<TokenExample>;
  const mint = anchor.web3.Keypair.generate();

  it("Is initialized!", async () => {
    const tx = await program.methods
      .createMint()
      .accounts({
        mint: mint.publicKey,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .signers([mint])
      .rpc({ commitment: "confirmed" });
    console.log("Your transaction signature", tx);

    const mintAccount = await getMint(
      program.provider.connection,
      mint.publicKey,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Mint Account", mintAccount);
  });
});
```

</Tab>
</Tabs>

### Create Mint using PDA

Create a new mint account using a Program Derived Address (PDA) as the address
of the mint account.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::token_interface::{Mint, TokenInterface};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn create_mint(ctx: Context<CreateMint>) -> Result<()> {
        msg!("Created Mint Account: {:?}", ctx.accounts.mint.key());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        // [!code word:seeds]
        // [!code word:bump]
        // [!code highlight:7]
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = mint.key(),
        mint::freeze_authority = mint.key(),
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TokenExample } from "../target/types/token_example";
import { TOKEN_2022_PROGRAM_ID, getMint } from "@solana/spl-token";

describe("token-example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.TokenExample as Program<TokenExample>;
  const [mint, bump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("mint")],
    program.programId
  );

  it("Is initialized!", async () => {
    const tx = await program.methods
      .createMint()
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });
    console.log("Your transaction signature", tx);

    const mintAccount = await getMint(
      program.provider.connection,
      mint,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Mint Account", mintAccount);
  });
});
```

</Tab>
</Tabs>

````

File: anchor/docs/content/docs/tokens/basics/index.mdx
```mdx
---
title: SPL Token Basics
description:
  Learn how to integrate SPL Tokens into your Solana programs using the Anchor
  framework.
index: true
---

This section covers the basics for interacting with SPL Tokens in Anchor
programs, focusing on the most commonly used instructions.

All examples in this section work identically with both the original Token
Program and the Token Extension Program (Token 2022), as they share the same
base implementation.

Below are the most common instructions you'll see when interacting with SPL
Tokens:

````

File: anchor/docs/content/docs/tokens/basics/create-token-account.mdx

````mdx
---
title: Create a Token Account
description:
  Learn how to create and initialize token accounts in Solana programs using
  Anchor. Covers creating Associated Token Accounts (ATAs) and Program Derived
  Address (PDA) token accounts with code examples.
---

## What is a Token Account?

A token account is an account type in Solana's Token Programs that stores
information about an individual's ownership of a specific token (mint). Each
token account is associated with a single mint and tracks details like the token
balance and owner.

```rust
/// Account data.
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Account {
    /// The mint associated with this account
    pub mint: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of tokens this account holds.
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate
    pub delegate: COption<Pubkey>,
    /// The account's state
    pub state: AccountState,
    /// If `is_native.is_some`, this is a native token, and the value logs the
    /// rent-exempt reserve. An Account is required to be rent-exempt, so
    /// the value is used by the Processor to ensure that wrapped SOL
    /// accounts do not drop below this threshold.
    pub is_native: COption<u64>,
    /// The amount delegated
    pub delegated_amount: u64,
    /// Optional authority to close the account.
    pub close_authority: COption<Pubkey>,
}
```
````

<Callout type="info">
  Note that in the source code, a Token account is referred to as an `Account`
  type. Both the [Token
  Program](https://github.com/solana-program/token/blob/main/program/src/state.rs#L89-L110)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/main/program/src/state.rs#L104-L124)
  have the same base implementation for the Token account.
</Callout>

To hold tokens for a specific mint, users must first create a token account.
Each token account is associated with:

1. A specific mint (the token type the token account holds units of)
2. An owner (the authority who can transfer tokens from the account)

Let's look at an example using USDC on Solana:

- The USDC mint address is `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`
- Circle (the USDC issuer) has a token account at
  `3emsAVdmGKERbHjmGfQ6oZ1e35dkf5iYcS6U4CPKFVaa`
- This token account can only hold units of the USDC token (mint)
- Circle is set as the owner at `7VHUFJHWu2CuExkJcJrzhQPJ2oygupTWkL2A2For4BmE`
  and can transfer these tokens

You can view the details of this token account on
[Solana Explorer](https://explorer.solana.com/address/3emsAVdmGKERbHjmGfQ6oZ1e35dkf5iYcS6U4CPKFVaa).

<Callout type="info">
  The term "owner" is used in two different contexts:

1. The token account "owner" - This is an address stored in the token account's
   as the "owner" field of the `Account` type defined by the Token Program. The
   owner can transfer, burn, or delegate tokens from the account. This address
   is sometimes referred to as the "authority" of the token account to
   distinguish it from the program owner.

2. The program "owner" - This refers to the program that owns the account data
   on Solana. For token accounts, this is always either the Token Program or
   Token Extension Program, as specified in the "owner" field of the base Solana
   [Account](https://github.com/anza-xyz/agave/blob/master/sdk/account/src/lib.rs#L44-L56)
   type.

When working with token accounts, "owner" typically refers to the authority that
can spend the tokens, not the program that owns the account.

</Callout>

## What is an Associated Token Account?

An associated token account (ATA) is simply a token account with an address that
is a PDA derived from and created by the
[Associated Token Program](https://github.com/solana-program/associated-token-account/tree/main/program).
You can think of an ATA as the default token account for a user to hold units of
a specific token (mint).

<Callout type="info">
  Only token accounts created through the Associated Token Program are referred
  to as associated token accounts.
</Callout>

ATAs provide a deterministic way to find a user's token account for any given
mint. You can inspect the implementation of the derivation
[here](https://github.com/solana-program/associated-token-account/blob/main/interface/src/address.rs#L56-L70).

```rust title="Associated Token Account Address Derivation"
pub fn get_associated_token_address_and_bump_seed_internal(
    wallet_address: &Pubkey,
    token_mint_address: &Pubkey,
    program_id: &Pubkey,
    token_program_id: &Pubkey,
) -> (Pubkey, u8) {
    Pubkey::find_program_address(
        &[
            &wallet_address.to_bytes(), // Owner's public key
            &token_program_id.to_bytes(), // Token Program or Token Extension Program
            &token_mint_address.to_bytes(), // Token mint address
        ],
        program_id, // Associated Token Program ID
    )
}
```

This deterministic derivation ensures that for any combination of wallet address
and token mint, there exists exactly one associated token account address. This
approach makes it simple to find a user's token account for any given token
mint, eliminating the need to track token account addresses separately.

<Callout type="info">
  The Associated Token Program acts as a helper program that creates token
  accounts with deterministic addresses (PDAs). When creating an associated
  token account, the Associated Token Program makes a CPI (Cross-Program
  Invocation) to either the Token Program or Token Extension Program. The
  created account is owned by the token program and has the same `Account` type
  structure as defined in the token program. The Associated Token Program itself
  maintains no state - it simply provides a standardized way to create token
  accounts at a deterministic address.
</Callout>

## Usage

Use the `token_interface` and `associated_token` modules from the `anchor-spl`
crate to work with ATAs compatible with either the Token Program and Token
Extension Program.

```rust title="snippet"
// [!code highlight:2]
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};

// --snip--

#[derive(Accounts)]
pub struct CreateTokenAccount<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init_if_needed,
        payer = signer,
        associated_token::mint = mint,
        associated_token::authority = signer,
        associated_token::token_program = token_program,
    )]
    // [!code highlight:4]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```

To create token accounts with PDAs derived from your program, you can use the
`token::mint`, `token::authority`, and `token::token_program` constraints along
with the `seeds` and `bump` constraints.

```rust title="snippet"
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};

// --snip--

#[derive(Accounts)]
pub struct CreateTokenAccount<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        // [!code word:seeds]
        // [!code word:bump]
        // [!code highlight:7]
        init_if_needed,
        payer = signer,
        token::mint = mint,
        token::authority = token_account,
        token::token_program = token_program,
        seeds = [b"token"],
        bump
    )]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

### Account Types

The
[`InterfaceAccount`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/lang/src/accounts/interface_account.rs#L161-L166)
type is a wrapper that allows the account to work with both the Token Program
and Token Extension Program.

The `TokenAccount` type represents the base `Account` data structure shared by
both token programs. When an account of this type is passed in, Anchor will
automatically deserialize the account data into the `Account` struct, regardless
of which token program created it.

```rust title="Account Type"
pub token_account: InterfaceAccount<'info, TokenAccount>,
```

### Account Constraints

Anchor provides two sets of constraints for working with token accounts:

- Use `associated_token` constraints when working with Associated Token Accounts
  (ATAs)
- Use `token` constraints when working with token accounts that are not
  specifically ATAs, such as custom PDAs or token accounts with addresses that
  are public keys from a keypair

The appropriate constraint to use depends on your specific use case. ATAs are
recommended for user wallets, while custom token accounts are useful for program
controlled accounts.

#### `associated_token` constraints

The following account constraints are used in combination to create and
initialize a new associated token account:

| Constraint                        | Description                                                                                                                                                                                               |
| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `init`                            | Creates a new account by making a cross program invocation (CPI) to the System Program. This allocates the required space for the token account and transfers ownership to the appropriate token program. |
| `init_if_needed`                  | Similar to `init`, but only creates the account if it doesn't already exist. Requires enabling the `init-if-needed` feature.                                                                              |
| `payer`                           | Specifies which account will pay the rent (SOL deposit) required to create the new account.                                                                                                               |
| `associated_token::mint`          | Specifies the mint account that this token account will be associated with.                                                                                                                               |
| `associated_token::authority`     | Sets the authority (owner) of the token account who has permission to transfer or burn tokens.                                                                                                            |
| `associated_token::token_program` | Specifies which token program (Token Program or Token Extension Program) to use when creating the token account.                                                                                          |

```rust title="Create Associated Token Account"
#[account(
    init,
    payer = <payer>,
    associated_token::mint = <mint>,
    associated_token::authority = <authority>,
    associated_token::token_program = <token_program>
)]
pub token_account: InterfaceAccount<'info, TokenAccount>,
```

#### `token` constraints

The following account constraints are used in combination to create and
initialize a new token account:

| Constraint             | Description                                                                                                                                                                                               |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `init`                 | Creates a new account by making a cross program invocation (CPI) to the System Program. This allocates the required space for the token account and transfers ownership to the appropriate token program. |
| `init_if_needed`       | Similar to `init`, but only creates the account if it doesn't already exist. Requires enabling the `init-if-needed` feature.                                                                              |
| `payer`                | Specifies which account will pay the rent (SOL deposit) required to create the new account.                                                                                                               |
| `token::mint`          | Specifies the mint account that this token account will be associated with.                                                                                                                               |
| `token::authority`     | Sets the authority (owner) of the token account who has permission to transfer or burn tokens.                                                                                                            |
| `token::token_program` | Specifies which token program (Token Program or Token Extension Program) to use when creating the token account.                                                                                          |

```rust title="Create Token Account with Keypair Public Key as Address"
#[account(
    init,
    payer = <payer>,
    token::mint = <mint>,
    token::authority = <authority>,
    token::token_program = <token_program>
)]
pub token_account: InterfaceAccount<'info, TokenAccount>,
```

```rust title="Create Token Account with PDA as Address"
#[account(
    init,
    payer = <payer>,
    token::mint = <mint>,
    token::authority = <authority>,
    token::token_program = <token_program>,
    seeds = [<seeds>],
    bump
)]
pub token_account: InterfaceAccount<'info, TokenAccount>,
```

<Callout type="info">
  Note that you can use the same PDA as both the `token::authority` and the
  token account address. Using a PDA as the `token::authority` enables your
  program to "sign" CPI instructions to transfer tokens from the token account.
  This pattern allows for a single deterministic address for both purposes.
</Callout>

To use the `init_if_needed` constraint, enable the `init-if-needed` feature in
`Cargo.toml` and replace the `init` constraint with `init_if_needed`.

```toml title="Cargo.toml"
[dependencies]
anchor-lang = { version = "0.31.0", features = ["init-if-needed"] }
```

## Examples

The following examples demonstrate how to create a token account in an Anchor
program using two different approaches:

1. Using an Associated Token Account (ATA) - This is the standard approach to
   create a token account for a specific user to hold units of a specific token
   (mint).

2. Using a Program Derived Address (PDA) - This approach creates a token account
   where the address is a custom PDA. This allows for deterministic token
   account addresses specific to your program. You can also set the authority
   (owner) as a PDA to enable your program to transfer tokens from the token
   account.

Both approaches are can be done entirely using account constraints.

### Create Associated Token Account

Create an associated token account for a user.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn create_mint(ctx: Context<CreateMint>) -> Result<()> {
        msg!("Created Mint Account: {:?}", ctx.accounts.mint.key());
        Ok(())
    }

    pub fn create_token_account(ctx: Context<CreateTokenAccount>) -> Result<()> {
        msg!(
            "Created Token Account: {:?}",
            ctx.accounts.token_account.key()
        );
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = mint.key(),
        mint::freeze_authority = mint.key(),
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateTokenAccount<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        // [!code highlight:5]
        init_if_needed,
        payer = signer,
        associated_token::mint = mint,
        associated_token::authority = signer,
        associated_token::token_program = token_program,
    )]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TokenExample } from "../target/types/token_example";
import {
  TOKEN_2022_PROGRAM_ID,
  getAssociatedTokenAddress,
  getMint,
  getAccount,
} from "@solana/spl-token";

describe("token-example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.TokenExample as Program<TokenExample>;
  const [mint, bump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("mint")],
    program.programId
  );

  it("Is initialized!", async () => {
    const tx = await program.methods
      .createMint()
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });
    console.log("Your transaction signature", tx);

    const mintAccount = await getMint(
      program.provider.connection,
      mint,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Mint Account", mintAccount);
  });

  it("Create token account", async () => {
    const tx = await program.methods
      .createTokenAccount()
      .accounts({
        mint: mint,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });

    console.log("Your transaction signature", tx);

    const associatedTokenAccount = await getAssociatedTokenAddress(
      mint,
      program.provider.publicKey,
      false,
      TOKEN_2022_PROGRAM_ID
    );

    const tokenAccount = await getAccount(
      program.provider.connection,
      associatedTokenAccount,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Token Account", tokenAccount);
  });
});
```

</Tab>
</Tabs>

### Create Token Account using PDA

Create a token account using a Program Derived Address (PDA) as the address of
the token account.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn create_mint(ctx: Context<CreateMint>) -> Result<()> {
        msg!("Created Mint Account: {:?}", ctx.accounts.mint.key());
        Ok(())
    }

    pub fn create_token_account(ctx: Context<CreateTokenAccount>) -> Result<()> {
        msg!(
            "Created Token Account: {:?}",
            ctx.accounts.token_account.key()
        );
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = mint.key(),
        mint::freeze_authority = mint.key(),
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateTokenAccount<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        // [!code highlight:7]
        init_if_needed,
        payer = signer,
        token::mint = mint,
        token::authority = token_account,
        token::token_program = token_program,
        seeds = [b"token"],
        bump
    )]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TokenExample } from "../target/types/token_example";
import {
  TOKEN_2022_PROGRAM_ID,
  getAssociatedTokenAddress,
  getMint,
  getAccount,
} from "@solana/spl-token";

describe("token-example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.TokenExample as Program<TokenExample>;
  const [mint, mintBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("mint")],
    program.programId
  );

  const [token, tokenBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("token")],
    program.programId
  );

  it("Is initialized!", async () => {
    const tx = await program.methods
      .createMint()
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });
    console.log("Your transaction signature", tx);

    const mintAccount = await getMint(
      program.provider.connection,
      mint,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Mint Account", mintAccount);
  });

  it("Create token account", async () => {
    const tx = await program.methods
      .createTokenAccount()
      .accounts({
        mint: mint,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });

    console.log("Your transaction signature", tx);

    const tokenAccount = await getAccount(
      program.provider.connection,
      token,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Token Account", tokenAccount);
  });
});
```

</Tab>
</Tabs>

````

File: anchor/docs/content/docs/tokens/basics/meta.json
```json
{
  "title": "Basics",
  "pages": [
    "create-mint",
    "create-token-account",
    "mint-tokens",
    "transfer-tokens"
  ]
}

````

File: anchor/docs/content/docs/tokens/basics/mint-tokens.mdx

````mdx
---
title: Mint Tokens
description:
  Learn how to mint tokens in Solana programs using Anchor. Covers creating new
  tokens via cross program invocations (CPI) to the Token Program with code
  examples.
---

## How to Mint Tokens

Minting tokens refers to the process of creating new units of a token by
invoking the
[`mint_to`](https://github.com/solana-program/token/blob/main/program/src/instruction.rs#L1087-L1114)
instruction on a token program. Only the address specified as the mint authority
on the mint account can mint new tokens. The instruction also requires the
existence of a token account for the mint as the destination of the minted
tokens.

<Callout type="info">
  The [Token
  Program](https://github.com/solana-program/token/blob/main/program/src/processor.rs#L523-L585)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/main/program/src/processor.rs#L962-L1048)
  share similar implementations to achieve the same functionality.
</Callout>

## Examples

To mint tokens through an Anchor program, you need to make a cross program
invocation (CPI) to the `mint_to` instruction on either the Token Program or
Token Extension Program.

This means you are invoking the `mint_to` instruction on the Token Program or
Token Extension Program from an instruction in your program. Your program acts
as an intermediary, passing along the required accounts, instruction data, and
signatures to the token program.

### Mint Tokens via CPI

Use the `token_interface::mint_to` function make a CPI to either the Token
Program or Token Extension Program. This function requires:

1. The `MintTo` struct which specifies the required accounts:

   - `mint` - The mint account to create new units of tokens for
   - `to` - The destination token account to receive the minted tokens
   - `authority` - The mint authority with permission to mint tokens

2. The `amount` of tokens to mint, in base units of the token adjusted by
   decimals. (e.g. if the mint has 2 decimals, amount of 100 = 1 token)

The mint authority passed to the `mint_to` instruction must match the
`mint_authority` stored on the mint account. Additionally, the mint authority
must be a signer on the transaction. For example:

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::{
    token_interface::{self, Mint, MintTo, TokenAccount, TokenInterface},
};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {
        let cpi_accounts = MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.token_account.to_account_info(),
            authority: ctx.accounts.signer.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
        token_interface::mint_to(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct MintTokens<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(mut)]
    pub mint: InterfaceAccount<'info, Mint>,
    #[account(mut)]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}
```
````

At minimum, the following accounts are required:

```rust title="snippet"
#[derive(Accounts)]
pub struct MintTokens<'info> {
    // The mint authority
    #[account(mut)]
    pub signer: Signer<'info>,
    // The mint account
    #[account(mut)]
    pub mint: InterfaceAccount<'info, Mint>,
    // The destination token account
    #[account(mut)]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    // The token program
    pub token_program: Interface<'info, TokenInterface>,
}
```

Within the instruction logic, use the:

- `MintTo` struct to specify the required accounts
- `token_interface::mint_to` function to make the CPI

```rust title="snippet"
pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {
    // Create the MintTo struct with the accounts required for the CPI
    let cpi_accounts = MintTo {
        mint: ctx.accounts.mint.to_account_info(),
        to: ctx.accounts.token_account.to_account_info(),
        authority: ctx.accounts.signer.to_account_info(),
    };

    // The program being invoked in the CPI
    let cpi_program = ctx.accounts.token_program.to_account_info();

    // Combine the accounts and program into a "CpiContext"
    let cpi_context = CpiContext::new(cpi_program, cpi_accounts);

    // Make CPI to mint_to instruction on the token program
    token_interface::mint_to(cpi_context, amount)?;
    Ok(())
}
```

### Mint Tokens with PDA mint authority via CPI

You can create a mint account with a Program Derived Address (PDA) as the mint
authority. This allows your program to programmatically mint tokens by "signing"
with the PDA's seeds in the Cross Program Invocation (CPI). This pattern is
useful when you want the program itself, rather than an external wallet, to
control token minting.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token_interface::{self, Mint, MintTo, TokenAccount, TokenInterface},
};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn create_mint(ctx: Context<CreateMint>) -> Result<()> {
        msg!("Created Mint Account: {:?}", ctx.accounts.mint.key());
        Ok(())
    }

    pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {
        let signer_seeds: &[&[&[u8]]] = &[&[b"mint", &[ctx.bumps.mint]]];

        let cpi_accounts = MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.token_account.to_account_info(),
            authority: ctx.accounts.mint.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts).with_signer(signer_seeds);
        // [!code highlight]
        token_interface::mint_to(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = mint,
        mint::freeze_authority = mint,
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct MintTokens<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init_if_needed,
        payer = signer,
        associated_token::mint = mint,
        associated_token::authority = signer,
        associated_token::token_program = token_program,
    )]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(
        mut,
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TokenExample } from "../target/types/token_example";
import {
  TOKEN_2022_PROGRAM_ID,
  getAssociatedTokenAddress,
  getMint,
  getAccount,
} from "@solana/spl-token";

describe("token-example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.TokenExample as Program<TokenExample>;
  const [mint, mintBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("mint")],
    program.programId
  );

  const [token, tokenBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("token")],
    program.programId
  );

  it("Is initialized!", async () => {
    const tx = await program.methods
      .createMint()
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });
    console.log("Your transaction signature", tx);

    const mintAccount = await getMint(
      program.provider.connection,
      mint,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Mint Account", mintAccount);
  });

  it("Mint Tokens", async () => {
    const tx = await program.methods
      .mintTokens(new anchor.BN(100))
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });

    console.log("Your transaction signature", tx);

    const associatedTokenAccount = await getAssociatedTokenAddress(
      mint,
      program.provider.publicKey,
      false,
      TOKEN_2022_PROGRAM_ID
    );

    const tokenAccount = await getAccount(
      program.provider.connection,
      associatedTokenAccount,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Token Account", tokenAccount);
  });
});
```

</Tab>
</Tabs>

In this example, mint authority is set to a Program Derived Address (PDA). The
PDA is derived using the seed `b"mint"`. This means the program itself controls
minting through this PDA.

```rust title="snippet"
#[derive(Accounts)]
pub struct CreateMint<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        // [!code word: mint,]
        // [!code highlight]
        mint::authority = mint,
        mint::freeze_authority = mint,
        seeds = [b"mint"],
        bump
    )]
    // [!code word:mint]
    pub mint: InterfaceAccount<'info, Mint>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

To mint tokens, the program must "sign" with the PDA by including the seeds and
bump in the CPI context. This is done by passing the seeds and bump to the
`with_signer` method when creating the CPI context.

```rust title="snippet"
pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {
    // [!code word:signer_seeds]
    // [!code highlight]
    let signer_seeds: &[&[&[u8]]] = &[&[b"mint", &[ctx.bumps.mint]]];

    let cpi_accounts = MintTo {
        mint: ctx.accounts.mint.to_account_info(),
        to: ctx.accounts.token_account.to_account_info(),
        authority: ctx.accounts.mint.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    // [!code highlight:2]
    let cpi_context = CpiContext::new(cpi_program, cpi_accounts).with_signer(signer_seeds);
    token_interface::mint_to(cpi_context, amount)?;
    Ok(())
}
```

<Callout type="info">
  Note in this example the same PDA is used as both the address of the mint
  account and the mint authority.
</Callout>

````

File: anchor/docs/content/docs/tokens/basics/transfer-tokens.mdx
```mdx
---
title: Transfer Tokens
description:
  Learn how to transfer tokens between token accounts through cross program
  invocations (CPIs) in Anchor.
---

## How to Transfer Tokens

Transferring tokens involves moving tokens from one token account to another
token account that share the same mint. This is done by invoking the
[`transfer_checked`](https://github.com/solana-program/token/blob/main/program/src/instruction.rs#L1235-L1265)
instruction on a token program. Only the address specified as the owner
(authority) of the source token account can transfer tokens out of the account.

<Callout type="info">
  The [Token
  Program](https://github.com/solana-program/token/blob/main/program/src/processor.rs#L229-L343)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/main/program/src/processor.rs#L290-L561)
  share similar implementations to achieve the same functionality.
</Callout>

## Examples

To transfer tokens through an Anchor program, you need to make a cross program
invocation (CPI) to the `transfer_checked` instruction on either the Token
Program or Token Extension Program.

This means you are invoking the `transfer_checked` instruction on the Token
Program or Token Extension Program from an instruction in your program. Your
program acts as an intermediary, passing along the required accounts,
instruction data, and signatures to the token program.

### Transfer Tokens via CPI

Use the `token_interface::transfer_checked` function make a CPI to either the
Token Program or Token Extension Program. This function requires:

1. The `TransferChecked` struct which specifies the required accounts:

   - `mint` - The mint account specifying the type of token to transfer
   - `from` - The source token account to transfer tokens from
   - `to` - The destination token account to receive the transferred tokens
   - `authority` - The owner of the source token account

2. The `amount` of tokens to transfer, in base units of the token adjusted by
   decimals. (e.g. if the mint has 2 decimals, amount of 100 = 1 token)

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::token_interface::{self, TokenAccount, TokenInterface, TransferChecked};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
        let decimals = ctx.accounts.mint.decimals;

        let cpi_accounts = TransferChecked {
            mint: ctx.accounts.mint.to_account_info(),
            from: ctx.accounts.sender_token_account.to_account_info(),
            to: ctx.accounts.recipient_token_account.to_account_info(),
            authority: ctx.accounts.signer.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
        // [!code highlight]
        token_interface::transfer_checked(cpi_context, amount, decimals)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(mut)]
    pub mint: InterfaceAccount<'info, Mint>,
    #[account(mut)]
    pub sender_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}
````

At minimum, the following accounts are required:

```rust title="snippet"
#[derive(Accounts)]
pub struct TransferTokens<'info> {
    // The source token account owner
    #[account(mut)]
    pub signer: Signer<'info>,
    // The mint account specifying the type of token
    #[account(mut)]
    pub mint: InterfaceAccount<'info, Mint>,
    // The source token account to transfer tokens from
    #[account(mut)]
    pub sender_token_account: InterfaceAccount<'info, TokenAccount>,
    // The destination token account to receive tokens
    #[account(mut)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    // The token program that will process the transfer
    pub token_program: Interface<'info, TokenInterface>,
}
```

Within the instruction logic, use the:

- `TransferChecked` struct to specify the required accounts
- `token_interface::transfer_checked` function to make the CPI

```rust title="snippet"
pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
    // Get the number of decimals for this mint
    let decimals = ctx.accounts.mint.decimals;

    // Create the TransferChecked struct with required accounts
    let cpi_accounts = TransferChecked {
        mint: ctx.accounts.mint.to_account_info(),
        from: ctx.accounts.sender_token_account.to_account_info(),
        to: ctx.accounts.recipient_token_account.to_account_info(),
        authority: ctx.accounts.signer.to_account_info(),
    };

    // The program being invoked in the CPI
    let cpi_program = ctx.accounts.token_program.to_account_info();

     // Combine the accounts and program into a "CpiContext"
    let cpi_context = CpiContext::new(cpi_program, cpi_accounts);

    // Make CPI to transfer_checked instruction on token program
    token_interface::transfer_checked(cpi_context, amount, decimals)?;
    Ok(())
}
```

### Transfer Tokens with PDA token owner via CPI

You can create a token account with a PDA as the owner. This allows your program
to transfer tokens from a program controlled token account by "signing" with the
PDA's seeds in the Cross Program Invocation (CPI). This pattern is useful when
you want the program itself to control token transfers based on conditions
defined within the program.

<Tabs items={["Program", "Client"]}>
<Tab value="Program">

```rust title="lib.rs"
use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token_interface::{self, Mint, MintTo, TokenAccount, TokenInterface, TransferChecked},
};

declare_id!("3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d");

#[program]
pub mod token_example {
    use super::*;

    pub fn create_and_mint_tokens(ctx: Context<CreateAndMintTokens>, amount: u64) -> Result<()> {
        let signer_seeds: &[&[&[u8]]] = &[&[b"mint", &[ctx.bumps.mint]]];

        let cpi_accounts = MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.token_account.to_account_info(),
            authority: ctx.accounts.mint.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts).with_signer(signer_seeds);
        token_interface::mint_to(cpi_context, amount)?;
        Ok(())
    }

    pub fn transfer_tokens(ctx: Context<TransferTokens>) -> Result<()> {
        let signer_seeds: &[&[&[u8]]] = &[&[b"token", &[ctx.bumps.sender_token_account]]];

        let amount = ctx.accounts.sender_token_account.amount;
        let decimals = ctx.accounts.mint.decimals;

        let cpi_accounts = TransferChecked {
            mint: ctx.accounts.mint.to_account_info(),
            from: ctx.accounts.sender_token_account.to_account_info(),
            to: ctx.accounts.recipient_token_account.to_account_info(),
            authority: ctx.accounts.sender_token_account.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts).with_signer(signer_seeds);
        token_interface::transfer_checked(cpi_context, amount, decimals)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateAndMintTokens<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = mint,
        mint::freeze_authority = mint,
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    #[account(
        init,
        payer = signer,
        token::mint = mint,
        token::authority = token_account,
        seeds = [b"token"],
        bump
    )]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        mut,
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    #[account(
        mut,
        token::mint = mint,
        token::authority = sender_token_account,
        seeds = [b"token"],
        bump
    )]
    pub sender_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(
        init_if_needed,
        payer = signer,
        associated_token::mint = mint,
        associated_token::authority = signer,
        associated_token::token_program = token_program,
    )]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```

</Tab>
<Tab value="Client">

```ts title="test.ts"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { TokenExample } from "../target/types/token_example";
import {
  TOKEN_2022_PROGRAM_ID,
  getAssociatedTokenAddress,
  getMint,
  getAccount,
} from "@solana/spl-token";

describe("token-example", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.TokenExample as Program<TokenExample>;
  const [mint, mintBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("mint")],
    program.programId
  );

  const [token, tokenBump] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("token")],
    program.programId
  );

  it("Is initialized!", async () => {
    const tx = await program.methods
      .createAndMintTokens(new anchor.BN(100))
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });
    console.log("Your transaction signature", tx);

    const mintAccount = await getMint(
      program.provider.connection,
      mint,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Mint Account", mintAccount);
  });

  it("Mint Tokens", async () => {
    const tx = await program.methods
      .transferTokens()
      .accounts({
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .rpc({ commitment: "confirmed" });

    console.log("Your transaction signature", tx);

    const associatedTokenAccount = await getAssociatedTokenAddress(
      mint,
      program.provider.publicKey,
      false,
      TOKEN_2022_PROGRAM_ID
    );

    const recipientTokenAccount = await getAccount(
      program.provider.connection,
      associatedTokenAccount,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    const senderTokenAccount = await getAccount(
      program.provider.connection,
      token,
      "confirmed",
      TOKEN_2022_PROGRAM_ID
    );

    console.log("Recipient Token Account", recipientTokenAccount);
    console.log("Sender Token Account", senderTokenAccount);
  });
});
```

</Tab>
</Tabs>

In this example, the source token account owner is set to a Program Derived
Address (PDA). The PDA is derived using the seed `b"token"`. This means the
program itself controls token transfers out of the token account through this
PDA.

```rust title="snippet"
#[derive(Accounts)]
pub struct CreateAndMintTokens<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        mint::decimals = 6,
        mint::authority = mint,
        mint::freeze_authority = mint,
        seeds = [b"mint"],
        bump
    )]
    pub mint: InterfaceAccount<'info, Mint>,
    #[account(
        init,
        payer = signer,
        token::mint = mint,
        // [!code word:token_account]
        // [!code highlight]
        token::authority = token_account,
        seeds = [b"token"],
        bump
    )]
    pub token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

To transfer tokens, the program must "sign" with the PDA by including the seeds
and bump in the CPI context. This is done by passing the seeds and bump to the
`with_signer` method when creating the CPI context.

```rust title="snippet"
pub fn transfer_tokens(ctx: Context<TransferTokens>) -> Result<()> {
    // [!code word:signer_seeds]
    // [!code highlight]
    let signer_seeds: &[&[&[u8]]] = &[&[b"token", &[ctx.bumps.sender_token_account]]];

    let amount = ctx.accounts.sender_token_account.amount;
    let decimals = ctx.accounts.mint.decimals;

    let cpi_accounts = TransferChecked {
        mint: ctx.accounts.mint.to_account_info(),
        from: ctx.accounts.sender_token_account.to_account_info(),
        to: ctx.accounts.recipient_token_account.to_account_info(),
        authority: ctx.accounts.sender_token_account.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    // [!code highlight:2]
    let cpi_context = CpiContext::new(cpi_program, cpi_accounts).with_signer(signer_seeds);
    token_interface::transfer_checked(cpi_context, amount, decimals)?;
    Ok(())
}
```

<Callout type="info">
  Note in this example the same PDA is used as both the address of the source
  token account and the source token account owner.
</Callout>

````

File: anchor/docs/content/docs/tokens/extensions.mdx
```mdx
---
title: Extensions
description:
  Learn how to enable token extensions to add optional features to token mints
  and accounts using the Token Extensions Program (Token 2022) in an Anchor
  program.
---

## What are Token Extensions?

The Token Extensions Program (Token 2022) provides additional features through
additional instructions referred to as extensions. Extensions are optional
functionality that can be added to a token mint or token account.You can find
the implementation of these extension instructions in the Token Extensions
Program
[source code](https://github.com/solana-program/token-2022/tree/main/program/src/extension).

Each extension adds specific state that must be initialized during mint or token
account creation. When initializing either type of account, you can enable
multiple extensions simultaneously to add different functionality. However,
extensions cannot be added after an account is created - you must include all
desired extensions during the initial account creation. This is an important
consideration when designing your token, as you'll need to plan ahead for which
features you want your token to support.

<Callout type="info">
  Some extensions are incompatible with each other and cannot be enabled
  simultaneously on the same token mint or token account. For example, you
  cannot combine the NonTransferable extension with the TransferFeeConfig
  extension, since they have conflicting behaviors.
</Callout>

The Token Extensions Program defines an
[`ExtensionType`](https://github.com/solana-program/token-2022/blob/main/program/src/extension/mod.rs#L1054-L1139)
enum that specifies all available extensions that can be added to a token mint
or token account. Each variant represents a different extension with unique
functionality.

The `ExtensionType` enum is defined as follows:

```rust title="Token Extensions"
/// Extensions that can be applied to mints or accounts.  Mint extensions must
/// only be applied to mint accounts, and account extensions must only be
/// applied to token holding accounts.
#[repr(u16)]
#[cfg_attr(feature = "serde-traits", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde-traits", serde(rename_all = "camelCase"))]
#[derive(Clone, Copy, Debug, PartialEq, TryFromPrimitive, IntoPrimitive)]
pub enum ExtensionType {
    /// Used as padding if the account size would otherwise be 355, same as a
    /// multisig
    Uninitialized,
    /// Includes transfer fee rate info and accompanying authorities to withdraw
    /// and set the fee
    TransferFeeConfig,
    /// Includes withheld transfer fees
    TransferFeeAmount,
    /// Includes an optional mint close authority
    MintCloseAuthority,
    /// Auditor configuration for confidential transfers
    ConfidentialTransferMint,
    /// State for confidential transfers
    ConfidentialTransferAccount,
    /// Specifies the default Account::state for new Accounts
    DefaultAccountState,
    /// Indicates that the Account owner authority cannot be changed
    ImmutableOwner,
    /// Require inbound transfers to have memo
    MemoTransfer,
    /// Indicates that the tokens from this mint can't be transferred
    NonTransferable,
    /// Tokens accrue interest over time,
    InterestBearingConfig,
    /// Locks privileged token operations from happening via CPI
    CpiGuard,
    /// Includes an optional permanent delegate
    PermanentDelegate,
    /// Indicates that the tokens in this account belong to a non-transferable
    /// mint
    NonTransferableAccount,
    /// Mint requires a CPI to a program implementing the "transfer hook"
    /// interface
    TransferHook,
    /// Indicates that the tokens in this account belong to a mint with a
    /// transfer hook
    TransferHookAccount,
    /// Includes encrypted withheld fees and the encryption public that they are
    /// encrypted under
    ConfidentialTransferFeeConfig,
    /// Includes confidential withheld transfer fees
    ConfidentialTransferFeeAmount,
    /// Mint contains a pointer to another account (or the same account) that
    /// holds metadata
    MetadataPointer,
    /// Mint contains token-metadata
    TokenMetadata,
    /// Mint contains a pointer to another account (or the same account) that
    /// holds group configurations
    GroupPointer,
    /// Mint contains token group configurations
    TokenGroup,
    /// Mint contains a pointer to another account (or the same account) that
    /// holds group member configurations
    GroupMemberPointer,
    /// Mint contains token group member configurations
    TokenGroupMember,
    /// Mint allowing the minting and burning of confidential tokens
    ConfidentialMintBurn,
    /// Tokens whose UI amount is scaled by a given amount
    ScaledUiAmount,
    /// Tokens where minting / burning / transferring can be paused
    Pausable,
    /// Indicates that the account belongs to a pausable mint
    PausableAccount,

    /// Test variable-length mint extension
    #[cfg(test)]
    VariableLenMintTest = u16::MAX - 2,
    /// Padding extension used to make an account exactly Multisig::LEN, used
    /// for testing
    #[cfg(test)]
    AccountPaddingTest,
    /// Padding extension used to make a mint exactly Multisig::LEN, used for
    /// testing
    #[cfg(test)]
    MintPaddingTest,
}
````

Each extension adds specialized functionality by including additional state that
must be initialized when creating a mint or token account. All extension
specific state is stored in the in the
[`tlv_data`](https://github.com/solana-program/token-2022/blob/main/program/src/extension/mod.rs#L541-L549)
field, which follows the base account data type. The `tlv_data` (containing
extension state) must be further deserialized according to the specific
extension types enabled for that account.

```rust title="Token Extensions"
/// Encapsulates immutable base state data (mint or account) with possible
/// extensions, where the base state is Pod for zero-copy serde.
#[derive(Debug, PartialEq)]
pub struct PodStateWithExtensions<'data, S: BaseState + Pod> {
    /// Unpacked base data
    pub base: &'data S,
    /// Slice of data containing all TLV data, deserialized on demand
    // [!code word:tlv_data]
    // [!code highlight]
    tlv_data: &'data [u8],
}
```

## Examples

The `anchor-spl` crate provides a
[`token_2022_extensions`](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/spl/src/token_2022_extensions)
module that contains helper functions and types for working with token extension
instructions.

You can find examples for how to work with Token Extensions in an Anchor program
in this
[program examples repository](https://github.com/solana-developers/program-examples/tree/main/tokens/token-2022).

<Callout type="info">
  Note that while the anchor-spl crate provides helper functions for working
  with Token Extensions, not all extension instructions have been fully
  implemented yet. You may need to manually implement CPI calls for some
  extension instructions.
</Callout>

````

File: anchor/docs/content/docs/tokens/index.mdx
```mdx
---
title: Token Integration with Anchor
description:
  Learn how to interact with Solana's Token Programs from an Anchor Program.
---

## What are Token Programs?

On Solana, there are two main token programs (developed by
[Anza](https://www.anza.xyz/), previously Solana Labs):

1. [Token Program (Original)](https://github.com/solana-program/token)
   - Basic token functionality (mint, transfer, etc.)
   - Immutable and widely used
2. [Token Extension Program (Token 2022)](https://github.com/solana-program/token-2022)
   - Includes all original Token Program features
   - Adds additional functionality through "extensions"
   - Recommended for new tokens

## Invoking Token Programs in an Anchor Program

The [`anchor-spl`](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/spl) crate
simplifies the process of interacting with Solana's Token Programs in an Anchor
program. This crate includes instructions and account types for both the
original Token Program and the newer Token Extension Program (Token 2022).

Simply add the `anchor-spl` crate as a dependency to your program and add `"anchor-spl/idl-build"` to idl-build feature list in `Cargo.toml`. For a
walkthrough of how to create an Anchor program locally, see the
[quickstart page](/docs/quickstart/local).

```shell title="Terminal"
cargo add anchor-spl
````

```toml title="Cargo.toml"
[features]
idl-build = [
    "anchor-lang/idl-build",
    "anchor-spl/idl-build",
]

[dependencies]
anchor-lang = "0.31.0"
anchor-spl = "0.31.0"
```

### Core Modules

The most commonly used modules provided by the `anchor-spl` crate include:

| Module                                                                                                                                     | Description                                                                              |
| ------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| [`token`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/spl/src/token.rs)                              | Token Program (legacy) instructions and account types                                    |
| [`token_2022`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/spl/src/token_2022.rs)                    | Token 2022 base instructions (instructions matching the Token Program functionality)     |
| [`token_2022_extensions`](https://github.com/coral-xyz/anchor/tree/0e5285aecdf410fa0779b7cd09a47f235882c156/spl/src/token_2022_extensions) | Token 2022 extensions instructions                                                       |
| [`token_interface`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/spl/src/token_interface.rs)          | Implementation of account types that work with both Token Program and Token 2022 Program |
| [`associated_token`](https://github.com/coral-xyz/anchor/blob/0e5285aecdf410fa0779b7cd09a47f235882c156/spl/src/associated_token.rs)        | Associated token account instruction                                                     |

The following pages provide examples of how to use the `anchor-spl` crate in an
Anchor program.

````

File: anchor/docs/content/docs/updates/release-notes/0-29-0.mdx
```mdx
---
title: 0.29.0
description: Anchor - Release Notes 0.29.0
---

Anchor keeps a
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/master/CHANGELOG.md) but
it's not easy to make sense what has changed, what effect does the change have
and how to migrate. This is where release notes comes in, an easy to digest and
actionable view for each release.

---

## How to update

1. Update `avm`:

   ```sh
   cargo install --git https://github.com/coral-xyz/anchor --tag v0.29.0 avm --locked
````

2. Update `anchor-cli`:

   ```sh
   avm install latest
   ```

3. Update Anchor crate(s) to `0.29.0`. Optionally, run `cargo update` to update
   other dependencies to the latest compatible versions.

4. Update TS package(s) to `0.29.0`.

## Solana `1.14` is no longer supported

Minimum supported Solana version is now `1.16.0` because

- All clusters including mainnet-beta are now running `^1.16`
- There is a
  [compatibility issue](https://github.com/solana-labs/solana/issues/31960)
  between `1.14` and `1.16`

If you are still on Solana `1.14`, update by running:

```sh
solana-install init 1.17.0
```

## Override toolchain for the workspace

`Anchor.toml` has a new section called `[toolchain]` that allows overriding the
current toolchain versions inside the workspace.

```toml
[toolchain]
anchor_version = "0.29.0" # `anchor-cli` version to use
solana_version = "1.17.0" # Solana version to use
```

### Notes

- Fields are optional.
- `anchor_version` requires
  [`avm`](https://github.com/coral-xyz/anchor/tree/master/avm) to be installed.
- Before this release, `anchor_version` and `solana_version` keys in
  `Anchor.toml` were being used for Docker verifiable builds only. Now, all
  commands work via the `[toolchain]` section.

## Install CLI from commit with `avm`

It is possible to install CLI from commit by running:

```sh
cargo install --git https://github.com/coral-xyz/anchor --rev 6cf200493a307c01487c7b492b4893e0d6f6cb23 anchor-cli --locked
```

but this overrides the `anchor` binary and does not work well with `avm`.

In this release, `avm` supports installing and switching between commits.

**Install** from a commit with `avm install <VERSION>-<COMMIT>`:

```sh
# <VERSION>-<COMMIT>
avm install 0.28.0-6cf200493a307c01487c7b492b4893e0d6f6cb23

# Full commit hash
avm install 6cf200493a307c01487c7b492b4893e0d6f6cb23

# Short commit hash
avm install 6cf200
```

**Use** a different version `avm use <VERSION>-<COMMIT>`:

```sh
avm use 0.28.0-6cf200493a307c01487c7b492b4893e0d6f6cb23
```

Specify `toolchain.anchor_version` as `<VERSION>-<COMMIT>`:

```toml
[toolchain]
anchor_version = "0.28.0-6cf200493a307c01487c7b492b4893e0d6f6cb23"
```

## Multiple files template

Programs created with `anchor init` or `anchor new` have a single `lib.rs` file
but not everyone prefers a single file approach for programs.

The most popular way of splitting the program into multiple files looks
something like the following:

```
â”œâ”€â”€ constants.rs
â”œâ”€â”€ error.rs
â”œâ”€â”€ instructions
â”‚Â Â  â”œâ”€â”€ initialize.rs
â”‚Â Â  â””â”€â”€ mod.rs
â”œâ”€â”€ lib.rs
â””â”€â”€ state
    â””â”€â”€ mod.rs
```

To initialize a workspace with this program structure, run:

```
anchor init <NAME> --template multiple
```

or if you have an existing workspace:

```
anchor new <NAME> --template multiple
```

## Upgradeable programs in tests

You can now configure upgradability of the programs in `anchor test`.

In `Anchor.toml`:

```toml
[test]
upgradeable = true
```

or for an individual program:

```toml
[[test.genesis]]
address = "22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD"
program = "swap.so"
upgradeable = true
```

## Lamport utilities

Transferring lamports from a PDA is quite complicated due to the types that are
being used.

Instead of

```rust
**ctx.accounts.from.to_account_info().try_borrow_mut_lamports()? -= amount;
**ctx.accounts.to.to_account_info().try_borrow_mut_lamports()? += amount;
```

you can

```rust
ctx.accounts.from.sub_lamports(amount)?;
ctx.accounts.to.add_lamports(amount)?;
```

Similarly for **getting** the lamports, instead of

```rust
let lamports = ctx.accounts.my_account.to_account_info().lamports();
```

you can

```rust
let lamports = ctx.accounts.my_account.get_lamports();
```

**Note:** The new methods are not only more ergonomic but they are also more
performant than the previous examples. This is because `to_account_info` method
clones the data internally but the new methods use a reference to the underlying
data.

## Type safe context bumps

Before this release, `ctx.bumps` used to be a `BTreeMap<String, u8>` which
doesn't provide type safety for the keys(account names).

```rust
let bump = *ctx.bumps.get("my_account").unwrap();
```

With this release, there is an auto-generated struct that holds the bump values.

```rust
let bump = ctx.bumps.my_account;
```

**Note**: The new way is not only more intuitive but also is more performant.
This is mainly because `BTreeMap` is heap-allocated and it has to resize and
grow occasionally.

## `idl-build` feature

There is a new way to generate IDLs via compilation.

Add `idl-build` feature to your program's `Cargo.toml` to try it out.

```toml
[features]
idl-build = ["anchor-lang/idl-build"]
```

The IDL will be built automatically when you run `anchor build` but if you'd
like to _only_ generate the IDL, run:

```sh
anchor idl build
```

### Notes

- All crates that are being used for the IDL generation needs to be added to the
  `idl-build` feature list.

```toml
[features]
idl-build = [
    "anchor-lang/idl-build",
    "anchor-spl/idl-build",
    "another-program/idl-build"
]
```

- Compile time checks are supported.
- External types from other Anchor programs are supported as long as the
  external crate has the `idl-build` feature(see `another-program/idl-build`).
- Conflicting type names e.g. `some_module::MyType` and `another_module::MyType`
  can be used together.
- Generation time is a lot slower compared to the default method(parsing) due to
  Rust compile times.
- Even though most of it works great, some parts are still rough around the
  edges and you may encounter parts that are not fully ironed out. Please
  [create an issue](https://github.com/coral-xyz/anchor/issues) if you run into
  a problem.

## Type aliases

Anchor IDL now supports type aliases.

```rust
pub type U8Array = [u8; 8];

#[program]
pub mod my_program {
    use super::*;

    pub fn type_alias(ctx: Context<TypeAlias>, u8_array: U8Array) -> Result<()> {
        msg!("{:?}", u8_array);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct TypeAlias {}
```

Generates the following IDL:

```json
{
  "version": "0.1.0",
  "name": "my_program",
  "instructions": [
    {
      "name": "typeAlias",
      "accounts": [],
      "args": [
        {
          "name": "u8Array",
          "type": {
            "defined": "U8Array"
          }
        }
      ]
    }
  ],
  "types": [
    {
      "name": "U8Array",
      "type": {
        "kind": "alias",
        "value": {
          "array": ["u8", 8]
        }
      }
    }
  ]
}
```

**Note:** This example only works with the default IDL generation
method(parsing) for now because type aliases for default Rust types don't work
properly with
`idl-build`([#2640](https://github.com/coral-xyz/anchor/issues/2640)).

## Export `mpl-token-metadata`

`anchor-spl` with `metadata` feature enabled now exports the
`mpl-token-metadata` crate.

**Note:** Consider removing the `mpl-token-metadata` dependency to reduce the
possibility of having conflicting versions:

```diff
[dependencies]
anchor-spl = { version = "0.29.0", features = ["metadata"] }
- mpl-token-metadata = "1.13.1"
```

and use the exported crate from `anchor-spl`:

```rust
use anchor_spl::metadata::mpl_token_metadata;
```

## TypeScript SDK improvements

1. `Program.addEventListener` method is now strongly typed -- correct types for
   the event names and the event returned from the callback instead of `any`.

2. `anchor.workspace` now lazy loads programs on-demand. Programs that are not
   being used in the tests won't get loaded and therefore won't cause errors.

3. JavaScript convention is to use camelCase for property names but programs are
   accessed via PascalCase e.g. `anchor.workspace.MyProgram` which is
   unintuitive. Both variations work in this release.

   ```ts
   const camel = anchor.workspace.myProgram;
   const pascal = anchor.workspace.MyProgram;
   ```

4. Removed `assert` and `base64-js` dependency.

## New docker image

The previous
image([projectserum/build](https://hub.docker.com/r/projectserum/build)) is now
deprecated, new image is
[backpackapp/build](https://hub.docker.com/r/backpackapp/build).

To pull the latest image, run:

```sh
docker pull backpackapp/build:v0.29.0
```

**Note:** `anchor build --verifiable` now works with the latest image.

## Enhanced performance

`0.29.0` performance is noticeably improved in all areas, the biggest one being
[binary size](https://github.com/coral-xyz/anchor/blob/master/bench/BINARY_SIZE.md#0290)
which is reduced ~36% compared to `0.28.0`!

Similar benchmarks can be found for
[compute units](https://github.com/coral-xyz/anchor/blob/master/bench/COMPUTE_UNITS.md#0290)
and
[stack memory](https://github.com/coral-xyz/anchor/blob/master/bench/STACK_MEMORY.md#0290).

**Note:** The benchmark results will vary between programs but the overall
direction should be the same.

---

See the full list of changes in the
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/master/CHANGELOG.md#0290---2023-10-16).

````

File: anchor/docs/content/docs/tokens/meta.json
```json
{
  "title": "Interacting with Tokens",
  "pages": ["basics", "extensions"]
}

````

File: anchor/docs/content/docs/updates/release-notes/0-30-0.mdx

````mdx
---
title: 0.30.0
description: Anchor - Release Notes 0.30.0
---

The long-awaited v0.30.0 release is finally here!

We'll go over the main changes, but if you'd like to see all notable changes,
check out the
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/v0.30.0/CHANGELOG.md#0300---2024-04-15).

---

## How to upgrade

1. Update `avm`:

   ```sh
   cargo install --git https://github.com/coral-xyz/anchor --tag v0.30.0 avm --locked
   ```
````

2. Update `anchor-cli`:

   ```sh
   avm install latest
   ```

3. Update Anchor crate(s) to `0.30.0`. Optionally, run `cargo update` to update
   other dependencies to the latest compatible versions.

4. Update TS package(s) to `0.30.0`.

## Recommended Solana Version

While this release supports anything above `1.16`, the recommended Solana
version is `1.18.8`. You can upgrade Solana tools by running:

```
solana-install init 1.18.8
```

## IDL

The IDL type specification and generation has been rewritten. To keep the
release notes short, we won't go over the changes here, but see
[this](https://github.com/coral-xyz/anchor/pull/2824) if you'd like to learn
more.

### `idl-build` feature

`idl-build` feature is now required in your program's `Cargo.toml` definition in
order for the IDL generation to work.

Without this feature, `anchor build` outputs:

```
Error: `idl-build` feature is missing. To solve, add

[features]
idl-build = ["anchor-lang/idl-build"]

in `<PATH_TO_CARGO_TOML>`.
```

Note that all crates that you use to generate type definitions for the IDL need
to be specified in the list of `idl-build`, e.g. `anchor-spl/idl-build`,
`some-program/idl-build`...

## Lang

### Dependency free program declaration

Depending on other crates who used different versions of Anchor is not the best
experience, to say the least. To solve this problem, program clients can now be
generated from their IDL using the new `declare_program!` macro:

```rust
declare_program!(program_name);
```

`program_name` is based on the file name of the IDL in `idls` directory, e.g.
`idls/program_name.json` is required to exist in order for the above example to
work.

This works for both on-chain (CPI) and off-chain (RPC) usage, allowing program
interactions without creating a
[dependency hell](https://en.wikipedia.org/wiki/Dependency_hell). Check out
[this](https://github.com/coral-xyz/anchor/blob/v0.30.0/tests/declare-program/programs/declare-program/src/lib.rs)
example for on-chain CPI usage.

For more information, see the macro's
[documentation](https://docs.rs/anchor-lang/0.30.0/anchor_lang/macro.declare_program.html).

### Token extensions

#### Constraints

There are new account constraints for
[Token Extensions (Token 2022)](https://solana.com/solutions/token-extensions):

- `group_pointer`:
  - `authority`
  - `group_address`
- `group_member_pointer`:
  - `authority`
  - `member_address`
- `metadata_pointer`:
  - `authority`
  - `metadata_address`
- `close_authority`
  - `authority`
- `permanent_delegate`:
  - `delegate`
- `transfer_hook`:
  - `authority`
  - `program_id`

**Note:** Above values are concatinated with `::` (similar to other Anchor
constraints) and have `extensions` prefix e.g.
`extensions::group_pointer::authority = <EXPR>`.

These constraints can be used both with or without the `init` constraint.

[Here](https://github.com/coral-xyz/anchor/blob/v0.30.0/tests/spl/token-extensions/programs/token-extensions/src/instructions.rs)
is an example program that uses these constraints.

#### CPI wrappers

`anchor-spl` now includes CPI wrappers for Token Extensions which can be
accessed from `anchor_spl::token_2022_extensions`.

### `#[interface]` attribute

Transfer hooks can now be used with the new `#[interface]` macro. This argument
overrides the Anchor's default instruction discriminator to use the interface
instruction's discriminator.

Current supported values are:

- `spl_transfer_hook_interface::initialize_extra_account_meta_list`
- `spl_transfer_hook_interface::execute`

```rust
mod my_hook_program {
    #[interface(spl_transfer_hook_interface::initialize_extra_account_meta_list)]
    pub fn initialize(ctx: Context<Initialize>, metas: Vec<AnchorExtraAccountMeta>) -> Result<()> {
        /* ... */
    }

    #[interface(spl_transfer_hook_interface::execute)]
    pub fn execute(ctx: Context<Execute>, amount: u64) -> Result<()> {
        /* ... */
    }
}
```

### Optional bumps

When an optional account is not specified, instead of defaulting it to
`u8::MAX`, this release changes the optional bump type to be `Option<u8>` and
sets the bump field to `None`.

### Less heap allocations

[`BorshSerialize::try_to_vec`](https://github.com/near/borsh-rs/blob/79097e3c71ae469a101b4828457792bcf8be7f5f/borsh/src/ser/mod.rs#L47-L51)
implementation, which is used in events, CPI, and return data, heap allocates
[1024](https://github.com/near/borsh-rs/blob/79097e3c71ae469a101b4828457792bcf8be7f5f/borsh/src/ser/mod.rs#L19)
bytes each time it's used, even if your data is much smaller. In this release,
the default allocation is set to 256 bytes.

There is also a new method `InstructionData::write_to()` to write to an existing
allocation rather than creating a new allocation with `InstructionData::data()`.

## CLI

### Priority fees in CLI

IDL commands take in `--priority-fee` argument As it's getting harder and harder
to land transactions in mainnet-beta without using priority fees, this release
supports setting `--priority-fee` argument for the IDL commands. For example:

```
anchor idl erase-authority --program-id <PROGRAM_ID> --priority-fee 9000
```

When the `--priortiy-fee` argument is not specified, the median fee of the last
150 confirmed slots is used.

### `--no-idl` flag on builds

IDL generation requires building of the program, but this is unnecessary if your
program API doesn't change. In that case, you can use `--no-idl` flag to build
your program but skip the IDL generation:

```
anchor build --no-idl
```

### IDL buffer is closed after `idl upgrade`

After an IDL upgrade, the buffer account is now closed and the lamports are
returned back to the IDL authority.

### Pass deploy arguments to `solana-cli`

You can now pass arguments to `solana program deploy` from `anchor deploy`:

```
anchor deploy -- --final
```

### Verifiable deployments

Similar to verifiable builds, you can now deploy the verified build instead of
the default build:

```
anchor deploy --verifiable
```

### Accept package name as program name

`--program-name` (`-p`) argument of various commands also works with package
name of the program rather than lib name which is snake_case. For example:

```
anchor build -p my-program
```

### Deactivate test-validator features

You can now deactivate test-validator features from `Anchor.toml`:

```toml
[test.validator]
deactivate_feature = ["GDH5TVdbTPUpRnXaRyQqiKUa7uZAbZ28Q2N9bhbKoMLm", "zkiTNuzBKxrCLMKehzuQeKZyLtX2yvFcEKMML8nExU8"]
```

### Crate and package compatibility

Using non-matching versions of `anchor-cli`, `anchor-lang`, and
`@coral-xyz/anchor` can result in unexpected behavior. In this release, you'll
get a warning if any of them don't match.

### Explicit `overflow-checks` flag

[`overflow-checks`](https://doc.rust-lang.org/cargo/reference/profiles.html#overflow-checks)
flag is implicitly disabled by default. Anchor workspaces that are crated with
`anchor init` have this flag enabled, however, Anchor doesn't do any checks for
it after the initial workspace creation.

With this release, `overflow-checks` in the workspace `Cargo.toml` need to be
specified. Note that "specified" does not mean enabled, as you can also disable
it, but you need to be explicit in doing so.

### Wildcard pattern in `Anchor.toml`

`workspace.members` and `workspace.exclude` now supports simple wildcard
pattern:

```toml
[workspace]
members = ["programs/*"]
```

Note that the support is limited to this simple wildcard pattern, and more
complex globs are not currently supported.

### `cargo build-sbf` is now the default

Before this release, `anchor build` used `cargo build-bpf` to build programs,
however, because it is deprecated, `anchor build` now defaults to
`cargo build-sbf`.

To preserve the old behavior, you can use:

```
anchor build --arch bpf
```

### Run multiple commands in scripts

Scripts in `Anchor.toml` now supports running multiple commands:

```toml
[scripts]
test-all = "cargo test && yarn run ts-mocha tests/**/*.ts"
```

This script would run both `cargo` and `yarn` commands:

```
anchor run test-all
```

### Test only a specified program

A single program can be tested in a multi program workspace with the
`--program-name` (`-p`) argument:

```
anchor test --program-name example
```

This builds and tests only the specified program.

### Rust test template

A wild TypeScript test won't appear if you initialize your workspace with the
new Rust test template:

```
anchor init --test-template rust
```

## TypeScript

### Account resolution

Account resolution refers to the ability of clients to resolve accounts without
having to manually specify them when sending transactions.

There are too many changes to the account resolution logic in the TS library,
however, we can skip a good chunk of them since they're mostly internal.

One change that affects everyone is the change in the `accounts` method. Even
though the TS library had some support for account resolution, it had no
type-level support for it â€” all accounts were essentially typed as partial, and
there was no way to know which accounts were resolvable and which were not.

There are now 3 methods to specify accounts with the transaction builder:

- `accounts`: This method is now fully type-safe based on the resolution fields
  in the IDL, making it much easier to only specify the accounts that are
  actually needed.
- `accountsPartial`: This method keeps the old behavior and let's you specify
  all accounts including the resolvable ones.
- `accountsStrict`: If you don't want to use account resolution and specify all
  accounts manually (unchanged).

This change is likely to result in errors in your existing `.accounts()` calls.
To fix, either change `accounts` to `accountsPartial`, or remove all accounts
that can be resolved from the IDL. For example:

```diff
- await program.methods
-   .init()
-   .accounts({
-     pda: ...,
-     signer: ...,
-     systemProgram: ...,
-   })
-   .rpc();
+ await program.methods.init().rpc();
```

### Magic account names

Another change that affects most projects is the removal of "magic" account
names. The TS library used to autofill common program and sysvar accounts based
on their name, e.g. `systemProgram`, however, this is no longer necessary with
the introduction of the `address` field (in the IDL) which is used to resolve
all program and sysvars by default.

### Case conversion

The internals of the TS library are filled with case conversion logic before
making string comparison and this also forces other libraries who build on top
of Anchor to do the same.

Along with making the IDL have consistent casing, TS library also has consistent
casing (camelCase) in this release.

### No more Program ID

`programId` parameter of `Program` is removed since the new IDL requires to
store the program id in its `address` field:

```diff
- new Program(idl, programId);
+ new Program(idl);
```

### Optional provider options

`opts` parameter of `AnchorProvider` is now optional:

```diff
- new AnchorProvider(connection, wallet, {});
+ new AnchorProvider(connection, wallet);
```

### Type changes

There are too many type changes to list here, especially the types that are
related to the IDL. The new IDL types can be found
[here](https://github.com/coral-xyz/anchor/blob/v0.30.0/ts/packages/anchor/src/idl.ts).

---

See the full list of notable changes in the
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/v0.30.0/CHANGELOG.md#0300---2024-04-15).

````

File: anchor/docs/content/docs/updates/release-notes/0-30-1.mdx
```mdx
---
title: 0.30.1
description: Anchor - Release Notes 0.30.1
---

There are a good number of quality of life improvements in this patch release.
You can upgrade to this version from `0.30.0` with ease since there are no major
breaking changes.

---

## How to upgrade

1. Update `anchor-cli`:

   ```sh
   avm install 0.30.1
````

2. Update Anchor crate(s) to `0.30.1`.

3. Update TS package(s) to `0.30.1`.

## Recommended Solana Version

While this release supports anything above `1.17.3`, the recommended Solana
version is `1.18.17`. You can upgrade Solana tools by running:

```
solana-install init 1.18.17
```

## IDL

### Convert legacy IDLs

A new feature has been added to the IDL crate in order to convert legacy IDLs
(pre Anchor v0.30) to new IDLs.

To programmatically convert legacy IDLs, add:

```
anchor-lang-idl = { version = "0.1.1", features = ["convert"] }
```

and use the
[`convert_idl`](https://docs.rs/anchor-lang-idl/0.1.1/anchor_lang_idl/convert/fn.convert_idl.html)
function.

**NOTE:** This functionality has also been implemented as a CLI command for
convenience, see [`idl convert` command](#idl-convert-command).

### Unsupported seed expressions

Some seed expressions such as `&(my_account.data + 1).to_le_bytes()`:

```rust
#[derive(Accounts)]
pub struct SeedMathExpr<'info> {
    #[account(seeds = [&(my_account.data + 1).to_le_bytes()], bump)]
    pub math_expr_account: UncheckedAccount<'info>,
    pub my_account: Account<'info, MyAccount>,
}

#[account]
pub struct MyAccount {
    data: u64,
}
```

cannot currently get stored in the IDL, but there was a regression in the IDL
generation that resulted in compile errors when using these or similar
unsupported expressions.

They no longer cause compile errors, but this also means that they also cannot
get automatically resolved by clients.

### Fields with `address` constraint

Using field expressions as an address constraint e.g.

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(address = my_account.authority)]
    pub authority: UncheckedAccount<'info>,
    pub my_account: Account<'info, MyAccount>,
}

#[account]
pub struct MyAccount {
    authority: u64,
}
```

no longer result in a compile error when generating the IDL.

However, accounts that use the `address` constraint with non-constant values do
not currently resolve automatically. For this reason, you might want to consider
using the `has_one` constraint instead:

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    pub authority: UncheckedAccount<'info>,
    #[account(has_one = authority)]
    pub my_account: Account<'info, MyAccount>,
}
```

### Override `nightly` version on builds

IDL generation currently uses the `nightly` compiler to build the IDL, and this
can potentially result in compile errors on certain `nightly` versions.

In this release, you can now override the nightly version with
`RUSTUP_TOOLCHAIN` env variable.

### Recursive generation

There was a compile error during generation with recursive external type
resolution, which is now fixed. See
[this](https://github.com/coral-xyz/anchor/pull/2946) if you'd like to see the
problem in more detail.

### New spec crate

Making changes to the IDL crate, e.g. adding features such as the
[`convert`](https://github.com/coral-xyz/anchor/pull/2986) feature, would
require bumping the version to get the changes even if the spec itself doesn't
change.

To fix this problem, a new [crate](https://docs.rs/anchor-lang-idl-spec) that
only includes the IDL spec has been introduced. The new crate's version will be
used in the `idl.metadata.spec` field to differentiate between various IDLs.

**NOTE:** This crate is accesible via the main IDL crate from
[`anchor_lang_idl::types`](https://docs.rs/anchor-lang-idl/0.1.1/anchor_lang_idl/types/index.html).

## CLI

### `idl convert` command

This command allows you to convert legacy IDLs with the new `anchor idl convert`
command:

```
anchor idl convert <PATH_TO_IDL_JSON>
```

### `idl type` command

This command creates TypeScript IDL type (with camelCase fields) from an
existing IDL file:

```
anchor idl type <PATH_TO_IDL_JSON>
```

### `idl build` toolchain override

See the [explanation](#override-nightly-version-on-builds) in the IDL section.
Example usage with the CLI:

```sh
RUSTUP_TOOLCHAIN="nightly-2024-05-09" anchor idl build
```

### Automatic program id updates

When building a program for the first time ever, the program id declarations
will get automatically updated if there is not a `[programs.localnet]` entry in
`Anchor.toml`.

Note that this is essentially the same as running `anchor keys sync`, only
difference being that this will only run once automatically.

### Upgradeable program clones

Cloning upgradeable programs with

```toml
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
```

would result in unusable programs due to a breaking change in Solana `1.17.12`.

This problem has been fixed from both Anchor and Solana's side. However, it
requires using `solana-cli >=1.18.10`.

### File system error improvements

Default Rust error when a file is not found in the file system does not log the
file path, which makes it difficult to debug.

In this release, file system related errors also include the path of the file.

## Lang

### Using legacy IDLs with `declare_program!`

[`declare_program!`](https://www.anchor-lang.com/release-notes/0.30.0#dependency-free-program-declaration)
macro can now be used with legacy IDLs (pre Anchor v0.30).

This works great as long as the program can be described correctly with the
legacy IDL spec. However, if a program uses non-default features such as zero
copy, or `repr` modifications, the declaration of the program either won't
compile, or will be invalid. There are two main solutions in this scenerio:

- Use the `idl convert` command, and manually fix the invalid parts
- Generate the program's IDL by upgrading the program to Anchor v0.30

The latter option is preferred as it's less error-prone. If you have dependency
issues while upgrading, simply remove them when generating the IDL since the IDL
generation only cares about the signatures, and all program logic, including all
dependencies (except Anchor), can be removed when generating the IDL.
[Here](https://github.com/coral-xyz/anchor/blob/cc43e67399ad50cf7d33466f7bcd7e6dcee88ae2/ts/packages/spl-token/program/lib.rs)
is an example program that you can generate an IDL from.

In short, IDLs should be preferably generated with v0.30 rather than the
conversion method, as a new IDL spec wouldn't be necessary if the old one was
sufficient to reliably describe programs.

### `declare_program!` fixes

There were a number of cases where the new `declare_program!` would cause a
compile error.

Using the following would result in a compile error:

- Defined types (e.g. `struct`s) in instruction parameters
- Types with `const` generics
- `Vec<u8>` type
- Instruction with a non-unit return type
- Optional accounts (in clients)
- `bytemuckunsafe` account serialization

Another issue was tuple struct fields were private (Rust default), they are now
public.

### `pubkey!` macro

[`solana-program`](https://docs.rs/solana-program/1.18.17/solana_program/index.html)
has
[`pubkey!`](https://docs.rs/solana-program/1.18.17/solana_program/macro.pubkey.html)
to easily declare public keys:

```rust
let key = pubkey!("11111111111111111111111111111111");
```

which is more convenient than `Pubkey::from_str`:

```rust
use std::str::FromStr;
let key = Pubkey::from_str("11111111111111111111111111111111").unwrap();
```

However, because of how the macro is implemented, it wasn't possible to use it
from Anchor without also including `solana-program` to your dependency list as
the macro was specifically using `::solana_program`.

You can now directly use `pubkey!` as it's exported from `anchor_lang::prelude`.

Note that because `solana_program` is exported from `anchor_lang`, you can also
remove `solana-program` dependency from your `Cargo.toml` if `pubkey!` was the
reason for adding it.

### `ID_CONST` constant

Program ids declared from
[`declare_id!`](https://docs.rs/anchor-lang/0.30.1/anchor_lang/macro.declare_id.html)
and
[`declare_program!`](https://docs.rs/anchor-lang/0.30.1/anchor_lang/macro.declare_program.html)
have `ID` declared as `static` which doesn't allow compile time checks.

Both of these macros now have a new constant (`ID_CONST`), which is essentially
the same as `ID`, but is declared as `const` instead of `static`.

### Stack usage of token extensions

Stack usage of the new
[token extensions constraints](https://www.anchor-lang.com/release-notes/0.30.0#token-extensions)
has been improved.

### Error propagation from integer conversion errors

You can now propagate integer conversion errors with `?`:

```rust
let n: i32 = u32::MAX.try_into()?;
```

## SPL

### Export ATA crate

[`spl-associated-token-account](https://crates.io/crates/spl-associated-token-account)
crate is now re-exported from `anchor_spl::associated_token`.

Similar to how you can
[remove](https://www.anchor-lang.com/release-notes/0.29.0#export-mpl-token-metadata)
the `mpl-token-metadata` crate from your dependency list, you can also remove
`spl-associated-token-accounts` crate.

```toml
[dependencies]
anchor-spl = "0.30.1"
- spl-associated-token-account = "3.0.2"
```

## TypeScript

### ATA resolution

The
[account resolution](https://www.anchor-lang.com/release-notes/0.30.0#account-resolution)
support has been extended to support associated token accounts in this release.

If you use ATAs in your instruction, you'll get a type error if you call the
`accounts` method with those account specified. To solve, simply remove all ATAs
from your `accounts` call.

### Defined types in generics

Using defined types (structs, enums, or type aliases) as a generic argument e.g.

```rust
param: GenericStruct<MyStruct>,
```

no longer results in an error.

### Versioned transactions

A problem where `maxSupportedTransactionVersion` was needed, but not being set
from `AnchorProvider` has been fixed.

### New errors package

Anchor errors have been separated into a new package
[`@coral-xyz/anchor-errors`](https://www.npmjs.com/package/@coral-xyz/anchor-errors).

---

See the full list of notable changes in the
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/v0.30.1/CHANGELOG.md#0301---2024-06-20).

````

File: anchor/docs/content/docs/updates/release-notes/0-31-0.mdx
```mdx
---
title: 0.31.0
description: Anchor - Release Notes 0.31.0
---

The last major release before v1 is finally here.

As always, there are a great number of changes, but we'll only be covering the
most important ones here. For a list of all notable changes, see the
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/v0.31.0/CHANGELOG.md#0310---2025-03-08).

---

## How to upgrade

1. Install the latest version of `avm`:

   ```sh
   cargo install --git https://github.com/coral-xyz/anchor avm --force
````

This will allow installing Anchor CLI without having to compile from source,
see [Install from binary](#install-from-binary).

2. Update `anchor-cli`:

   ```sh
   avm install 0.31.0
   ```

3. Update Anchor crate(s) to `0.31.0`.

4. Update TS package(s) to `0.31.0`.

## Recommended Solana Version

The recommended Solana version is `2.1.0`. This is a special upgrade because
some of the Solana binaries have been renamed to Agave, see
[Agave transition](https://github.com/anza-xyz/agave/wiki/Agave-Transition).

You can install the newer tooling by running:

```
sh -c "$(curl -sSfL https://release.anza.xyz/v2.1.0/install)"
```

This change is handled automatically if you specify `toolchain.solana_version`,
see [Automatic Agave transition](#automatic-agave-transition).

## AVM

### Install from binary

`avm install` now downloads binaries from GitHub by default.

The following build targets are supported:

- `aarch64-apple-darwin`
- `x86_64-unknown-linux-gnu`
- `x86_64-apple-darwin`
- `x86_64-pc-windows-msvc`

You can add the `--from-source` flag to the `install` command if that's
preferred (or required due to unsupported platform).

## CLI

### Automatic Agave transition

As mentioned in [Recommended Solana version](#recommended-solana-version)
section, some of the Solana binaries are renamed to Agave. `solana-install` is
deprecated in `1.18.19` and logs a deprecation message when used (this results
in parsing failure in older Anchor versions):

```
âš ï¸  solana-install is deprecated and will be discontinued when v1.18 is no longer supported. Please switch to Agave: https://github.com/anza-xyz/agave/wiki/Agave-Transition
```

In this release, if you specify `solana_version` field with a version greater
than `1.18.19`, it automatically installs and switches to `agave-install`:

```toml
[toolchain]
solana_version = "2.1.0"
```

### `solana-program` warning

Adding `solana-program` as a dependency of Anchor programs should be avoided to
decrease the possibility of version conflicts between Solana v1 and v2 crates.

You'll see the following warning on builds if you have `solana-program` in your
dependency list:

```
WARNING: Adding `solana-program` as a separate dependency might cause conflicts.
To solve, remove the `solana-program` dependency and use the exported crate from `anchor-lang`.
`use solana_program` becomes `use anchor_lang::solana_program`.
Program name: `my-program`
```

### Pass `cargo` args to IDL build

Both `anchor build` and `anchor idl build` commands pass the `cargo` arguments
to the underyling IDL build command. For example:

```
anchor build -- --features my-feature
```

now builds the IDL with `my-feature` enabled.

### `--no-idl` flag for tests

If you make a change to your program, but the API of the program stays the same,
building the IDL is pointless and takes additional time.

Similar to [`--no-idl` flag on builds](./0.30.0#no-idl-flag-on-builds), now you
can use:

```
anchor test --no-idl
```

### `mollusk` test template

You can initialize your workspace using the new
[`mollusk`](/docs/testing/mollusk) template by running:

```sh
anchor init my-program --test-template mollusk
```

### `clean`

`anchor clean` now also removes the generated `.anchor` directory.

For those of you that don't know, this command is similar to `cargo clean`, but
it keeps the program keypairs.

### Automatic IDL conversion

Legacy IDLs (pre Anchor v0.30) were not supported in v0.30, unless you first
converted them to the new spec using `anchor idl convert`. In this release,
various commands do this conversion automatically, meaning you'll be able to
work with both specs without having to switch versions. The only exception is
the `idl fetch` command, which does not convert legacy IDLs.

### Package manager

Anchor has been using `yarn` as the default JS package manager, but some people
want to use other package managers. Changing the package manager to use wasn't
easy, as certain commands required `yarn` to be installed to function properly.
This is no longer the case, and you can simply specify the package manager to
use from `Anchor.toml`:

```toml
[toolchain]
package_manager = "npm"
```

or when creating a new workspace:

```
anchor init <NAME> --package-manager npm
```

Supported values: `npm`, `yarn`, `pnpm` (default: `yarn`)

### Shell completions

You can now generate shell completions, see
[Shell Completions](/docs/installation#shell-completions).

## Lang

### Stack memory improvements

This is going to be a longer section, TL;DR is stack usage is improved massively
when using `init` constraints, and stack warnings on builds are now reliable
when using Solana v2 (`platform-tools v1.42`). Keep reading if you're interested
in learning more, otherwise you can skip to
[Custom discriminators](#custom-discriminators).

The main place where Anchor programs are likely to hit stack violation errors is
a generated function called `try_accounts`. This is where the instruction is
deserialized and constraints are run. Although having everything at the same
place is convenient for using constraints, this also makes it very easy to use
the fixed amount of stack space (4096 bytes) SVM allocates just by increasing
the number of accounts the instruction has. You might be familiar with it from
the mangled build logs:

```
Error: Function _ZN71_$LT$pr..Test$u20$as$u20$anchor_lang..Accounts$LT$pr..TestBumps$GT$$GT$12try_accounts17h5572074d55b9e638E Stack offset of 4112 exceeded max offset of 4096 by 16 bytes, please minimize large stack variables.
```

The problem was made worse with the following external developments:

1. Rust/LLVM changes shipped with Solana v1.18 made Anchor's `try_accounts`
   function use even more stack space, resulting in much lower threshold to hit
   stack-related problems.
2. The stack logs were unreliable, meaning you wouldn't always get warnings
   during builds if you went over the stack limit.
3. The feature
   ["Account data direct mapping"](https://github.com/solana-labs/solana/issues/29708),
   which is enabled by default when using local-validator, made the programs run
   into [undefined behavior](https://en.wikipedia.org/wiki/Undefined_behavior)
   when a function used more stack space than it had available.

All of this combined meant that your programs used more stack space (1), but
sometimes the errors didn't get caught during the compile time (2) or even the
runtime (3).

Undefined behavior is particularly challenging to debug because things may
appear to work as expected during tests, but a different input to the same test
might overwrite an account's data with unintended bytes. There are endless
scenarios that could go wrong here, and some examples include
[#2955](https://github.com/coral-xyz/anchor/issues/2955),
[#3113](https://github.com/coral-xyz/anchor/issues/3113), and
[#3196](https://github.com/coral-xyz/anchor/issues/3196).

There isn't much we can do for problems 1 and 3, but the problem 2 is resolved
with Solana v2 (`platform-tools v1.42`), meaning you'll reliably get warnings
about all stack problems.

Circling back to Anchor, the biggest offender to the stack usage was identified
to be the `init` constraint. Each `init` constraint expands to a lengthy code
inside `try_accounts`, resulting in excessive stack usage when multiple `init`
constraints are used. This problem was fixed by moving the `init` code inside a
closure and immediately calling it in order to create and use a different stack
frame ([#2939](https://github.com/coral-xyz/anchor/pull/2939)).

Related to this topic, there is
[SIMD-0166](https://github.com/solana-foundation/solana-improvement-documents/pull/166),
a proposal to introduce dynamic stack frames.

In short, you'll have fewer problems related to stack memory when using Anchor
v0.31 and Solana v2. If you're still running into problems, please create an
issue in [coral-xyz/anchor](https://github.com/coral-xyz/anchor/issues/3097).

### Custom discriminators

Before this release, there were several problems regarding Anchor
discriminators:

- Due to the transaction size limits enforced by the Solana runtime (1232
  bytes), 8 bytes can be too high for some use cases
- The `Discriminator` trait had a fixed size type field (`[u8; 8]`), which meant
  we wouldn't be able to implement it for non-Anchor programs (e.g. in
  `declare_program!`)
- Discriminators were not customizable
- Changing the name of the data type the discriminator was derived from resulted
  in a different discriminator

This release solves all of the above problems by introducing support for custom
discriminators. The default 8-byte discriminators have not changed, but you can
override them via the `discriminator` argument implemented in various Anchor
attribute macros:

- `#[account(discriminator = 1)]`
- `#[event(discriminator = [1, 2])]`
- `#[instruction(discriminator = MY_CONST)]`

All constant expressions are supported.

See
[example](https://github.com/coral-xyz/anchor/blob/v0.31.0/tests/custom-discriminator/programs/custom-discriminator/src/lib.rs).

It's important that the discriminator is always unique for the type you're
implementing it for. While the discriminator can be at any length (including
zero), the IDL generation does not currently allow empty discriminators for
safety and convenience reasons. However, the `Discriminator` trait definition
still allows empty discriminators because some non-Anchor programs, e.g. the SPL
Token program, don't have account discriminators. In that case, safety checks
should never depend on the discriminator.

Additionally, the IDL generation step also checks whether you have ambigious
discriminators i.e. discriminators that can be used for multiple types. However,
you should still consider future possibilities, especially when working with
1-byte discriminators. For example, having an account with discriminator `[1]`
means you can't have any other discriminators that start with `1`, e.g.
`[1, 2 , 3, 4]`, as it would not be unique.

This change also enables using non-Anchor programs with both Rust (via
[`declare_program!`](./0.30.0#dependency-free-program-declaration)) and in the
TS client.

### `Discriminator` trait

The `discriminator` method of the `Discriminator` trait has been removed. If you
have compilation errors related to this removal, you can simply replace the
`discriminator()` call to the `DISCRIMINATOR` associated constant.

This trait is now exported from `prelude`, and it can be used to replace a very
common usage that hardcodes the discriminator length as `8`. For example, the
following:

```rs
space = 8 + ...
```

can be replaced by:

```rs
space = MyAccount::DISCRIMINATOR.len() + ...
```

### `LazyAccount`

`LazyAccount` is an experimental account type that can be used to replace
`Account` when you're running into performance-related problems.

We'll skip the details to keep the release notes as short as possible, but if
you're interested, check out
[its documentation](https://docs.rs/anchor-lang/0.31.0/anchor_lang/accounts/lazy_account/struct.LazyAccount.html)
to see if it fits your needs.

**Note:** You need to enable `lazy-account` feature of `anchor-lang` to be able
to use `LazyAccount`.

### `cfg` attribute on instructions

You can now use `cfg` attributes on instructions:

```rs
#[program]
mod my_program {
    #[cfg(feature = "my-feature")]
    pub fn my_feature(ctx: Context<MyFeature>) -> Result<()> {}
}
```

### Unnamed and unit structs with `InitSpace`

Unnamed and unit struct support was added in v0.30, but deriving `InitSpace` did
not work with these structs. This release adds support for both of them:

```rs
#[derive(InitSpace)]
pub struct Unnamed(pub u64, #[max_len(64)] pub Vec<u8>);

#[derive(InitSpace)]
pub struct Unit;
```

### Account parser

You can now conveniently parse any program account using `declare_program!`:

```rs
declare_program!(my_program);
```

This will generate something similar to:

```rs
pub enum Account {
    SomeAccount(SomeAccount),
    OtherAccount(OtherAccount),
}
```

Use `my_program::utils::Account::try_from_bytes` to parse any account belonging
to the program.

### `declare_program!` improvements

The following issues related to
[`declare_program!`](/docs/features/declare-program) have been fixed:

- Being unable to use constant bytes
  ([#3287](https://github.com/coral-xyz/anchor/pull/3287))
- Missing docs from the generated constants
  ([#3311](https://github.com/coral-xyz/anchor/pull/3311))
- Compilation errors related to incorrectly adding `derive`s and `repr`s to type
  aliases ([#3504](https://github.com/coral-xyz/anchor/pull/3504))
- Being unable to use `data` as an instruction parameter
  ([#3574](https://github.com/coral-xyz/anchor/pull/3574))

## SPL

### New Token 2022 instructions

The following Token 2022 instructions were added:

- `burn_checked`
- `mint_to_checked`
- `approve_checked`
- `withdraw_withheld_tokens_from_accounts`

## IDL

### Safety comment checks

In v0.30.1, you'd run into panics in Rust Analyzer if you enabled all features
because the `idl-build` feature expected an environment variable to be set. This
was always set if you used `anchor build`, but since Rust Analyzer did not know
about this environment variable, it would panic:

```
custom attribute panicked
message: Safety checks failed: Failed to get program path
```

It no longer panics if the environment variable is missing.

### `address` constraint with non-const expressions

There was a regression in v0.30 that made using non-const expressions with the
`address` constraint fail:

```rs
#[derive(Accounts)]
pub struct MyIx {
    #[account(address = my_account.authority())]
    pub authority: Signer<'info>,
    pub my_account: Account<'info, MyAccount>,
}
```

This is now fixed and no longer results in build errors.

See [coral-xyz/anchor#3216](https://github.com/coral-xyz/anchor/pull/3216) for
more information.

### `Program` accounts with full paths

The following did not work in v0.30, but it works now:

```rs
#[derive(Accounts)]
pub struct FullPath<'info> {
    pub external_program: Program<'info, external::program::External>,
}
```

### `IdlBuilder`

Building the IDL via the
[`build_idl`](https://github.com/coral-xyz/anchor/blob/v0.31.0/idl/src/build.rs#L119)
function made it impossible to extend its functionality e.g. add new parameters
without a breaking change. To solve this problem, there is a new way to build
IDLs programatically:

```rs
let idl = IdlBuilder::new().program_path(path).skip_lint(true).build()?;
```

See
[`IdlBuilder`](https://docs.rs/anchor-lang-idl/0.1.2/anchor_lang_idl/build/struct.IdlBuilder.html)
for more information.

### Generation improvements

The following issues with the IDL generation have been fixed:

- A bug where using tuple parameters in instructions would result in an
  incorrect IDL ([#3294](https://github.com/coral-xyz/anchor/pull/3294))
- A bug where doc comments could trigger false-positives during module paths
  convertion ([#3359](https://github.com/coral-xyz/anchor/pull/3359))
- A bug where the generated IDL only has partial resolution information
  ([#3474](https://github.com/coral-xyz/anchor/pull/3474))
- Being unable to use constant identifiers as generic arguments
  ([#3522](https://github.com/coral-xyz/anchor/pull/3522))
- Being unable to pass in a `Pubkey` constant to `seeds::program`
  ([#3559](https://github.com/coral-xyz/anchor/pull/3559))
- Being unable to pass in an account or an argument to `seeds::program`
  ([#3570](https://github.com/coral-xyz/anchor/pull/3570))

## TypeScript

### Simpler `Program` construction

TypeScript's automatic inference of JSON files made it difficult to use the
`Program` constructor without additional casting:

```ts
import * as idl from "./idl/my_program.json";
import type { MyProgram } from "./types/my_program";

const program = new Program(idl as unknown as MyProgram, provider);
```

Casting to `unknown` or `any` was necessary when TypeScript automatically
inferred the type of the JSON file.

In this release, the program constructor no longer infers the IDL type from the
given `idl` argument. This makes it easier to specify the actual IDL type:

```ts
const program = new Program<MyProgram>(idl, provider);
```

### Error improvements

Account resolution error now includes the accounts that weren't able to get
resolved:

```
Reached maximum depth for account resolution. Unresolved accounts: `pda`, `anotherPda`
```

Similarly, unsupported `view` method error now includes the possible causes:

```
Error: Method does not support views. The instruction should return a value, and its accounts must be read-only
```

### Type improvements

It's common to use `//@ts-ignore` to get the payer keypair in tests:

```ts
// @ts-ignore
const payer = program.provider.wallet.payer;
```

To fix this problem, the `Provider` interface now includes an optional
`wallet: Wallet` field, and similarly, the `Wallet` interface now includes
optional `payer: Keypair` field.

You can now do:

```ts
const payer = program.provider.wallet!.payer!;
```

We're using `!` because we know these fields are going to be defined in our
testing environment.

### Better confirmation

`Provider.sendAndConfirm` now takes in an optional `blockhash` and uses that for
better transaction confirmation:

```ts
await program.provider.sendAndConfirm(tx, signers, { blockhash: ... });
```

### Programs with numbers in their name

Testing programs with numbers in their name using `anchor.workspace` now works
for all cases.

For more details about the problem and its solution, see
[#3450](https://github.com/coral-xyz/anchor/pull/3450).

## Rust Client

### `tokio` support

There was a problem that made it impossible to use `tokio` with
[`anchor-client`](https://docs.rs/anchor-client/0.31.0/anchor_client/index.html).
This problem is now fixed, and you can use `tokio` (with `async` feature). See
[`tokio` example](https://github.com/coral-xyz/anchor/blob/v0.31.0/client/example/src/nonblocking.rs#L65-L99).

### Mock client

It's now possible to pass in a
[mock RPC client](https://docs.rs/solana-client/2.1.0/solana_client/rpc_client/struct.RpcClient.html#method.new_mock)
for testing by enabling the `mock` feature:

```toml
anchor-client = { version = "0.31.0", features = ["mock"] }
```

---

See the full list of notable changes in the
[CHANGELOG](https://github.com/coral-xyz/anchor/blob/v0.31.0/CHANGELOG.md#0310---2025-03-08).

````

File: anchor/docs/content/docs/updates/release-notes/meta.json
```json
{
  "title": "Release Notes",
  "pages": ["0-31-0", "0-30-1", "0-30-0", "0-29-0"]
}

````

File: anchor/docs/content/docs/updates/changelog.mdx

```mdx
---
title: Changelog
description: Anchor Changelog
---

Version 0 of Semantic Versioning is handled differently from version 1 and
above. The minor version will be incremented upon a breaking change and the
patch version will be incremented for features.

---

## [0.31.0] - 2025-03-08

### Features

- client: Make `solana_account_decoder` dep public in anchor client
  ([#3455](https://github.com/coral-xyz/anchor/pull/3455)).
- ts: Add optional `options.blockhash` to `Provider.sendAndConfirm`
  ([#3070](https://github.com/coral-xyz/anchor/pull/3070)).
- ts: Add optional `commitment` parameter to `Program.addEventListener`
  ([#3052](https://github.com/coral-xyz/anchor/pull/3052)).
- cli, idl: Pass `cargo` args to IDL generation when building program or IDL
  ([#3059](https://github.com/coral-xyz/anchor/pull/3059)).
- cli: Add checks for incorrect usage of `idl-build` feature
  ([#3061](https://github.com/coral-xyz/anchor/pull/3061)).
- lang: Export `Discriminator` trait from `prelude`
  ([#3075](https://github.com/coral-xyz/anchor/pull/3075)).
- lang: Add `Account` utility type to get accounts from bytes
  ([#3091](https://github.com/coral-xyz/anchor/pull/3091)).
- client: Add option to pass in mock rpc client when using anchor_client
  ([#3053](https://github.com/coral-xyz/anchor/pull/3053)).
- lang: Get discriminator length dynamically
  ([#3101](https://github.com/coral-xyz/anchor/pull/3101)).
- lang: Add non-8-byte discriminator support in `declare_program!`
  ([#3103](https://github.com/coral-xyz/anchor/pull/3103)).
- client: Make `ThreadSafeSigner` trait public
  ([#3107](https://github.com/coral-xyz/anchor/pull/3107)).
- lang: Update `dispatch` function to support dynamic discriminators
  ([#3104](https://github.com/coral-xyz/anchor/pull/3104)).
- lang: Remove the fallback function shortcut in `try_entry` function
  ([#3109](https://github.com/coral-xyz/anchor/pull/3109)).
- ts: Get discriminator lengths dynamically
  ([#3120](https://github.com/coral-xyz/anchor/pull/3120)).
- client: Support non-8-byte discriminators
  ([#3125](https://github.com/coral-xyz/anchor/pull/3125)).
- spl: Add `withdraw_withheld_tokens_from_accounts` instruction
  ([#3128](https://github.com/coral-xyz/anchor/pull/3128)).
- ts: Add optional `wallet` property to the `Provider` interface
  ([#3130](https://github.com/coral-xyz/anchor/pull/3130)).
- cli: Warn if `anchor-spl/idl-build` is missing
  ([#3133](https://github.com/coral-xyz/anchor/pull/3133)).
- client: Add `internal_rpc` method for `mock` feature
  ([#3135](https://github.com/coral-xyz/anchor/pull/3135)).
- lang: Add `#[instruction]` attribute proc-macro to override default
  instruction discriminators
  ([#3137](https://github.com/coral-xyz/anchor/pull/3137)).
- lang: Use associated discriminator constants instead of hardcoding in
  `#[account]` ([#3144](https://github.com/coral-xyz/anchor/pull/3144)).
- lang: Add `discriminator` argument to `#[account]` attribute
  ([#3149](https://github.com/coral-xyz/anchor/pull/3149)).
- lang: Add `discriminator` argument to `#[event]` attribute
  ([#3152](https://github.com/coral-xyz/anchor/pull/3152)).
- idl: Check ambiguous discriminators
  ([#3157](https://github.com/coral-xyz/anchor/pull/3157)).
- idl: Disallow all zero account discriminators
  ([#3159](https://github.com/coral-xyz/anchor/pull/3159)).
- cli: Support non-8-byte discriminators
  ([#3165](https://github.com/coral-xyz/anchor/pull/3165)).
- idl: Disallow empty discriminators
  ([#3166](https://github.com/coral-xyz/anchor/pull/3166)).
- cli: Add `--no-idl` option to the `test` command
  ([#3175](https://github.com/coral-xyz/anchor/pull/3175)).
- spl: Add `burn_checked`, `mint_to_checked` and `approve_checked` instructions
  ([#3186](https://github.com/coral-xyz/anchor/pull/3186)).
- cli: Migrate to `agave-install` when `solana_version` is `>= 1.18.19`
  ([#3185](https://github.com/coral-xyz/anchor/pull/3185)).
- idl: Add `IdlBuilder`
  ([#3188](https://github.com/coral-xyz/anchor/pull/3188)).
- cli: Make `clean` command also remove the `.anchor` directory
  ([#3192](https://github.com/coral-xyz/anchor/pull/3192)).
- lang: Deprecate `#[interface]` attribute
  ([#3195](https://github.com/coral-xyz/anchor/pull/3195)).
- ts: Include unresolved accounts in the resolution error message
  ([#3207](https://github.com/coral-xyz/anchor/pull/3207)).
- lang: Add `LazyAccount`
  ([#3194](https://github.com/coral-xyz/anchor/pull/3194)).
- avm: Ask whether to install if the version is not installed with the `use`
  command ([#3230](https://github.com/coral-xyz/anchor/pull/3230)).
- cli: Warn if a manifest has `solana-program` dependency
  ([#3250](https://github.com/coral-xyz/anchor/pull/3250)).
- cli: Add completions command to generate shell completions via the
  clap_complete crate ([#3251](https://github.com/coral-xyz/anchor/pull/3251)).
- cli: Always convert IDLs
  ([#3265](https://github.com/coral-xyz/anchor/pull/3265)).
- cli: Check whether the `idl-build` feature exists when using the `idl build`
  command ([#3273](https://github.com/coral-xyz/anchor/pull/3273)).
- cli: Build IDL if there is only one program when using the `idl build` command
  ([#3275](https://github.com/coral-xyz/anchor/pull/3275)).
- cli: Add short alias for the `idl build` command
  ([#3283](https://github.com/coral-xyz/anchor/pull/3283)).
- cli: Add `--program-id` option to `idl convert` command
  ([#3309](https://github.com/coral-xyz/anchor/pull/3309)).
- lang: Generate documentation of constants in `declare_program!`
  ([#3311](https://github.com/coral-xyz/anchor/pull/3311)).
- cli: Add support for fetching legacy IDLs
  ([#3324](https://github.com/coral-xyz/anchor/pull/3324)).
- avm: Add short alias for `install` and `list` commands
  ([#3326](https://github.com/coral-xyz/anchor/pull/3326)).
- avm: Add Windows support for renaming anchor binary
  ([#3325](https://github.com/coral-xyz/anchor/pull/3325)).
- cli: Add optional `package-manager` flag in `init` command to set package
  manager field in Anchor.toml
  ([#3328](https://github.com/coral-xyz/anchor/pull/3328)).
- cli: Add test template for [Mollusk](https://github.com/buffalojoec/mollusk)
  ([#3352](https://github.com/coral-xyz/anchor/pull/3352)).
- idl: Disallow account discriminators that can conflict with the `zero`
  constraint ([#3365](https://github.com/coral-xyz/anchor/pull/3365)).
- cli: Include recommended solana args by default and add new `--max-retries`
  option to the `deploy` command
  ([#3354](https://github.com/coral-xyz/anchor/pull/3354)).
- avm: Make installation download binaries by default
  ([#3445](https://github.com/coral-xyz/anchor/pull/3445)).
- idl: Support PDA resolution of call expressions that don't have any arguments
  ([#3485](https://github.com/coral-xyz/anchor/pull/3485)).
- spl: Add `anchor-debug` feature
  ([#3511](https://github.com/coral-xyz/anchor/pull/3511)).

### Fixes

- idl: Make safety comment checks fail silently when program path env is not set
  ([#3045](https://github.com/coral-xyz/anchor/pull/3045)).
- idl: Avoid interference from rust tests during IDL generation
  ([#3058](https://github.com/coral-xyz/anchor/pull/3058)).
- lang: Fix `align` repr support in `declare-program!`
  ([#3056](https://github.com/coral-xyz/anchor/pull/3056)).
- lang: Make stack frames slimmer on ATA creation
  ([#3065](https://github.com/coral-xyz/anchor/pull/3065)).
- lang: Remove `getrandom` dependency
  ([#3072](https://github.com/coral-xyz/anchor/pull/3072)).
- lang: Make `InitSpace` support unnamed & unit structs
  ([#3084](https://github.com/coral-xyz/anchor/pull/3084)).
- lang: Fix using `owner` constraint with `Box`ed accounts
  ([#3087](https://github.com/coral-xyz/anchor/pull/3087)).
- lang: Add a sanity check for unimplemented token extensions
  ([#3090](https://github.com/coral-xyz/anchor/pull/3090)).
- cli: Skip IDL checks if `--no-idl` option is passed
  ([#3093](https://github.com/coral-xyz/anchor/pull/3093)).
- lang: Remove unnecessary clone in account exit routine
  ([#3139](https://github.com/coral-xyz/anchor/pull/3139)).
- cli: Fix installation with `--locked` argument using Rust v1.80 due to `time`
  crate issue ([#3143](https://github.com/coral-xyz/anchor/pull/3143)).
- lang: Fix compilation warnings due to unused deprecated program id macros
  ([#3170](https://github.com/coral-xyz/anchor/pull/3170)).
- ts: Remove `crypto-hash` dependency
  ([#3171](https://github.com/coral-xyz/anchor/pull/3171)).
- ts: Improve error message of unsupported `view` method
  ([#3177](https://github.com/coral-xyz/anchor/pull/3177)).
- idl: Fix panicking on tests
  ([#3197](https://github.com/coral-xyz/anchor/pull/3197)).
- lang: Remove `arrayref` dependency
  ([#3201](https://github.com/coral-xyz/anchor/pull/3201)).
- cli: Fix template code shouldn't escape
  ([#3210](https://github.com/coral-xyz/anchor/pull/3210)).
- idl: Fix using `address` constraint with non-const expressions
  ([#3216](https://github.com/coral-xyz/anchor/pull/3216)).
- idl: Fix using full path types with `Program`
  ([#3228](https://github.com/coral-xyz/anchor/pull/3228)).
- lang: Use closures for `init` constraints to reduce the stack usage of
  `try_accounts` ([#2939](https://github.com/coral-xyz/anchor/pull/2939)).
- lang: Allow the `cfg` attribute above the instructions
  ([#2339](https://github.com/coral-xyz/anchor/pull/2339)).
- idl: Log output with `ANCHOR_LOG` on failure and improve build error message
  ([#3284](https://github.com/coral-xyz/anchor/pull/3284)).
- lang: Fix constant bytes declarations when using `declare_program!`
  ([#3287](https://github.com/coral-xyz/anchor/pull/3287)).
- lang: Fix using non-instruction composite accounts with `declare_program!`
  ([#3290](https://github.com/coral-xyz/anchor/pull/3290)).
- idl: Fix instructions with tuple parameters not producing an
  error([#3294](https://github.com/coral-xyz/anchor/pull/3294)).
- ts: Update `engines.node` to `>= 17`
  ([#3301](https://github.com/coral-xyz/anchor/pull/3301)).
- cli: Use OS-agnostic paths
  ([#3307](https://github.com/coral-xyz/anchor/pull/3307)).
- avm: Use `rustc 1.79.0` when installing versions older than v0.31
  ([#3315](https://github.com/coral-xyz/anchor/pull/3315)).
- cli: Fix priority fee calculation causing panic on localnet
  ([#3318](https://github.com/coral-xyz/anchor/pull/3318)).
- cli: Fix `shell` command failing due to outdated program initialization
  ([#3351](https://github.com/coral-xyz/anchor/pull/3351)).
- idl: Fix detecting false-positives from doc comments during module path
  conversion ([#3359](https://github.com/coral-xyz/anchor/pull/3359)).
- cli: Remove passing the rent sysvar account to IDL instructions
  ([#3372](https://github.com/coral-xyz/anchor/pull/3372)).
- lang: Fix `cpi` feature instructions not accounting for discriminator
  overrides ([#3376](https://github.com/coral-xyz/anchor/pull/3376)).
- idl: Ignore compiler warnings during builds
  ([#3396](https://github.com/coral-xyz/anchor/pull/3396)).
- cli: Avoid extra IDL generation during `verify`
  ([#3398](https://github.com/coral-xyz/anchor/pull/3398)).
- lang: Require `zero` accounts to be unique
  ([#3409](https://github.com/coral-xyz/anchor/pull/3409)).
- lang: Deduplicate `zero` accounts against `init` accounts
  ([#3422](https://github.com/coral-xyz/anchor/pull/3422)).
- cli: Fix custom `provider.cluster`
  ([#3428](https://github.com/coral-xyz/anchor/pull/3428)).
- cli: Ignore non semver solana/agave releases to avoid panic
  ([#3432](https://github.com/coral-xyz/anchor/pull/3432)).
- ts: Fix loading programs with numbers in their names using `workspace`
  ([#3450](https://github.com/coral-xyz/anchor/pull/3450)).
- lang: Remove a potential panic while getting the IDL in `declare_program!`
  ([#3458](https://github.com/coral-xyz/anchor/pull/3458)).
- cli: Fix altering user-provided lib names
  ([#3467](https://github.com/coral-xyz/anchor/pull/3467)).
- idl: Fix missing `program::seed` resolution
  ([#3474](https://github.com/coral-xyz/anchor/pull/3474)).
- lang: Fix adding `derive`s and `repr`s to type alias definitions in
  `declare_program!` ([#3504](https://github.com/coral-xyz/anchor/pull/3504)).
- idl: Fix using constant identifiers as generic arguments
  ([#3522](https://github.com/coral-xyz/anchor/pull/3522)).
- client: Remove `std::process::exit` usage
  ([#3544](https://github.com/coral-xyz/anchor/pull/3544)).
- idl: Fix using `Pubkey` constants with `seeds::program`
  ([#3559](https://github.com/coral-xyz/anchor/pull/3559)).
- lang: Fix instructions with no accounts causing compilation errors when using
  `declare_program!` ([#3567](https://github.com/coral-xyz/anchor/pull/3567)).
- idl: Fix using account or arg values for `seeds::program`
  ([#3570](https://github.com/coral-xyz/anchor/pull/3570)).
- lang: Fix using `data` as an instruction parameter name in `declare_program!`
  ([#3574](https://github.com/coral-xyz/anchor/pull/3574)).
- cli: Use camelCase for program name in `anchor.workspace` templates
  ([#3581](https://github.com/coral-xyz/anchor/pull/3581)).

### Breaking

- syn: Remove `bpf` target support in `hash` feature
  ([#3078](https://github.com/coral-xyz/anchor/pull/3078)).
- client: Add `tokio` support to `RequestBuilder` with `async` feature
  ([#3057](https://github.com/coral-xyz/anchor/pull/3057)).
- lang: Remove `EventData` trait
  ([#3083](https://github.com/coral-xyz/anchor/pull/3083)).
- client: Remove `async_rpc` method
  ([#3053](https://github.com/coral-xyz/anchor/pull/3053)).
- lang: Make discriminator type unsized
  ([#3098](https://github.com/coral-xyz/anchor/pull/3098)).
- lang: Require `Discriminator` trait impl when using the `zero` constraint
  ([#3118](https://github.com/coral-xyz/anchor/pull/3118)).
- ts: Remove `DISCRIMINATOR_SIZE` constant
  ([#3120](https://github.com/coral-xyz/anchor/pull/3120)).
- lang: `#[account]` attribute arguments no longer parses identifiers as
  namespaces ([#3140](https://github.com/coral-xyz/anchor/pull/3140)).
- spl: Rename metadata interface instruction fields from `token_program_id` to
  `program_id` ([#3076](https://github.com/coral-xyz/anchor/pull/3076)).
- lang, ts: Remove "8 byte" requirement from discriminator error messages
  ([#3161](https://github.com/coral-xyz/anchor/pull/3161)).
- lang: Remove `discriminator` method from `Discriminator` trait
  ([#3163](https://github.com/coral-xyz/anchor/pull/3163)).
- docker: Upgrade `node` to 20.16.0 LTS
  ([#3179](https://github.com/coral-xyz/anchor/pull/3179)).
- ts: Change the `Program` constructor's `idl` parameter type to `any`
  ([#3181](https://github.com/coral-xyz/anchor/pull/3181)).
- lang, spl: Remove `borsh 0.9` support
  ([#3199](https://github.com/coral-xyz/anchor/pull/3199)).
- ts: Upgrade `typescript` to `5.5.4` and remove the generic parameters of
  `SimulateResponse` ([#3221](https://github.com/coral-xyz/anchor/pull/3221)).
- ts: Remove
  `StateCoder`([#3224](https://github.com/coral-xyz/anchor/pull/3224)).
- cli: Accept integers for `warp_slot`
  ([#3235](https://github.com/coral-xyz/anchor/pull/3235)).
- lang: Remove `EventIndex`
  ([#3244](https://github.com/coral-xyz/anchor/pull/3244)).
- spl: Remove `dex` feature
  ([#3257](https://github.com/coral-xyz/anchor/pull/3257)).
- client, lang, spl: Upgrade Solana to v2 and SPL to the latest
  ([#3219](https://github.com/coral-xyz/anchor/pull/3219)).
- cli: Install Solana from anza.xyz domain in Docker verifiable builds
  ([#3271](https://github.com/coral-xyz/anchor/pull/3271)).
- spl: Upgrade SPL deps to latest
  ([#3346](https://github.com/coral-xyz/anchor/pull/3346)).
- cli: Upgrade `typescript` version of templates to v5
  ([#3480](https://github.com/coral-xyz/anchor/pull/3480)).
- ts: Remove `snake-case` dependency
  ([#3507](https://github.com/coral-xyz/anchor/pull/3507)).

## [0.30.1] - 2024-06-20

### Features

- idl: Allow overriding the idl build toolchain with the `RUSTUP_TOOLCHAIN`
  environment variable
  ([#2941](https://github.com/coral-xyz/anchor/pull/2941])).
- avm: Support customizing the installation location using `AVM_HOME`
  environment variable ([#2917](https://github.com/coral-xyz/anchor/pull/2917)).
- avm: Optimize `avm list` when GitHub API rate limits are reached
  ([#2962](https://github.com/coral-xyz/anchor/pull/2962))
- idl, ts: Add accounts resolution for associated token accounts
  ([#2927](https://github.com/coral-xyz/anchor/pull/2927)).
- cli: Add `--no-install` option to the `init` command
  ([#2945](https://github.com/coral-xyz/anchor/pull/2945)).
- lang: Implement `TryFromIntError` for `Error` to be able to propagate integer
  conversion errors ([#2950](https://github.com/coral-xyz/anchor/pull/2950)).
- idl: Add ability to convert legacy IDLs
  ([#2986](https://github.com/coral-xyz/anchor/pull/2986)).
- ts: Extract Anchor error codes into their own package
  ([#2983](https://github.com/coral-xyz/anchor/pull/2983)).
- cli: Add additional solana arguments to the `upgrade` command
  ([#2998](https://github.com/coral-xyz/anchor/pull/2998)).
- spl: Export `spl-associated-token-account` crate
  ([#2999](https://github.com/coral-xyz/anchor/pull/2999)).
- lang: Support legacy IDLs with `declare_program!`
  ([#2997](https://github.com/coral-xyz/anchor/pull/2997)).
- cli: Add `idl convert` command
  ([#3009](https://github.com/coral-xyz/anchor/pull/3009)).
- cli: Add `idl type` command
  ([#3017](https://github.com/coral-xyz/anchor/pull/3017)).
- lang: Add `anchor_lang::pubkey` macro for declaring `Pubkey` const values
  ([#3021](https://github.com/coral-xyz/anchor/pull/3021)).
- cli: Sync program ids on the initial build
  ([#3023](https://github.com/coral-xyz/anchor/pull/3023)).
- idl: Remove `anchor-syn` dependency
  ([#3030](https://github.com/coral-xyz/anchor/pull/3030)).
- lang: Add `const` of program ID to `declare_id!` and `declare_program!`
  ([#3019](https://github.com/coral-xyz/anchor/pull/3019)).
- idl: Add separate spec crate
  ([#3036](https://github.com/coral-xyz/anchor/pull/3036)).

### Fixes

- lang: Eliminate variable allocations that build up stack space for token
  extension code generation
  ([#2913](https://github.com/coral-xyz/anchor/pull/2913)).
- ts: Fix incorrect `maxSupportedTransactionVersion` in `AnchorProvider.send*()`
  methods ([#2922](https://github.com/coral-xyz/anchor/pull/2922)).
- cli: Use npm's configured default license for new projects made with
  `anchor init` ([#2929](https://github.com/coral-xyz/anchor/pull/2929)).
- cli: add filename to 'Unable to read keypair file' errors
  ([#2932](https://github.com/coral-xyz/anchor/pull/2932)).
- idl: Fix path resolution of the `Cargo.lock` of the project when generating
  idls for external types
  ([#2946](https://github.com/coral-xyz/anchor/pull/2946)).
- idl: Fix potential panic on external type resolution
  ([#2954](https://github.com/coral-xyz/anchor/pull/2954)).
- lang: Fix using defined types in instruction parameters with
  `declare_program!` ([#2959](https://github.com/coral-xyz/anchor/pull/2959)).
- lang: Fix using const generics with `declare_program!`
  ([#2965](https://github.com/coral-xyz/anchor/pull/2965)).
- lang: Fix using `Vec<u8>` type with `declare_program!`
  ([#2966](https://github.com/coral-xyz/anchor/pull/2966)).
- lang: Fix `ProgramError::ArithmeticOverflow` not found error
  ([#2975](https://github.com/coral-xyz/anchor/pull/2975)).
- lang: Fix using optional accounts with `declare_program!`
  ([#2967](https://github.com/coral-xyz/anchor/pull/2967)).
- lang: Fix instruction return type generation with `declare_program!`
  ([#2977](https://github.com/coral-xyz/anchor/pull/2977)).
- cli: Fix IDL write getting corrupted from retries
  ([#2964](https://github.com/coral-xyz/anchor/pull/2964)).
- idl: Fix `unexpected_cfgs` build warning
  ([#2992](https://github.com/coral-xyz/anchor/pull/2992)).
- lang: Make tuple struct fields public in `declare_program!`
  ([#2994](https://github.com/coral-xyz/anchor/pull/2994)).
- Remove `rust-version` from crate manifests
  ([#3000](https://github.com/coral-xyz/anchor/pull/3000)).
- cli: Fix upgradeable program clones
  ([#3010](https://github.com/coral-xyz/anchor/pull/3010)).
- ts: Fix using IDLs that have defined types as generic arguments
  ([#3016](https://github.com/coral-xyz/anchor/pull/3016)).
- idl: Fix generation with unsupported expressions
  ([#3033](https://github.com/coral-xyz/anchor/pull/3033)).
- idl: Fix using `address` constraint with field expressions
  ([#3034](https://github.com/coral-xyz/anchor/pull/3034)).
- lang: Fix using `bytemuckunsafe` account serialization with `declare_program!`
  ([#3037](https://github.com/coral-xyz/anchor/pull/3037)).

### Breaking

## [0.30.0] - 2024-04-15

### Features

- cli: Allow force `init` and `new`
  ([#2698](https://github.com/coral-xyz/anchor/pull/2698)).
- cli: Add verifiable option when `deploy`
  ([#2705](https://github.com/coral-xyz/anchor/pull/2705)).
- cli: Add support for passing arguments to the underlying
  `solana program deploy` command with `anchor deploy`
  ([#2709](https://github.com/coral-xyz/anchor/pull/2709)).
- lang: Add `InstructionData::write_to` implementation
  ([#2733](https://github.com/coral-xyz/anchor/pull/2733)).
- lang: Add `#[interface(..)]` attribute for instruction discriminator overrides
  ([#2728](https://github.com/coral-xyz/anchor/pull/2728)).
- ts: Add `.interface(..)` method for instruction discriminator overrides
  ([#2728](https://github.com/coral-xyz/anchor/pull/2728)).
- cli: Check `anchor-lang` and CLI version compatibility
  ([#2753](https://github.com/coral-xyz/anchor/pull/2753)).
- ts: Add missing IDL PDA seed types
  ([#2752](https://github.com/coral-xyz/anchor/pull/2752)).
- cli: `idl close` accepts optional `--idl-address` parameter
  ([#2760](https://github.com/coral-xyz/anchor/pull/2760)).
- cli: Add support for simple wildcard patterns in Anchor.toml's
  `workspace.members` and `workspace.exclude`.
  ([#2785](https://github.com/coral-xyz/anchor/pull/2785)).
- cli: Add `--test-template` option for `init` command
  ([#2805](https://github.com/coral-xyz/anchor/pull/2805)).
- cli: `anchor test` is able to run multiple commands
  ([#2799](https://github.com/coral-xyz/anchor/pull/2799)).
- cli: Check `@coral-xyz/anchor` package and CLI version compatibility
  ([#2813](https://github.com/coral-xyz/anchor/pull/2813)).
- cli: Accept package name as program name
  ([#2816](https://github.com/coral-xyz/anchor/pull/2816)).
- cli: Add ability to build and test only a specified program
  ([#2823](https://github.com/coral-xyz/anchor/pull/2823)).
- idl: Add new IDL spec
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl: Add support for `repr`s
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl: Add support for expression evaluation
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl: Add support for using external types when generating the IDL
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl, ts: Add unit and tuple struct support
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl, ts: Add generics support
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: Add `accountsPartial` method to keep the old `accounts` method behavior
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: Make `opts` parameter of `AnchorProvider` constructor optional
  ([#2843](https://github.com/coral-xyz/anchor/pull/2843)).
- cli: Add `--no-idl` flag to the `build` command
  ([#2847](https://github.com/coral-xyz/anchor/pull/2847)).
- cli: Add priority fees to idl commands
  ([#2845](https://github.com/coral-xyz/anchor/pull/2845)).
- ts: Add `prepend` option to MethodBuilder `preInstructions` method
  ([#2863](https://github.com/coral-xyz/anchor/pull/2863)).
- lang: Add `declare_program!` macro
  ([#2857](https://github.com/coral-xyz/anchor/pull/2857)).
- cli: Add `deactivate_feature` flag to `solana-test-validator` config in
  Anchor.toml ([#2872](https://github.com/coral-xyz/anchor/pull/2872)).
- idl: Add `docs` field for constants
  ([#2887](https://github.com/coral-xyz/anchor/pull/2887)).
- idl: Store deployment addresses for other clusters
  ([#2892](https://github.com/coral-xyz/anchor/pull/2892)).
- lang: Add `Event` utility type to get events from bytes
  ([#2897](https://github.com/coral-xyz/anchor/pull/2897)).
- lang, spl: Add support for
  [token extensions](https://solana.com/solutions/token-extensions)
  ([#2789](https://github.com/coral-xyz/anchor/pull/2789)).
- lang: Return overflow error from `Lamports` trait operations
  ([#2907](https://github.com/coral-xyz/anchor/pull/2907)).

### Fixes

- syn: Add missing `new_from_array` method to `Hash`
  ([#2682](https://github.com/coral-xyz/anchor/pull/2682)).
- cli: Switch to Cargo feature resolver(`resolver = "2"`)
  ([#2676](https://github.com/coral-xyz/anchor/pull/2676)).
- cli: Fix using user specific path for `provider.wallet` in `Anchor.toml`
  ([#2696](https://github.com/coral-xyz/anchor/pull/2696)).
- syn: Fix IDL constant seeds parsing
  ([#2699](https://github.com/coral-xyz/anchor/pull/2699)).
- cli: Display errors if toolchain override restoration fails
  ([#2700](https://github.com/coral-xyz/anchor/pull/2700)).
- cli: Fix commit based `anchor_version` override
  ([#2704](https://github.com/coral-xyz/anchor/pull/2704)).
- spl: Fix compilation with `shmem` feature enabled
  ([#2722](https://github.com/coral-xyz/anchor/pull/2722)).
- cli: Localhost default test validator address changes from `localhost` to
  `127.0.0.1`, NodeJS 17 IP resolution changes for IPv6
  ([#2725](https://github.com/coral-xyz/anchor/pull/2725)).
- lang: Eliminate temporary Vec allocations when serializing data with
  discriminant and set the default capacity to 256 bytes
  ([#2691](https://github.com/coral-xyz/anchor/pull/2691)).
- lang: Allow custom lifetime in Accounts structure
  ([#2741](https://github.com/coral-xyz/anchor/pull/2741)).
- lang: Remove `try_to_vec` usage while setting the return data in order to
  reduce heap memory usage
  ([#2744](https://github.com/coral-xyz/anchor/pull/2744))
- cli: Show installation progress if Solana tools are not installed when using
  toolchain overrides ([#2757](https://github.com/coral-xyz/anchor/pull/2757)).
- ts: Fix formatting enums
  ([#2763](https://github.com/coral-xyz/anchor/pull/2763)).
- cli: Fix `migrate` command not working without global `ts-node` installation
  ([#2767](https://github.com/coral-xyz/anchor/pull/2767)).
- client, lang, spl, syn: Enable all features for docs.rs build
  ([#2774](https://github.com/coral-xyz/anchor/pull/2774)).
- ts: Fix construction of field layouts for type aliased instruction arguments
  ([#2821](https://github.com/coral-xyz/anchor/pull/2821))
- idl: Fix IDL ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl, ts: Make casing consistent
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: Fix not being able to use numbers in instruction, account, or event names
  in some cases due to case conversion
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- cli: Fix excessive test validator requests
  ([#2828](https://github.com/coral-xyz/anchor/pull/2828)).
- client: Fix `parse_logs_response` to prevent panics when more than 1 outer
  instruction exists in logs
  ([#2856](https://github.com/coral-xyz/anchor/pull/2856)).
- avm, cli: Fix `stdsimd` feature compilation error from `ahash` when installing
  the CLI using newer Rust versions
  ([#2867](https://github.com/coral-xyz/anchor/pull/2867)).
- spl: Fix not being able to deserialize newer token 2022 extensions
  ([#2876](https://github.com/coral-xyz/anchor/pull/2876)).
- spl: Remove `solana-program` dependency
  ([#2900](https://github.com/coral-xyz/anchor/pull/2900)).
- spl: Make `TokenAccount` and ` Mint` `Copy`
  ([#2904](https://github.com/coral-xyz/anchor/pull/2904)).
- ts: Add missing errors
  ([#2906](https://github.com/coral-xyz/anchor/pull/2906)).

### Breaking

- cli: Make `cargo build-sbf` the default build command
  ([#2694](https://github.com/coral-xyz/anchor/pull/2694)).
- cli: Require explicit `overflow-checks` flag
  ([#2716](https://github.com/coral-xyz/anchor/pull/2716)).
- ts: Remove `anchor-deprecated-state` feature
  ([#2717](https://github.com/coral-xyz/anchor/pull/2717)).
- lang: Remove `CLOSED_ACCOUNT_DISCRIMINATOR`
  ([#2726](https://github.com/coral-xyz/anchor/pull/2726)).
- lang: Make bumps of optional accounts `Option<u8>` rather than `u8`
  ([#2730](https://github.com/coral-xyz/anchor/pull/2730)).
- spl: Remove `shared-memory` program
  ([#2747](https://github.com/coral-xyz/anchor/pull/2747)).
- ts: Remove `associated`, `account.associated` and `account.associatedAddress`
  methods ([#2749](https://github.com/coral-xyz/anchor/pull/2749)).
- cli: `idl upgrade` command closes the IDL buffer account
  ([#2760](https://github.com/coral-xyz/anchor/pull/2760)).
- cli: Remove `--jest` option from the `init` command
  ([#2805](https://github.com/coral-xyz/anchor/pull/2805)).
- cli: Require `idl-build` feature in program `Cargo.toml`
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- cli: Rename `seeds` feature to `resolution` and make it enabled by default
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- cli: Remove `idl parse` command
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- idl: Change IDL spec ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- syn: Remove `idl-parse` and `seeds` features
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: Change `accounts` method to no longer accept resolvable accounts
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: `Program` instances use camelCase for everything
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: Remove discriminator functions
  ([#2824](https://github.com/coral-xyz/anchor/pull/2824)).
- ts: Remove `programId` parameter of the `Program` constructor
  ([#2864](https://github.com/coral-xyz/anchor/pull/2864)).
- idl, syn: Move IDL types from the `anchor-syn` crate to the new IDL crate
  ([#2882](https://github.com/coral-xyz/anchor/pull/2882)).
- idl: Add `#[non_exhaustive]` to IDL enums
  ([#2890](https://github.com/coral-xyz/anchor/pull/2890)).

## [0.29.0] - 2023-10-16

### Features

- lang: Change all accounts to have a reference to `AccountInfo`
  ([#2656](https://github.com/coral-xyz/anchor/pull/2656)).
- lang: Add `get_lamports`, `add_lamports` and `sub_lamports` methods for all
  account types ([#2552](https://github.com/coral-xyz/anchor/pull/2552)).
- client: Add a helper struct `DynSigner` to simplify use of
  `Client<C> where <C: Clone + Deref<Target = impl Signer>>` with Solana clap
  CLI utils that loads `Signer` as `Box<dyn Signer>`
  ([#2550](https://github.com/coral-xyz/anchor/pull/2550)).
- lang: Allow CPI calls matching an interface without pinning program ID
  ([#2559](https://github.com/coral-xyz/anchor/pull/2559)).
- cli, lang: Add IDL generation through compilation. `anchor build` still uses
  parsing method to generate IDLs, use `anchor idl build` to generate IDLs with
  the build method ([#2011](https://github.com/coral-xyz/anchor/pull/2011)).
- avm: Add support for the `.anchorversion` file to facilitate switching between
  different versions of the `anchor-cli`
  ([#2553](https://github.com/coral-xyz/anchor/pull/2553)).
- ts: Add ability to access workspace programs independent of the casing used,
  e.g. `anchor.workspace.myProgram`, `anchor.workspace.MyProgram`...
  ([#2579](https://github.com/coral-xyz/anchor/pull/2579)).
- bench: Add benchmarking for program binary size
  ([#2591](https://github.com/coral-xyz/anchor/pull/2591)).
- spl: Export `mpl-token-metadata` crate
  ([#2583](https://github.com/coral-xyz/anchor/pull/2583)).
- spl: Add `TokenRecordAccount` for pNFTs
  ([#2597](https://github.com/coral-xyz/anchor/pull/2597)).
- ts: Add support for unnamed(tuple) enum in accounts
  ([#2601](https://github.com/coral-xyz/anchor/pull/2601)).
- cli: Add program template with multiple files for instructions, state...
  ([#2602](https://github.com/coral-xyz/anchor/pull/2602)).
- bench: Add benchmarking for stack memory usage
  ([#2617](https://github.com/coral-xyz/anchor/pull/2617)).
- lang: `Box` the inner enums of `anchor_lang::error::Error` to optimize
  `anchor_lang::Result`
  ([#2600](https://github.com/coral-xyz/anchor/pull/2600)).
- ts: Add strong type support for `Program.addEventListener` method
  ([#2627](https://github.com/coral-xyz/anchor/pull/2627)).
- syn: Add `IdlBuild` trait to implement IDL support for custom types
  ([#2629](https://github.com/coral-xyz/anchor/pull/2629)).
- spl: Add `idl-build` feature. IDL build method will not work without enabling
  this feature when using `anchor-spl`
  ([#2629](https://github.com/coral-xyz/anchor/pull/2629)).
- lang: Add support for type aliases in IDLs
  ([#2637](https://github.com/coral-xyz/anchor/pull/2637)).
- cli: Add `test.upgradeable`, `test.genesis.upgradeable` setting in
  `Anchor.toml` to support testing upgradeable programs
  ([#2642](https://github.com/coral-xyz/anchor/pull/2642)).
- cli, client, lang, spl: Update Solana toolchain and dependencies to `1.17.0`,
  `1.16` remains supported
  ([#2645](https://github.com/coral-xyz/anchor/pull/2645)).
- spl: Add support for memo program
  ([#2661](https://github.com/coral-xyz/anchor/pull/2661)).
- avm: Add `anchor-cli` installation from commit
  ([#2659](https://github.com/coral-xyz/anchor/pull/2659)).
- cli: Add `toolchain` property in `Anchor.toml` to override Anchor and Solana
  versions ([#2649](https://github.com/coral-xyz/anchor/pull/2649)).

### Fixes

- ts: Packages no longer depend on `assert`
  ([#2535](https://github.com/coral-xyz/anchor/pull/2535)).
- lang: Support for `const` in the `InitSpace` macro
  ([#2555](https://github.com/coral-xyz/anchor/pull/2555)).
- cli: Support workspace inheritance
  ([#2570](https://github.com/coral-xyz/anchor/pull/2570)).
- client: Compile with Solana `1.14`
  ([#2572](https://github.com/coral-xyz/anchor/pull/2572)).
- cli: Fix `anchor build --no-docs` adding docs to the IDL
  ([#2575](https://github.com/coral-xyz/anchor/pull/2575)).
- ts: Load workspace programs on-demand rather than loading all of them at once
  ([#2579](https://github.com/coral-xyz/anchor/pull/2579)).
- lang: Fix `associated_token::token_program` constraint
  ([#2603](https://github.com/coral-xyz/anchor/pull/2603)).
- cli: Fix `anchor account` command panicking outside of workspace
  ([#2620](https://github.com/coral-xyz/anchor/pull/2620)).
- lang: IDL named enum variant fields are now camelCase as opposed to
  snake_case, consistent with the other IDL types
  ([#2633](https://github.com/coral-xyz/anchor/pull/2633)).
- avm: Remove excessive panics and handle the errors gracefully
  ([#2671](https://github.com/coral-xyz/anchor/pull/2671)).

### Breaking

- lang: Switch to type safe bumps in context
  ([#2542](https://github.com/coral-xyz/anchor/pull/2542)).
- syn: `idl` feature has been replaced with `idl-build`, `idl-parse` and
  `idl-types` features ([#2011](https://github.com/coral-xyz/anchor/pull/2011)).
- syn: IDL `parse` method now returns `Result<Idl>` instead of
  `Result<Option<Idl>>`
  ([#2582](https://github.com/coral-xyz/anchor/pull/2582)).
- spl: Update `mpl-token-metadata` dependency to use the client SDK instead of
  the program crate ([#2632](https://github.com/coral-xyz/anchor/pull/2632)).
- ts: Remove `base64-js` dependency
  ([#2635](https://github.com/coral-xyz/anchor/pull/2635)).
- syn: `IdlTypeDefinitionTy` enum has a new variant `Alias`
  ([#2637](https://github.com/coral-xyz/anchor/pull/2637)).
- cli, client, lang, spl: Solana `1.14` is no longer supported, minimum required
  Solana version is `1.16.0`
  ([#2645](https://github.com/coral-xyz/anchor/pull/2645)).
- cli: `anchor_version` and `solana_version` property in `Anchor.toml` that was
  being used in verifiable builds are moved inside `toolchain`. They are now
  being used for all commands in the workspace, not just verifiable builds
  ([#2649](https://github.com/coral-xyz/anchor/pull/2649)).

## [0.28.0] - 2023-06-09

### Features

- client: Add `async` feature flag to use an asynchronous anchor-client
  ([#2488](https://github.com/coral-xyz/anchor/pull/2488)).
- spl: Add metadata wrappers `approve_collection_authority`,
  `bubblegum_set_collection_size`, `burn_edition_nft`, `burn_nft`,
  `revoke_collection_authority`, `set_token_standard`, `utilize`,
  `unverify_sized_collection_item`, `unverify_collection`
  ([#2430](https://github.com/coral-xyz/anchor/pull/2430))
- spl: Add `token_program` constraint to `Token`, `Mint`, and `AssociatedToken`
  accounts in order to override required `token_program` fields and use
  different token interface implementations in the same instruction
  ([#2460](https://github.com/coral-xyz/anchor/pull/2460))
- cli: Add support for Solidity programs. `anchor init` and `anchor new` take an
  option `--solidity` which creates solidity code rather than rust.
  `anchor build` and `anchor test` work accordingly
  ([#2421](https://github.com/coral-xyz/anchor/pull/2421))
- bench: Add benchmarking for compute units usage
  ([#2466](https://github.com/coral-xyz/anchor/pull/2466))
- cli: `idl set-buffer`, `idl set-authority` and `idl close` take an option
  `--print-only`. which prints transaction in a base64 Borsh compatible format
  but not sent to the cluster. It's helpful when managing authority under a
  multisig, e.g., a user can create a proposal for a `Custom Instruction` in SPL
  Governance ([#2486](https://github.com/coral-xyz/anchor/pull/2486)).
- lang: Add `emit_cpi!` and `#[event_cpi]` macros(behind `event-cpi` feature
  flag) to store event logs in transaction metadata
  ([#2438](https://github.com/coral-xyz/anchor/pull/2438)).
- cli: Add `keys sync` command to sync program id declarations
  ([#2505](https://github.com/coral-xyz/anchor/pull/2505)).
- cli: Create new programs with correct program ids
  ([#2509](https://github.com/coral-xyz/anchor/pull/2509)).
- cli, client, lang, spl: Update Solana toolchain and dependencies to `1.16.0`
  and specify maximum version of `<1.17.0`
  ([#2512](https://github.com/coral-xyz/anchor/pull/2512)).
- cli: `anchor deploy` command's `--program-name` argument accepts program lib
  names ([#2519](https://github.com/coral-xyz/anchor/pull/2519)).

### Fixes

- ts: Narrowed `AccountClient` type to it's appropriate account type
  ([#2440](https://github.com/coral-xyz/anchor/pull/2440))
- lang: Fix inability to use identifiers `program_id`, `accounts`, `ix_data`,
  `remaining_accounts` in instruction arguments
  ([#2464](https://github.com/coral-xyz/anchor/pull/2464))
- cli: Fix incorrect `metadata.address` generation in IDL after deploying with a
  custom keypair ([#2485](https://github.com/coral-xyz/anchor/pull/2485))
- cli: IDL commands no longer hang when the payer doesn't have funds to pay for
  the transaction fee ([#2492](https://github.com/coral-xyz/anchor/pull/2492))
- cli: Fix `anchor new` not updating `Anchor.toml`
  ([#2516](https://github.com/coral-xyz/anchor/pull/2516)).
- client, lang, spl: Allow wider range of dependency versions to reduce
  dependency issues ([#2524](https://github.com/coral-xyz/anchor/pull/2524)).

### Breaking

- lang: Identifiers that are intended for internal usage(`program_id`,
  `accounts`, `ix_data`, `remaining_accounts`) have been renamed with `__`
  prefix ([#2464](https://github.com/coral-xyz/anchor/pull/2464))
- spl: Remove the `metadata::create_metadata_account_v2` deprecated wrapper
  since it was removed from token metadata program
  ([#2480](https://github.com/coral-xyz/anchor/pull/2480))

## [0.27.0] - 2023-03-08

### Features

- spl: Add `MasterEditionAccount` account deserialization to spl metadata
  ([#2393](https://github.com/coral-xyz/anchor/pull/2393)).
- lang: Add the `InitSpace` derive macro to automatically calculate the space at
  the initialization of an account
  ([#2346](https://github.com/coral-xyz/anchor/pull/2346)).
- cli: Add `env` option to verifiable builds
  ([#2325](https://github.com/coral-xyz/anchor/pull/2325)).
- cli: Add `idl close` command to close a program's IDL account
  ([#2329](https://github.com/coral-xyz/anchor/pull/2329)).
- cli: `idl init` now supports very large IDL files
  ([#2329](https://github.com/coral-xyz/anchor/pull/2329)).
- spl: Add `transfer_checked` function
  ([#2353](https://github.com/coral-xyz/anchor/pull/2353)).
- spl: Add `approve_checked` function
  ([#2401](https://github.com/coral-xyz/anchor/pull/2401)).
- cli: Add `--skip-build` option to the verify command
  ([#2387](https://github.com/coral-xyz/anchor/pull/2387)).
- client: Add support for multithreading to the rust client: use flag
  `--multithreaded` ([#2321](https://github.com/coral-xyz/anchor/pull/2321)).
- client: Add `async_rpc` a method which returns a nonblocking solana rpc client
  ([#2322](https://github.com/coral-xyz/anchor/pull/2322)).
- avm, cli: Use the `rustls-tls` feature of `reqwest` so that users don't need
  OpenSSL installed ([#2385](https://github.com/coral-xyz/anchor/pull/2385)).
- ts: Add `VersionedTransaction` support. Methods in the `Provider` class and
  `Wallet` interface now use the argument
  `tx: Transaction | VersionedTransaction`
  ([#2427](https://github.com/coral-xyz/anchor/pull/2427)).
- cli: Add `--arch sbf` option to compile programs using `cargo build-sbf`
  ([#2398](https://github.com/coral-xyz/anchor/pull/2398)).
- land: Support multiple programs with the same interface using `Interface` and
  `InterfaceAccount` types, related to token-2022
  ([#2386](https://github.com/coral-xyz/anchor/pull/2386)).

### Fixes

- ts: Make the return type of `AccountClient.fetchMultiple` match the account
  type being fetched ([#2390](https://github.com/coral-xyz/anchor/pull/2390))
- cli: Don't regenerate idl in read_all_programs().
  ([#2332](https://github.com/coral-xyz/anchor/pull/2332)).
- ts: `provider.simulate` will send the transaction with `sigVerify: false` if
  no `signers` are present
  ([#2331](https://github.com/coral-xyz/anchor/pull/2331)).
- cli: Failing commands will return the correct exit status.
  ([#2370](https://github.com/coral-xyz/anchor/pull/2370)).
- idl: Update the IDL program to use non-deprecated account types
  ([#2365](https://github.com/coral-xyz/anchor/pull/2365)).
- ts: Enum fields weren't being converted from snake_case to camelCase
  ([#2378](https://github.com/coral-xyz/anchor/pull/2378)).
- lang/cli: Update to solana-program version 1.14.16 and rust version 1.60,
  appears to still be incompatible with 1.15 CLI
  ([#2420](https://github.com/coral-xyz/anchor/pull/2420)).

### Breaking

- lang: Remove deprecated account types: `CpiAccount`, `Loader` and
  `ProgramAccount` ([#2375](https://github.com/coral-xyz/anchor/pull/2375)).
- lang: Remove `state` and `interface` attributes
  ([#2285](https://github.com/coral-xyz/anchor/pull/2285)).
- lang: Remove deprecated literal constraint which has been replaced by
  `#[account(constraint = {})]`
  ([#2379](https://github.com/coral-xyz/anchor/pull/2379)).
- lang: `account(zero_copy)` and `zero_copy` attributes now derive the
  `bytemuck::Pod` and `bytemuck::Zeroable` traits instead of using `unsafe impl`
  ([#2330](https://github.com/coral-xyz/anchor/pull/2330)). This imposes useful
  restrictions on the type, like not having padding bytes and all fields being
  `Pod` themselves. See
  [bytemuck::Pod](https://docs.rs/bytemuck/latest/bytemuck/trait.Pod.html) for
  details. This change requires adding
  `bytemuck = { version = "1.4.0", features = ["derive", "min_const_generics"]}`
  to your `cargo.toml`. Legacy applications can still use
  `#[account(zero_copy(unsafe))]` and `#[zero_copy(unsafe)]` for the old
  behavior.
- ts: Remove `createProgramAddressSync`, `findProgramAddressSync` (now available
  in `@solana/web3.js`) and update `associatedAddress` to be synchronous
  ([#2357](https://github.com/coral-xyz/anchor/pull/2357)).

## [0.26.0] - 2022-12-15

### Features

- cli: Add `--run` to `anchor test` for running a subset of test suites
  ([#1828](https://github.com/coral-xyz/anchor/issues/1828)).
- client: Add `transaction` functions to RequestBuilder
  ([#1958](https://github.com/coral-xyz/anchor/pull/1958)).
- spl: Add `create_metadata_accounts_v3` and `set_collection_size` wrappers
  ([#2119](https://github.com/coral-xyz/anchor/pull/2119)).
- spl: Add `MetadataAccount` account deserialization.
  ([#2014](https://github.com/coral-xyz/anchor/pull/2014)).
- spl: Add `update_primary_sale_happened_via_token` wrapper
  ([#2173](https://github.com/coral-xyz/anchor/pull/2173)).
- spl: Add `sign_metadata` and `remove_creator_verification` wrappers
  ([#2175](https://github.com/coral-xyz/anchor/pull/2175)).
- spl: Add `initialize_account3` and `initialize_mint2`
  ([#2265](https://github.com/coral-xyz/anchor/pull/2265)).
- spl: Change `serum-dex` to `openbook-dex`
  ([#2308](https://github.com/coral-xyz/anchor/pull/2308)).
- lang: Add parsing for consts from impl blocks for IDL PDA seeds generation
  ([#2128](https://github.com/coral-xyz/anchor/pull/2128)).
- lang: Account closing reassigns to system program and reallocates
  ([#2169](https://github.com/coral-xyz/anchor/pull/2169)).
- ts: Add coders for SPL programs
  ([#2143](https://github.com/coral-xyz/anchor/pull/2143)).
- ts: Add `has_one` relations inference so accounts mapped via has_one
  relationships no longer need to be provided
  ([#2160](https://github.com/coral-xyz/anchor/pull/2160)).
- ts: Add ability to set args after setting accounts and retrieving pubkeys
  ([#2160](https://github.com/coral-xyz/anchor/pull/2160)).
- ts: Add `.prepare()` to builder pattern
  ([#2160](https://github.com/coral-xyz/anchor/pull/2160)).
- spl: Add `freeze_delegated_account` and `thaw_delegated_account` wrappers
  ([#2164](https://github.com/coral-xyz/anchor/pull/2164)).
- ts: Add `feePayer` check to `AnchorProvider` methods, so that anchor writes
  the provider's wallet as fee payer if fee payer isn't already set
  ([#2186](https://github.com/coral-xyz/anchor/pull/2186)).
- ts: Add nested PDA inference
  ([#2194](https://github.com/coral-xyz/anchor/pull/2194)).
- ts: Add ability to resolve missing accounts with a custom resolver
  ([#2194](https://github.com/coral-xyz/anchor/pull/2194)).
- ts: Update the Solana web3 library used by anchor ts to version 1.64.0
  ([#2220](https://github.com/coral-xyz/anchor/issues/2220)).
- lang: Updates `AccountsClose` to make it safe to call manually
  ([#2209](https://github.com/coral-xyz/anchor/pull/2209)).
- lang: Update rust used in the repo version 1.62
  ([#2272](https://github.com/coral-xyz/anchor/pull/2272)).
- cli: Allow custom cluster config
  ([#2271](https://github.com/coral-xyz/anchor/pull/2271)).
- ts: Add optional flag to parseLogs to throw an error on decoding failure
  ([#2043](https://github.com/coral-xyz/anchor/pull/2043)).
- cli: Add `test.validator.geyser_plugin_config` support
  ([#2016](https://github.com/coral-xyz/anchor/pull/2016)).
- cli: Add `account` subcommand to cli
  ([#1923](https://github.com/coral-xyz/anchor/pull/1923))
- cli: Add `ticks_per_slot` option to Validator args
  ([#1875](https://github.com/coral-xyz/anchor/pull/1875)).

### Fixes

- lang: Fix parsing for bytes literals in the IDL
  ([#2261](https://github.com/coral-xyz/anchor/pull/2261)).
- lang: Fix IDL `seed` generation for byte string literals
  ([#2125](https://github.com/coral-xyz/anchor/pull/2125)).
- ts: Update seeds inference to allow nested user defined structs within the
  seeds ([#2198](https://github.com/coral-xyz/anchor/pull/2198)).
- event: Fix multiple event listeners with the same name
  ([#2165](https://github.com/coral-xyz/anchor/pull/2165)).
- lang: Prevent the payer account from being initialized as a program account
  ([#2284](https://github.com/coral-xyz/anchor/pull/2284)).
- ts: Fixing breaking change where null or undefined wallet throws an error
  ([#2303](https://github.com/coral-xyz/anchor/pull/2303)).
- ts: Fixed `.fetchNullable()` to be robust towards accounts only holding a
  balance ([#2301](https://github.com/coral-xyz/anchor/pull/2301)).
- lang: Only add public enums to the IDL
  ([#2309](https://github.com/coral-xyz/anchor/pull/2309)).
- lang: Fix heap intensive error mapping
  ([#2313](https://github.com/coral-xyz/anchor/pull/2313)).

### Breaking

- ts: SPL coders have been removed from the main Anchor package.
  ([#2155](https://github.com/coral-xyz/anchor/pull/2155))
- lang: Remove `rent` from constraints
  ([#2265](https://github.com/coral-xyz/anchor/pull/2265)).
- spl: Remove `rent` from `associated_token::Create`
  ([#2265](https://github.com/coral-xyz/anchor/pull/2265)).
- lang: Add `Discriminator` and `Owner` trait implementation for structures
  representing instructions
  ([#1997](https://github.com/coral-xyz/anchor/pull/1997)).
- ts: '@coral-xyz/borsh' package is now part of the yarn monorepo
  ([#2290](https://github.com/coral-xyz/anchor/pull/2290)). The borsh package
  needs to be built before the anchor package can be built but this should
  happen automatically when running `yarn build` in packages/anchor, see
  [#2299](https://github.com/coral-xyz/anchor/pull/2299) and
  [#2306](https://github.com/coral-xyz/anchor/pull/2306).
- lang: Add support for optionally passing in accounts using the syntax
  `Optional<Account<'info, T>>`. Shouldn't affect existing programs but may be a
  breaking change to tools that use the anchor generated IDL.
  [#2101](https://github.com/coral-xyz/anchor/pull/2101).
- ts: Switch from `@project-serum/anchor` to the `@coral-xyz/anchor` package
  [#2318](https://github.com/coral-xyz/anchor/pull/2318).

## [0.25.0] - 2022-07-05

### Features

- lang: Add `realloc`, `realloc::payer`, and `realloc::zero` as a new constraint
  group for program accounts
  ([#1986](https://github.com/coral-xyz/anchor/pull/1986)).
- lang: Add `PartialEq` and `Eq` for `anchor_lang::Error`
  ([#1544](https://github.com/coral-xyz/anchor/pull/1544)).
- cli: Add `--skip-build` to `anchor publish`
  ([#1786](https://github.com/coral-xyz/anchor/pull/1841)).
- cli: Add `--program-keypair` to `anchor deploy`
  ([#1786](https://github.com/coral-xyz/anchor/pull/1786)).
- cli: Add compilation optimizations to cli template
  ([#1807](https://github.com/coral-xyz/anchor/pull/1807)).
- cli: `build` now adds docs to idl. This can be turned off with `--no-docs`
  ([#1561](https://github.com/coral-xyz/anchor/pull/1561)).
- cli: Add `b` and `t` aliases for `build` and `test` respectively
  ([#1823](https://github.com/coral-xyz/anchor/pull/1823)).
- spl: Add more derived traits to `TokenAccount` to `Mint`
  ([#1818](https://github.com/coral-xyz/anchor/pull/1818)).
- spl: Add `sync_native` token program CPI wrapper function
  ([#1833](https://github.com/coral-xyz/anchor/pull/1833)).
- cli: Allow passing arguments to an underlying script with `anchor run`
  ([#1914](https://github.com/coral-xyz/anchor/pull/1914)).
- ts: Implement a coder for system program
  ([#1920](https://github.com/coral-xyz/anchor/pull/1920)).
- ts: Add `program.coder.types` for encoding/decoding user-defined types
  ([#1931](https://github.com/coral-xyz/anchor/pull/1931)).
- client: Add `send_with_spinner_and_config` function to RequestBuilder
  ([#1926](https://github.com/coral-xyz/anchor/pull/1926)).
- ts: Implement a coder for SPL associated token program
  ([#1939](https://github.com/coral-xyz/anchor/pull/1939)).
- ts: verbose error for missing `ANCHOR_WALLET` variable when using
  `NodeWallet.local()` ([#1958](https://github.com/coral-xyz/anchor/pull/1958)).
- ts: Add `MethodsBuilder#accountsStrict` for strict typing on ix account input
  ([#2019](https://github.com/coral-xyz/anchor/pull/2019)).
- Update solana dependencies to 1.10.29
  ([#2027](https://github.com/coral-xyz/anchor/pull/2027)).

### Fixes

- cli: Fix `anchor keys list` reading the `target` folder in the wrong path
  ([#2063](https://github.com/coral-xyz/anchor/pull/2063)).
- cli: Move `overflow-checks` into workspace `Cargo.toml` so that it will not be
  ignored by compiler ([#1806](https://github.com/coral-xyz/anchor/pull/1806)).
- lang: Fix missing account name information when deserialization fails when
  using `init` or `zero`
  ([#1800](https://github.com/coral-xyz/anchor/pull/1800)).
- ts: Expose the wallet's publickey on the Provider
  ([#1845](https://github.com/coral-xyz/anchor/pull/1845)).

### Breaking

- ts: Change `BROWSER` env variable to `ANCHOR_BROWSER`
  ([#1233](https://github.com/coral-xyz/anchor/pull/1233)).
- ts: Add transaction signature to `EventCallback` parameters
  ([#1851](https://github.com/coral-xyz/anchor/pull/1851)).
- ts: Change `EventParser#parseLogs` implementation to be a generator instead of
  callback function ([#2018](https://github.com/coral-xyz/anchor/pull/2018)).
- lang: Adds a new `&mut reallocs: BTreeSet<Pubkey>` argument to
  `Accounts::try_accounts`
  ([#1986](https://github.com/coral-xyz/anchor/pull/1986)).

## [0.24.2] - 2022-04-13

### Fixes

- lang: Fix `returns` being serialized as `null` instead of `undefined` in IDL
  ([#1782](https://github.com/coral-xyz/anchor/pull/1782)).

## [0.24.1] - 2022-04-12

### Fixes

- lang: Fix `anchor build` failing if `Test.toml` included a relative path that
  didn't exist yet because it's created by `anchor build`
  ([#1772](https://github.com/coral-xyz/anchor/pull/1772)).
- cli: Update js/ts template to use new `AnchorProvider` class
  ([#1770](https://github.com/coral-xyz/anchor/pull/1770)).

## [0.24.0] - 2022-04-12

### Features

- lang: Add support for multiple test suites with separate local validators
  ([#1681](https://github.com/coral-xyz/anchor/pull/1681)).
- lang: Add return values to CPI client
  ([#1598](https://github.com/coral-xyz/anchor/pull/1598)).
- ts: Add view functions
  ([#1695](https://github.com/coral-xyz/anchor/pull/1695)).
- avm: New `avm update` command to update the Anchor CLI to the latest version
  ([#1670](https://github.com/coral-xyz/anchor/pull/1670)).
- cli: Update js/ts templates to use new `program.methods` syntax
  ([#1732](https://github.com/coral-xyz/anchor/pull/1732)).
- cli: Workspaces created with `anchor init` now come with the `prettier`
  formatter and scripts included
  ([#1741](https://github.com/coral-xyz/anchor/pull/1741)).
- ts: Add `pubkeys` function to methods builder to get all instruction account
  addresses ([#1733](https://github.com/coral-xyz/anchor/pull/1733)).
- ts: Export `LangErrorCode` and `LangErrorMessage` from `error.ts`
  ([#1756](https://github.com/coral-xyz/anchor/pull/1756)).

### Fixes

- avm: `avm install` no longer downloads the version if already installed in the
  machine ([#1670](https://github.com/coral-xyz/anchor/pull/1670)).
- cli: make `anchor test` fail when used with `--skip-deploy` option and without
  `--skip-local-validator` option but there already is a running validator
  ([#1675](https://github.com/coral-xyz/anchor/pull/1675)).
- lang: Return proper error instead of panicking if account length is smaller
  than discriminator in functions of `(Account)Loader`
  ([#1678](https://github.com/coral-xyz/anchor/pull/1678)).
- cli: Add `@types/bn.js` to `devDependencies` in cli template
  ([#1712](https://github.com/coral-xyz/anchor/pull/1712)).
- ts: Event listener no longer crashes on Program Upgrade or any other
  unexpected log ([#1757](https://github.com/coral-xyz/anchor/pull/1757)).

### Breaking

- avm: `avm install` switches to the newly installed version after installation
  finishes ([#1670](https://github.com/coral-xyz/anchor/pull/1670)).
- spl: Re-export the `spl_token` crate
  ([#1665](https://github.com/coral-xyz/anchor/pull/1665)).
- lang, cli, spl: Update solana toolchain to v1.9.13
  ([#1653](https://github.com/coral-xyz/anchor/pull/1653) and
  [#1751](https://github.com/coral-xyz/anchor/pull/1751)).
- lang: `Program` type now deserializes `programdata_address` only on demand
  ([#1723](https://github.com/coral-xyz/anchor/pull/1723)).
- ts: Make `Provider` an interface and adjust its signatures and add
  `AnchorProvider` implementor class
  ([#1707](https://github.com/coral-xyz/anchor/pull/1707)).
- spl: Change "to" to "from" in `token::burn`
  ([#1080](https://github.com/coral-xyz/anchor/pull/1080)).

## [0.23.0] - 2022-03-20

### Features

- cli: Add `anchor clean` command that's the same as `cargo clean` but preserves
  keypairs inside `target/deploy`
  ([#1470](https://github.com/coral-xyz/anchor/issues/1470)).
- cli: Running `anchor init` now initializes a new git repository for the
  workspace. This can be disabled with the `--no-git` flag
  ([#1605](https://github.com/coral-xyz/anchor/pull/1605)).
- cli: Add support for `anchor idl fetch` to work outside anchor workspace
  ([#1509](https://github.com/coral-xyz/anchor/pull/1509)).
- cli: [[test.validator.clone]] also clones the program data account of programs
  owned by the bpf upgradeable loader
  ([#1481](https://github.com/coral-xyz/anchor/issues/1481)).
- lang: Add new `AccountSysvarMismatch` error code and test cases for sysvars
  ([#1535](https://github.com/coral-xyz/anchor/pull/1535)).
- lang: Replace `std::io::Cursor` with a custom `Write` impl that uses the
  Solana mem syscalls ([#1589](https://github.com/coral-xyz/anchor/pull/1589)).
- lang: Add `require_neq`, `require_keys_neq`, `require_gt`, and `require_gte`
  comparison macros ([#1622](https://github.com/coral-xyz/anchor/pull/1622)).
- lang: Handle arrays with const as size in instruction data
  ([#1623](https://github.com/coral-xyz/anchor/issues/1623).
- spl: Add support for revoke instruction
  ([#1493](https://github.com/coral-xyz/anchor/pull/1493)).
- ts: Add provider parameter to `Spl.token` factory method
  ([#1597](https://github.com/coral-xyz/anchor/pull/1597)).

### Fixes

- ts: Fix the loss of strict typing using the `methods` namespace on builder
  functions ([#1539](https://github.com/coral-xyz/anchor/pull/1539)).
- spl: Update `spl/governance` to use new errors
  ([#1582](https://github.com/coral-xyz/anchor/pull/1582)).
- client: Fix `Cluster`'s `FromStr` implementation
  ([#1362](https://github.com/coral-xyz/anchor/pull/1362)).
- lang: Implement `Key` for `Pubkey` again, so `associated_token::*` constraints
  can use pubkey targets again
  ([#1601](https://github.com/coral-xyz/anchor/pull/1601)).
- lang: Adjust error code so `#[error_code]` works with just importing
  `anchor_lang::error_code`
  ([#1610](https://github.com/coral-xyz/anchor/pull/1610)).
- ts: Fix `spl-token` coder account parsing
  ([#1604](https://github.com/coral-xyz/anchor/pull/1604)).
- cli: Fix `npm install` fallback if `yarn` install doesn't work
  ([#1643](https://github.com/coral-xyz/anchor/pull/1643)).
- lang: Fix bug where `owner = <target>` would not compile because of missing
  type annotation ([#1648](https://github.com/coral-xyz/anchor/pull/1648)).
- ts: Adjust `send` and `simulate` functions in `provider.ts`, so they use the
  return value of
  `Wallet.signTransaction`([#1527](https://github.com/coral-xyz/anchor/pull/1527)).

### Breaking

- ts: Mark `transaction`, `instruction`, `simulate` and `rpc` program namespaces
  as deprecated in favor of `methods`
  ([#1539](https://github.com/coral-xyz/anchor/pull/1539)).
- ts: No longer allow manual setting of globally resolvable program public keys
  in `methods#accounts()`.
  ([#1548][https://github.com/coral-xyz/anchor/pull/1548])
- lang/ts: Events are now emitted using the `sol_log_data` syscall
  ([#1608](https://github.com/coral-xyz/anchor/pull/1608)).
- lang: Remove space calculation using `#[derive(Default)]`
  ([#1519](https://github.com/coral-xyz/anchor/pull/1519)).
- lang: Add support for logging expected and actual values and pubkeys. Add
  `require_eq` and `require_keys_eq` macros. Add default error code to `require`
  macro ([#1572](https://github.com/coral-xyz/anchor/pull/1572)).
- lang: Add `system_program` CPI wrapper functions. Make `system_program` module
  public instead of re-exporting
  `system_program::System`([#1629](https://github.com/coral-xyz/anchor/pull/1629)).
- cli: `avm use` no long prompts [y/n] if an install is needed first - it just
  tells the user to `avm install`
  ([#1565](https://github.com/coral-xyz/anchor/pull/1565))
- ts: Add `AnchorError` with program stack and also a program stack for
  non-`AnchorError` errors
  ([#1640](https://github.com/coral-xyz/anchor/pull/1640)). `AnchorError` is not
  returned for `processed` tx that have `skipPreflight` set to `true` (it falls
  back to `ProgramError` or the raw solana library error).

## [0.22.1] - 2022-02-28

### Fixes

- cli: Fix rust template
  ([#1488](https://github.com/coral-xyz/anchor/pull/1488)).
- lang: Handle array sizes with variable sizes in events and array size casting
  in IDL parsing ([#1485](https://github.com/coral-xyz/anchor/pull/1485))

## [0.22.0] - 2022-02-20

### Features

- lang: Add check that declared id == program id
  ([#1451](https://github.com/coral-xyz/anchor/pull/1451)).
- ts: Added float types support
  ([#1425](https://github.com/coral-xyz/anchor/pull/1425)).
- cli: Add `--skip-lint` option to disable check linting introduced in
  ([#1452](https://github.com/coral-xyz/anchor/pull/1452)) for rapid prototyping
  ([#1482](https://github.com/coral-xyz/anchor/pull/1482)).

### Fixes

- ts: Allow nullable types for `Option<T>` mapped types
  ([#1428](https://github.com/coral-xyz/anchor/pull/1428)).

### Breaking

- lang: Enforce that the payer for an init-ed account be marked `mut`
  ([#1271](https://github.com/coral-xyz/anchor/pull/1271)).
- lang: All error-related code is now in the error module
  ([#1426](https://github.com/coral-xyz/anchor/pull/1426)).
- lang: Require doc comments when using AccountInfo or UncheckedAccount types
  ([#1452](https://github.com/coral-xyz/anchor/pull/1452)).
- lang: add
  [`error!`](https://docs.rs/anchor-lang/latest/anchor_lang/prelude/macro.error.html)
  and
  [`err!`](https://docs.rs/anchor-lang/latest/anchor_lang/prelude/macro.err.html)
  macro and `Result` type
  ([#1462](https://github.com/coral-xyz/anchor/pull/1462)). This change will
  break most programs. Do the following to upgrade: _ change all
  `ProgramResult`'s to `Result<()>` _ change `#[error]` to `#[error_code]` _
  change all `Err(MyError::SomeError.into())` to
  `Err(error!(MyError::SomeError))` and all
  `Err(ProgramError::SomeProgramError)` to
  `Err(ProgramError::SomeProgramError.into())` or
  `Err(Error::from(ProgramError::SomeProgramError).with_source(source!()))` to
  provide file and line source of the error (`with_source` is most useful with
  `ProgramError`s. `error!` already adds source information for custom and
  anchor internal errors). _ change all `solana_program::program::invoke()` to
  `solana_program::program::invoke().map_err(Into::into)` and
  `solana_program::program::invoke_signed()` to
  `solana_program::program::invoke_signed().map_err(Into::into)`

## [0.21.0] - 2022-02-07

### Fixes

- ts: Fix the root type declaration of the `Wallet` / `NodeWallet` class
  ([#1363](https://github.com/coral-xyz/anchor/pull/1363)).
- ts: Improve type mapping of Account fields into Typescript with additional
  support for `Option<T>` and `Vec<String>` types
  ([#1393](https://github.com/coral-xyz/anchor/pull/1393)).

### Features

- lang: Add `seeds::program` constraint for specifying which program_id to use
  when deriving PDAs ([#1197](https://github.com/coral-xyz/anchor/pull/1197)).
- lang: `Context` now has a new `bumps: BTree<String, u8>` argument, mapping
  account name to bump seed "found" by the accounts context. This allows one to
  access bump seeds without having to pass them in from the client or
  recalculate them in the handler
  ([#1367](https://github.com/coral-xyz/anchor/pull/1367)).
- lang, ts: Automatically infer PDA addresses
  ([#1331](https://github.com/coral-xyz/anchor/pull/1331)).
- ts: Remove error logging in the event parser when log websocket encounters a
  program error ([#1313](https://github.com/coral-xyz/anchor/pull/1313)).
- ts: Add new `methods` namespace to the program client, introducing a more
  ergonomic builder API
  ([#1324](https://github.com/coral-xyz/anchor/pull/1324)).
- ts: Add registry utility for fetching the latest verified build
  ([#1371](https://github.com/coral-xyz/anchor/pull/1371)).
- cli: Expose the solana-test-validator --account flag in Anchor.toml via
  [[test.validator.account]]
  ([#1366](https://github.com/coral-xyz/anchor/pull/1366)).
- cli: Add avm, a tool for managing anchor-cli versions
  ([#1385](https://github.com/coral-xyz/anchor/pull/1385)).

### Breaking

- lang: Put `init_if_needed` behind a feature flag to decrease wrong usage
  ([#1258](https://github.com/coral-xyz/anchor/pull/1258)).
- lang: rename `loader_account` module to `account_loader` module
  ([#1279](https://github.com/coral-xyz/anchor/pull/1279))
- lang: The `Accounts` trait's `try_accounts` method now has an additional
  `bumps: &mut BTreeMap<String, u8>` argument, which accumulates bump seeds
  ([#1367](https://github.com/coral-xyz/anchor/pull/1367)).
- lang: Providing `bump = <target>` targets with `init` will now error. On
  `init` only, it is required to use `bump` without a target and access the seed
  inside function handlers via `ctx.bumps.get("<pda-account-name")`. For
  subsequent seeds constraints (without init), it is recommended to store the
  bump on your account and use it as a `bump = <target>` target to minimize
  compute units used ([#1380](https://github.com/coral-xyz/anchor/pull/1380)).
- ts: `Coder` is now an interface and the existing class has been renamed to
  `BorshCoder`. This change allows the generation of Anchor clients for non
  anchor programs
  ([#1259](https://github.com/coral-xyz/anchor/pull/1259/files)).
- cli: [[test.clone]] key in Anchor.toml is renamed to [[test.validator.clone]]
  ([#1366](https://github.com/coral-xyz/anchor/pull/1366)).

## [0.20.1] - 2022-01-09

### Fixes

- lang: Improved error msgs when required programs are missing when using the
  `init` constraint([#1257](https://github.com/coral-xyz/anchor/pull/1257))

### Features

- lang: Allow repr overrides for zero copy accounts
  ([#1273](https://github.com/coral-xyz/anchor/pull/1273)).

## [0.20.0] - 2022-01-06

### Fixes

- lang: `init_if_needed` now checks rent exemption when init is not needed
  ([#1250](https://github.com/coral-xyz/anchor/pull/1250)).
- lang: Add missing owner check when `associated_token::authority` is used
  ([#1240](https://github.com/coral-xyz/anchor/pull/1240)).
- ts: Add type declarations for conditional `workspace` and `Wallet` exports
  ([#1137](https://github.com/coral-xyz/anchor/pull/1137)).
- ts: Change commitment message `recent` to `processed` and `max` to `finalized`
  ([#1128](https://github.com/coral-xyz/anchor/pull/1128))
- ts: fix `translateAddress` which currently leads to failing browser code. Now
  uses `PublicKey` constructor instead of prototype chain constructor name
  checking which doesn't work in the presence of code
  minifying/mangling([#1138](https://github.com/coral-xyz/anchor/pull/1138))
- lang: add missing check that verifies that account is ATA when using
  `init_if_needed` and init is not
  needed([#1221](https://github.com/coral-xyz/anchor/pull/1221))

### Features

- lang: Add `programdata_address: Option<Pubkey>` field to `Program` account.
  Will be populated if account is a program owned by the upgradable bpf loader
  ([#1125](https://github.com/coral-xyz/anchor/pull/1125))
- lang,ts,ci,cli,docs: update solana toolchain to version
  1.8.5([#1133](https://github.com/coral-xyz/anchor/pull/1133)).
- lang: Account wrappers for non-Anchor programs no longer have to implement the
  `serialize` function because it has a default impl now. Similarly, they no
  longer have to implement `try_deserialize` which now delegates to
  `try_deserialize_unchecked` by
  default([#1156](https://github.com/coral-xyz/anchor/pull/1156)).
- lang: Add `set_inner` method to `Account<'a, T>` to enable easy updates
  ([#1177](https://github.com/coral-xyz/anchor/pull/1177)).
- lang: Handle arrays with const as length
  ([#968](https://github.com/coral-xyz/anchor/pull/968)).
- ts: Add optional commitment argument to `fetch` and `fetchMultiple`
  ([#1171](https://github.com/coral-xyz/anchor/pull/1171)).
- lang: Implement `AsRef<T>` for
  `Account<'a, T>`([#1173](https://github.com/coral-xyz/anchor/pull/1173))
- cli: Add `anchor expand` command which wraps around `cargo expand`
  ([#1160](https://github.com/coral-xyz/anchor/pull/1160))

### Breaking

- client: Client::new and Client::new_with_options now accept `Rc<dyn Signer>`
  instead of `Keypair` ([#975](https://github.com/coral-xyz/anchor/pull/975)).
- lang, ts: Change error enum name and message for 'wrong program ownership'
  account validation ([#1154](https://github.com/coral-xyz/anchor/pull/1154)).
- lang: Change from `#[repr(packed)]` to `#[repr(C)]` for zero copy accounts
  ([#1106](https://github.com/coral-xyz/anchor/pull/1106)).
- lang: Account types can now be found either in the `prelude` module or the
  `accounts` module but not longer directly under the root. Deprecated account
  types are no longer imported by the prelude
  ([#1208](https://github.com/coral-xyz/anchor/pull/1208)).

## [0.19.0] - 2021-12-08

### Fixes

- lang: Add `deprecated` attribute to `ProgramAccount`
  ([#1014](https://github.com/coral-xyz/anchor/pull/1014)).
- cli: Add version number from programs `Cargo.toml` into extracted IDL
  ([#1061](https://github.com/coral-xyz/anchor/pull/1061)).
- lang: Add `deprecated` attribute to
  `Loader`([#1078](https://github.com/coral-xyz/anchor/pull/1078)).
- lang: the `init_if_needed` attribute now checks that given attributes (e.g.
  space, owner, token::authority etc.) are validated even when init is not
  needed ([#1096](https://github.com/coral-xyz/anchor/pull/1096)).

### Features

- lang: Add `ErrorCode::AccountNotInitialized` error to separate the situation
  when the account has the wrong owner from when it does not exist
  (#[1024](https://github.com/coral-xyz/anchor/pull/1024)).
- lang: Called instructions now log their name by default. This can be turned
  off with the `no-log-ix-name` flag
  ([#1057](https://github.com/coral-xyz/anchor/pull/1057)).
- lang: `ProgramData` and `UpgradableLoaderState` can now be passed into
  `Account` as generics. see
  [UpgradeableLoaderState](https://docs.rs/solana-program/latest/solana_program/bpf_loader_upgradeable/enum.UpgradeableLoaderState.html).
  `UpgradableLoaderState` can also be matched on to get `ProgramData`, but when
  `ProgramData` is used instead, anchor does the serialization and checking that
  it is actually program data for you
  ([#1095](https://github.com/coral-xyz/anchor/pull/1095)).
- ts: Add better error msgs in the ts client if something wrong (i.e. not a
  pubkey or a string) is passed in as an account in an instruction accounts
  object ([#1098](https://github.com/coral-xyz/anchor/pull/1098)).
- ts: Add inputs `postInstructions` and `preInstructions` as a replacement for
  (the now deprecated) `instructions`
  ([#1007](https://github.com/coral-xyz/anchor/pull/1007)).
- ts: Add `getAccountInfo` helper method to account namespace/client
  ([#1084](https://github.com/coral-xyz/anchor/pull/1084)).

### Breaking

- lang, ts: Error codes have been mapped to new numbers to allow for more errors
  per namespace ([#1096](https://github.com/coral-xyz/anchor/pull/1096)).

## [0.18.2] - 2021-11-14

- cli: Replace global JavaScript dependency installs with local.

### Features

- lang: Add `SystemAccount<'info>` account type for generic wallet addresses or
  accounts owned by the system program
  ([#954](https://github.com/coral-xyz/anchor/pull/954))

### Fixes

- cli: fix dns in NODE_OPTIONS
  ([#928](https://github.com/coral-xyz/anchor/pull/928)).
- cli: output TypeScript IDL in `idl parse` subcommand
  ([#941](https://github.com/coral-xyz/anchor/pull/941)).
- cli: Add fields `os` and `cpu` to npm package `@project-serum/anchor-cli`
  ([#976](https://github.com/coral-xyz/anchor/pull/976)).
- cli: Allow specify output directory for TypeScript IDL
  ([#940](https://github.com/coral-xyz/anchor/pull/940)).

### Breaking

- spl: Move permissioned markets into dex repository
  ([#962](https://github.com/coral-xyz/anchor/pull/962)).

## [0.18.0] - 2021-10-24

### Features

- cli: Add support for configuration options for `solana-test-validator` in
  Anchor.toml ([#834](https://github.com/coral-xyz/anchor/pull/834)).
- cli: `target/types` directory now created on build to store a TypeScript types
  file for each program's IDL
  ([#795](https://github.com/coral-xyz/anchor/pull/795)).
- ts: `Program<T>` can now be typed with an IDL type
  ([#795](https://github.com/coral-xyz/anchor/pull/795)).
- lang: Add `mint::freeze_authority` keyword for mint initialization within
  `#[derive(Accounts)]` ([#835](https://github.com/coral-xyz/anchor/pull/835)).
- lang: Add `AccountLoader` type for `zero_copy` accounts with support for CPI
  ([#792](https://github.com/coral-xyz/anchor/pull/792)).
- lang: Add `#[account(init_if_needed)]` keyword for allowing one to invoke the
  same instruction even if the account was created already
  ([#906](https://github.com/coral-xyz/anchor/pull/906)).
- lang: Add custom errors support for raw constraints
  ([#905](https://github.com/coral-xyz/anchor/pull/905)).
- lang, cli, spl: Update solana toolchain to v1.8.0
  ([#886](https://github.com/coral-xyz/anchor/pull/886)).
- lang: Add custom errors support for `signer`, `mut`, `has_one`, `owner`, raw
  constraints and `address`
  ([#905](https://github.com/coral-xyz/anchor/pull/905),
  [#913](https://github.com/coral-xyz/anchor/pull/913)).

### Breaking

- lang: Accounts marked with the `#[account(signer)]` constraint now enforce
  signer when the `"cpi"` feature is enabled
  ([#849](https://github.com/coral-xyz/anchor/pull/849)).

## [0.17.0] - 2021-10-03

### Features

- cli: Add `localnet` command for starting a local `solana-test-validator` with
  the workspace deployed ([#820](https://github.com/coral-xyz/anchor/pull/820)).

### Breaking

- `CpiContext` accounts must now be used with the accounts struct generated in
  the `crate::cpi::accounts::*` module. These structs correspond to the accounts
  context for each instruction, except that each field is of type `AccountInfo`
  ([#824](https://github.com/coral-xyz/anchor/pull/824)).

## [0.16.2] - 2021-09-27

### Features

- lang: Add `--detach` flag to `anchor test`
  ([#770](https://github.com/coral-xyz/anchor/pull/770)).
- lang: Add `associated_token` keyword for initializing associated token
  accounts within `#[derive(Accounts)]`
  ([#790](https://github.com/coral-xyz/anchor/pull/790)).
- cli: Allow passing through cargo flags for build command
  ([#719](https://github.com/coral-xyz/anchor/pull/719)).
- cli: Allow passing through cargo flags for test, verify, and publish commands
  ([#804](https://github.com/coral-xyz/anchor/pull/804)).

### Fixes

- lang: Generated `AccountMeta`s for Rust clients now properly set the
  `isSigner` field ([#762](https://github.com/coral-xyz/anchor/pull/762)).

## [0.16.1] - 2021-09-17

### Fixes

- lang: `Signer` type now sets isSigner to true in the IDL
  ([#750](https://github.com/coral-xyz/anchor/pull/750)).

## [0.16.0] - 2021-09-16

### Features

- lang: `Program` type introduced for executable accounts
  ([#705](https://github.com/coral-xyz/anchor/pull/705)).
- lang: `Signer` type introduced for signing accounts where data is not used
  ([#705](https://github.com/coral-xyz/anchor/pull/705)).
- lang: `UncheckedAccount` type introduced as a preferred alias for
  `AccountInfo` ([#745](https://github.com/coral-xyz/anchor/pull/745)).

### Breaking Changes

- lang: `#[account(owner = <pubkey>)]` now requires a `Pubkey` instead of an
  account ([#691](https://github.com/coral-xyz/anchor/pull/691)).

## [0.15.0] - 2021-09-07

### Features

- lang: Add new `Account` type to replace `ProgramAccount` and `CpiAccount`,
  both of which are deprecated
  ([#686](https://github.com/coral-xyz/anchor/pull/686)).
- lang: `Box` can be used with `Account` types to reduce stack usage
  ([#686](https://github.com/coral-xyz/anchor/pull/686)).
- lang: Add `Owner` trait, which is automatically implemented by all
  `#[account]` structs ([#686](https://github.com/coral-xyz/anchor/pull/686)).
- lang: Check that ProgramAccount writable before mut borrow (`anchor-debug`
  only) ([#681](https://github.com/coral-xyz/anchor/pull/681)).

### Breaking Changes

- lang: All programs must now define their program id in source via
  `declare_id!` ([#686](https://github.com/coral-xyz/anchor/pull/686)).

## [0.14.0] - 2021-09-02

### Features

- lang: Ignore `Unnamed` structs instead of panic
  ([#605](https://github.com/coral-xyz/anchor/pull/605)).
- lang: Add constraints for initializing mint accounts as pdas,
  `#[account(init, seeds = [...], mint::decimals = <expr>, mint::authority = <expr>)]`
  ([#562](https://github.com/coral-xyz/anchor/pull/562)).
- lang: Add `AsRef<AccountInfo>` for `AccountInfo` wrappers
  ([#652](https://github.com/coral-xyz/anchor/pull/652)).
- lang: Optimize `trait Key` by removing `AccountInfo` cloning
  ([#652](https://github.com/coral-xyz/anchor/pull/652)).
- cli, client, lang: Update solana toolchain to v1.7.11
  ([#653](https://github.com/coral-xyz/anchor/pull/653)).

### Breaking Changes

- lang: Change
  `#[account(init, seeds = [...], token = <expr>, authority = <expr>)]` to
  `#[account(init, token::mint = <expr> token::authority = <expr>)]`
  ([#562](https://github.com/coral-xyz/anchor/pull/562)).
- lang: `#[associated]` and `#[account(associated = <target>, with = <target>)]`
  are both removed ([#612](https://github.com/coral-xyz/anchor/pull/612)).
- cli: Removed `anchor launch` command
  ([#634](https://github.com/coral-xyz/anchor/pull/634)).
- lang: `#[account(init)]` now creates the account inside the same instruction
  to be consistent with initializing PDAs. To maintain the old behavior of
  `init`, replace it with `#[account(zero)]`
  ([#641](https://github.com/coral-xyz/anchor/pull/641)).
- lang: `bump` must be provided when using the `seeds` constraint. This has been
  added as an extra safety constraint to ensure that whenever a PDA is
  initialized via a constraint the bump used is the one created by
  `Pubkey::find_program_address`
  ([#641](https://github.com/coral-xyz/anchor/pull/641)).
- lang: `try_from_init` has been removed from `Loader`, `ProgramAccount`, and
  `CpiAccount` and replaced with `try_from_unchecked`
  ([#641](https://github.com/coral-xyz/anchor/pull/641)).
- lang: Remove `AccountsInit` trait
  ([#641](https://github.com/coral-xyz/anchor/pull/641)).
- lang: `try_from` methods for `ProgramAccount`, `Loader`, and `ProgramState`
  now take in an additional `program_id: &Pubkey` parameter
  ([#660](https://github.com/coral-xyz/anchor/pull/660)).

## [0.13.2] - 2021-08-11

### Fixes

- cli: Fix `anchor init` command "Workspace not found" regression
  ([#598](https://github.com/coral-xyz/anchor/pull/598)).

## [0.13.1] - 2021-08-10

### Features

- cli: Programs embedded into genesis during tests will produce program logs
  ([#594](https://github.com/coral-xyz/anchor/pull/594)).

### Fixes

- cli: Allows Cargo.lock to exist in workspace subdirectories when publishing
  ([#593](https://github.com/coral-xyz/anchor/pull/593)).

## [0.13.0] - 2021-08-08

### Features

- cli: Adds a `[registry]` section in the Anchor toml
  ([#570](https://github.com/coral-xyz/anchor/pull/570)).
- cli: Adds the `anchor login <api-token>` command
  ([#570](https://github.com/coral-xyz/anchor/pull/570)).
- cli: Adds the `anchor publish <package>` command
  ([#570](https://github.com/coral-xyz/anchor/pull/570)).
- cli: Adds a root level `anchor_version` field to the Anchor.toml for
  specifying the anchor docker image to use for verifiable builds
  ([#570](https://github.com/coral-xyz/anchor/pull/570)).
- cli: Adds a root level `solana_version` field to the Anchor.toml for
  specifying the solana toolchain to use for verifiable builds
  ([#570](https://github.com/coral-xyz/anchor/pull/570)).
- lang: Dynamically fetch rent sysvar for when using `init`
  ([#587](https://github.com/coral-xyz/anchor/pull/587)).

### Breaking

- cli: `[clusters.<network>]` Anchor.toml section has been renamed to
  `[programs.<network>]` ([#570](https://github.com/coral-xyz/anchor/pull/570)).
- cli: `[workspace]` member and exclude arrays must now be filepaths relative to
  the workspace root ([#570](https://github.com/coral-xyz/anchor/pull/570)).

## [0.12.0] - 2021-08-03

### Features

- cli: Add keys `members` / `exclude` in config `programs` section
  ([#546](https://github.com/coral-xyz/anchor/pull/546)).
- cli: Allow program address configuration for test command through
  `clusters.localnet` ([#554](https://github.com/coral-xyz/anchor/pull/554)).
- lang: IDLs are now parsed from the entire crate
  ([#517](https://github.com/coral-xyz/anchor/pull/517)).
- spl: Dex permissioned markets proxy
  ([#519](https://github.com/coral-xyz/anchor/pull/519),
  [#543](https://github.com/coral-xyz/anchor/pull/543)).

### Breaking Changes

- ts: Use `hex` by default for decoding Instruction
  ([#547](https://github.com/coral-xyz/anchor/pull/547)).
- lang: `CpiAccount::reload` mutates the existing struct instead of returning a
  new one ([#526](https://github.com/coral-xyz/anchor/pull/526)).
- cli: Anchor.toml now requires an explicit `[scripts]` test command
  ([#550](https://github.com/coral-xyz/anchor/pull/550)).

## [0.11.1] - 2021-07-09

### Features

- lang: Adds `require` macro for specifying assertions that return error codes
  on failure ([#483](https://github.com/coral-xyz/anchor/pull/483)).
- lang: Allow one to specify arbitrary programs as the owner when creating PDA
  ([#483](https://github.com/coral-xyz/anchor/pull/483)).
- lang: A new `bump` keyword is added to the accounts constraints, which is used
  to add an optional bump seed to the end of a `seeds` array. When used in
  conjunction with _both_ `init` and `seeds`, then the program executes
  `find_program_address` to assert that the given bump is the canonical bump
  ([#483](https://github.com/coral-xyz/anchor/pull/483)).

### Fixes

- lang: Preserve all instruction data for fallback functions
  ([#483](https://github.com/coral-xyz/anchor/pull/483)).
- ts: Event listener not firing when creating associated accounts
  ([#356](https://github.com/coral-xyz/anchor/issues/356)).

## [0.11.0] - 2021-07-03

### Features

- lang: Add fallback functions
  ([#457](https://github.com/coral-xyz/anchor/pull/457)).
- lang: Add feature flag for using the old state account discriminator. This is
  a temporary flag for those with programs built prior to v0.7.0 but want to use
  the latest Anchor version. Expect this to be removed in a future version
  ([#446](https://github.com/coral-xyz/anchor/pull/446)).
- lang: Add generic support to Accounts
  ([#496](https://github.com/coral-xyz/anchor/pull/496)).

### Breaking Changes

- cli: Remove `.spec` suffix on TypeScript tests files
  ([#441](https://github.com/coral-xyz/anchor/pull/441)).
- lang: Remove `belongs_to` constraint
  ([#459](https://github.com/coral-xyz/anchor/pull/459)).

## [0.10.0] - 2021-06-27

### Features

- lang: Add `#[account(address = <expr>)]` constraint for asserting the address
  of an account ([#400](https://github.com/coral-xyz/anchor/pull/400)).
- lang: Add
  `#[account(init, token = <mint-target>, authority = <token-owner-target>...)]`
  constraint for initializing SPL token accounts as program derived addresses
  for the program. Can be used when initialized via `seeds` or `associated`
  ([#400](https://github.com/coral-xyz/anchor/pull/400)).
- lang: Add `associated_seeds!` macro for generating signer seeds for CPIs
  signed by an `#[account(associated = <target>)]` account
  ([#400](https://github.com/coral-xyz/anchor/pull/400)).
- cli: Add `[scripts]` section to the Anchor.toml for specifying workspace
  scripts that can be run via `anchor run <script>`
  ([#400](https://github.com/coral-xyz/anchor/pull/400)).
- cli: `[clusters.<network>]` table entries can now also use
  `{ address = <base58-str>, idl = <filepath-str> }` to specify workspace
  programs ([#400](https://github.com/coral-xyz/anchor/pull/400)).

### Breaking Changes

- cli: Remove `--yarn` flag in favor of using `npx`
  ([#432](https://github.com/coral-xyz/anchor/pull/432)).

## [0.9.0] - 2021-06-15

### Features

- lang: Instruction data is now available to accounts constraints
  ([#386](https://github.com/coral-xyz/anchor/pull/386)).
- lang: Initialize program derived addresses with accounts constraints
  ([#386](https://github.com/coral-xyz/anchor/pull/386)).

### Breaking Changes

- lang: Event field names in IDLs are now mixed case.
  ([#379](https://github.com/coral-xyz/anchor/pull/379)).
- lang: Accounts trait now accepts an additional `&[u8]` parameter
  ([#386](https://github.com/coral-xyz/anchor/pull/386)).

## [0.8.0] - 2021-06-10

### Features

- cli: Add `--program-name` option for build command to build a single program
  at a time ([#362](https://github.com/coral-xyz/anchor/pull/362)).
- cli, client: Parse custom cluster urls from str
  ([#369](https://github.com/coral-xyz/anchor/pull/369)).
- cli, client, lang: Update solana toolchain to v1.7.1
  ([#368](https://github.com/coral-xyz/anchor/pull/369)).
- ts: Instruction decoding and formatting
  ([#372](https://github.com/coral-xyz/anchor/pull/372)).
- lang: Add `#[account(close = <destination>)]` constraint for closing accounts
  and sending the rent exemption lamports to a specified destination account
  ([#371](https://github.com/coral-xyz/anchor/pull/371)).

### Fixes

- lang: Allows one to use `remaining_accounts` with `CpiContext` by implementing
  the `ToAccountMetas` trait on `CpiContext`
  ([#351](https://github.com/coral-xyz/anchor/pull/351/files)).

### Breaking

- lang, ts: Framework defined error codes are introduced, reserving error codes
  0-300 for Anchor, and 300 and up for user defined error codes
  ([#354](https://github.com/coral-xyz/anchor/pull/354)).

## [0.7.0] - 2021-05-31

### Features

- cli: Add global options for override Anchor.toml values
  ([#313](https://github.com/coral-xyz/anchor/pull/313)).
- spl: Add `SetAuthority` instruction
  ([#307](https://github.com/coral-xyz/anchor/pull/307/files)).
- spl: Add init and close open orders instructions
  ([#245](https://github.com/coral-xyz/anchor/pull/245)).
- lang: `constraint = <expression>` added as a replacement for (the now
  deprecated) string literal constraints
  ([#341](https://github.com/coral-xyz/anchor/pull/341)).
- lang: Span information is now preserved, providing informative compiler error
  messages ([#341](https://github.com/coral-xyz/anchor/pull/341)).
- ts: Address metadata is now optional for `anchor.workspace` clients
  ([#310](https://github.com/coral-xyz/anchor/pull/310)).

### Breaking Changes

- ts: Retrieving deserialized accounts from the `<program>.account.<my-account>`
  and `<program>.state` namespaces now require explicitly invoking the `fetch`
  API. For example, `program.account.myAccount(<address>)` and `program.state()`
  is now `program.account.myAccount.fetch(<address>)` and
  `program.state.fetch()`
  ([#322](https://github.com/coral-xyz/anchor/pull/322)).
- lang: `#[account(associated)]` now requires `init` to be provided to create an
  associated account. If not provided, then the address will be assumed to
  exist, and a constraint will be added to ensure the correctness of the address
  ([#318](https://github.com/coral-xyz/anchor/pull/318)).
- lang, ts: Change account discriminator pre-image of the `#[state]` account
  discriminator to be namespaced by "state:"
  ([#320](https://github.com/coral-xyz/anchor/pull/320)).
- lang, ts: Change domain delimiters for the pre-image of the instruction
  sighash to be a single colon `:` to be consistent with accounts
  ([#321](https://github.com/coral-xyz/anchor/pull/321)).
- lang: Associated constraints no longer automatically implement `mut`
  ([#341](https://github.com/coral-xyz/anchor/pull/341)).
- lang: Associated `space` constraints must now be literal integers instead of
  literal strings ([#341](https://github.com/coral-xyz/anchor/pull/341)).

## [0.6.0] - 2021-05-23

### Features

- ts: Add `program.simulate` namespace
  ([#266](https://github.com/coral-xyz/anchor/pull/266)).
- ts: Introduce `Address` type, allowing one to use Base 58 encoded strings in
  public APIs ([#304](https://github.com/coral-xyz/anchor/pull/304)).
- ts: Replace deprecated `web3.Account` with `web3.Signer` in public APIs
  ([#296](https://github.com/coral-xyz/anchor/pull/296)).
- ts: Generated `anchor.workspace` clients can now be customized per network
  with `[cluster.<slug>]` in the Anchor.toml
  ([#308](https://github.com/coral-xyz/anchor/pull/308)).
- cli: Add yarn flag to test command
  ([#267](https://github.com/coral-xyz/anchor/pull/267)).
- cli: Add `--skip-build` flag to test command
  ([301](https://github.com/coral-xyz/anchor/pull/301)).
- cli: Add `anchor shell` command to spawn a node shell populated with an
  Anchor.toml based environment
  ([#303](https://github.com/coral-xyz/anchor/pull/303)).

### Breaking Changes

- cli: The Anchor.toml's `wallet` and `cluster` settings must now be under the
  `[provider]` table ([#305](https://github.com/coral-xyz/anchor/pull/305)).
- ts: Event coder `decode` API changed to decode strings directly instead of
  buffers ([#292](https://github.com/coral-xyz/anchor/pull/292)).
- ts: Event coder `encode` API removed
  ([#292](https://github.com/coral-xyz/anchor/pull/292)).

## [0.5.0] - 2021-05-07

### Features

- client: Adds support for state instructions
  ([#248](https://github.com/coral-xyz/anchor/pull/248)).
- lang: Add `anchor-debug` feature flag for logging
  ([#253](https://github.com/coral-xyz/anchor/pull/253)).
- ts: Add support for u16
  ([#255](https://github.com/coral-xyz/anchor/pull/255)).

### Breaking Changes

- client: Renames `RequestBuilder::new` to `RequestBuilder::from`
  ([#248](https://github.com/coral-xyz/anchor/pull/248)).
- lang: Renames the generated `instruction::state::Ctor` struct to
  `instruction::state::New`
  ([#248](https://github.com/coral-xyz/anchor/pull/248)).

## [0.4.5] - 2021-04-29

- spl: Add serum DEX CPI client
  ([#224](https://github.com/coral-xyz/anchor/pull/224)).

## [0.4.4] - 2021-04-18

### Features

- lang: Allows one to specify multiple `with` targets when creating associated
  accounts ([#197](https://github.com/coral-xyz/anchor/pull/197)).
- lang, ts: Add array support
  ([#202](https://github.com/coral-xyz/anchor/pull/202)).
- lang: Zero copy deserialization for accounts
  ([#202](https://github.com/coral-xyz/anchor/pull/202),
  [#206](https://github.com/coral-xyz/anchor/pull/206)).
- lang, spl, cli, client: Upgrade solana toolchain to 1.6.6
  ([#210](https://github.com/coral-xyz/anchor/pull/210)).

## [0.4.3] - 2021-04-13

### Features

- lang: CPI clients for program state instructions
  ([#43](https://github.com/coral-xyz/anchor/pull/43)).
- lang: Add `#[account(owner = <program>)]` constraint
  ([#178](https://github.com/coral-xyz/anchor/pull/178)).
- lang, cli, ts: Add `#[account(associated = <target>)]` and `#[associated]`
  attributes for creating associated program accounts within programs. The
  TypeScript package can fetch these accounts with a new
  `<program>.account.<account-name>.associated` (and `associatedAddress`) method
  ([#186](https://github.com/coral-xyz/anchor/pull/186)).

### Fixes

- lang: Unused `#[account]`s are now parsed into the IDL correctly
  ([#177](https://github.com/coral-xyz/anchor/pull/177)).

## [0.4.2] - 2021-04-10

### Features

- cli: Fund Anchor.toml configured wallet when testing
  ([#164](https://github.com/coral-xyz/anchor/pull/164)).
- spl: Add initialize_account instruction for spl tokens
  ([#166](https://github.com/coral-xyz/anchor/pull/166)).

## [0.4.1] - 2021-04-06

- cli: Version verifiable docker builder
  ([#145](https://github.com/coral-xyz/anchor/pull/145)).

## [0.4.0] - 2021-04-04

### Features

- cli: Specify test files to run
  ([#118](https://github.com/coral-xyz/anchor/pull/118)).
- lang: Allow overriding the `#[state]` account's size
  ([#121](https://github.com/coral-xyz/anchor/pull/121)).
- lang, client, ts: Add event emission and subscriptions
  ([#89](https://github.com/coral-xyz/anchor/pull/89)).
- lang/account: Allow namespacing account discriminators
  ([#128](https://github.com/coral-xyz/anchor/pull/128)).
- cli: TypeScript migrations
  ([#132](https://github.com/coral-xyz/anchor/pull/132)).
- lang: Add `#[account(executable)]` attribute
  ([#140](https://github.com/coral-xyz/anchor/pull/140)).

### Breaking Changes

- client: Replace url str with `Cluster` struct when constructing clients
  ([#89](https://github.com/coral-xyz/anchor/pull/89)).
- lang: Changes the account discriminator of `IdlAccount` to be namespaced by
  `"internal"` ([#128](https://github.com/coral-xyz/anchor/pull/128)).
- lang, spl, cli: Upgrade solana toolchain to 1.6.3, a major version upgrade
  even though only the minor version is incremented. This allows for the removal
  of `-#![feature(proc_macro_hygiene)]`.
  ([#139](https://github.com/coral-xyz/anchor/pull/139)).

## [0.3.0] - 2021-03-12

### Features

- ts: Allow preloading instructions for state rpc transactions
  ([cf9c84](https://github.com/coral-xyz/anchor/commit/cf9c847e4144989b5bc1936149d171e90204777b)).
- ts: Export sighash coder function
  ([734c75](https://github.com/coral-xyz/anchor/commit/734c751882f43beec7ea3f0f4d988b502e3f24e4)).
- cli: Specify programs to embed into local validator genesis via Anchor.toml
  while testing
  ([b3803a](https://github.com/coral-xyz/anchor/commit/b3803aec03fbbae1a794c9aa6a789e6cb58fda99)).
- cli: Allow skipping the creation of a local validator when testing against
  localnet ([#93](https://github.com/coral-xyz/anchor/pull/93)).
- cli: Adds support for tests with Typescript
  ([#94](https://github.com/coral-xyz/anchor/pull/94)).
- cli: Deterministic and verifiable builds
  ([#100](https://github.com/coral-xyz/anchor/pull/100)).
- cli, lang: Add write buffers for IDL upgrades
  ([#107](https://github.com/coral-xyz/anchor/pull/107)).

## Breaking Changes

- lang: Removes `IdlInstruction::Clear`
  ([#107](https://github.com/coral-xyz/anchor/pull/107)).

### Fixes

- cli: Propagates mocha test exit status on error
  ([79b791](https://github.com/coral-xyz/anchor/commit/79b791ffa85ffae5b6163fa853562aa568650f21)).

## [0.2.1] - 2021-02-11

### Features

- cli: Embed workspace programs into local validator genesis when testing
  ([733ec3](https://github.com/coral-xyz/anchor/commit/733ec300b0308e7d007873b0975585d836333fd4)).
- cli: Stream program logs to `.anchor/program-logs` directory when testing
  ([ce5ca7](https://github.com/coral-xyz/anchor/commit/ce5ca7ddab6e0fd579deddcd02094b3f798bbe6a)).
- spl: Add shared memory api
  [(d92cb1)](https://github.com/coral-xyz/anchor/commit/d92cb1516b78696d1257e41d0c5ac6821716300e).
- lang/attribute/access-control: Allow specifying multiple modifier functions
  ([845df6](https://github.com/coral-xyz/anchor/commit/845df6d1960bb544fa0f2e3331ec79cc804edeb6)).
- lang/syn: Allow state structs that don't have a ctor or impl block (just trait
  implementations)
  ([a78000](https://github.com/coral-xyz/anchor/commit/a7800026833d64579e5b19c90d724ecc20d2a455)).
- ts: Add instruction method to state namespace
  ([627c27](https://github.com/coral-xyz/anchor/commit/627c275e9cdf3dafafcf44473ba8146cc7979d44)).
- lang/syn, ts: Add support for u128 and i128
  ([#83](https://github.com/coral-xyz/anchor/pull/83)).

## [0.2.0] - 2021-02-08

### Features

- lang: Adds the ability to create and use CPI program interfaces
  ([#66](https://github.com/coral-xyz/anchor/pull/66/files?file-filters%5B%5D=)).

### Breaking Changes

- lang, client, ts: Migrate from rust enum based method dispatch to a variant of
  sighash ([#64](https://github.com/coral-xyz/anchor/pull/64)).

## [0.1.0] - 2021-01-31

Initial release.

### Includes

- lang: `anchor-lang` crate providing a Rust eDSL for Solana.
- lang/attribute/access-control: Internal attribute macro for function
  modifiers.
- lang/attribute/account: Internal attribute macro for defining Anchor accounts.
- lang/attribute/error: Internal attribute macro for defining Anchor program
  errors.
- lang/attribute/program: Internal attribute macro for defining an Anchor
  program.
- lang/attribute/state: Internal attribute macro for defining an Anchor program
  state struct.
- lang/derive/accounts: Internal derive macro for defining deserialized account
  structs.
- lang/syn: Internal crate for parsing the Anchor eDSL, generating code, and an
  IDL.
- spl: `anchor-spl` crate providing CPI clients for Anchor programs.
- client: `anchor-client` crate providing Rust clients for Anchor programs.
- ts: `@project-serum/anchor` package for generating TypeScript clients.
- cli: Command line interface for managing Anchor programs.
```

File: anchor/docs/content/docs/updates/contribution-guide.mdx

```mdx
---
title: Contribution Guide
description: Anchor - Contribution Guide
---

Thank you for your interest in contributing to Anchor! All contributions are
welcome no matter how big or small. This includes (but is not limited to) filing
issues, adding documentation, fixing bugs, creating examples, and implementing
features.

---

## Finding issues to work on

If you're looking to get started, check out
[good first issues](https://github.com/coral-xyz/anchor/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22)
or issues where
[help is wanted](https://github.com/coral-xyz/anchor/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22).
For simple documentation changes or typos, feel free to just open a pull
request.

If you're considering larger changes or self motivated features, please file an
issue and engage with the maintainers in
[Discord](https://discord.gg/NHHGSXAnXk).

## Choosing an issue

If you'd like to contribute, please claim an issue by commenting, forking, and
opening a pull request, even if empty. This allows the maintainers to track who
is working on what issue as to not overlap work.

## Issue Guidelines

Please follow these guidelines:

Before coding:

- choose a branch name that describes the issue you're working on
- enable
  [commit signing](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits)

While coding:

- Submit a draft PR asap
- Only change code directly relevant to your PR. Sometimes you might find some
  code that could really need some refactoring. However, if it's not relevant to
  your PR, do not touch it. File an issue instead. This allows the reviewer to
  focus on a single problem at a time.
- If you write comments, do not exceed 80 chars per line. This allows
  contributors who work with multiple open windows to still read the comments
  without horizontally scrolling.
- Write adversarial tests. For example, if you're adding a new account type, do
  not only write tests where the instruction succeeds. Also write tests that
  test whether the instruction fails, if a check inside the new type is
  violated.

After coding:

- If you've moved code around, build the docs with `cargo doc --open` and adjust
  broken links
- Adjust the cli templates if necessary
- If you made a change to anchor's periphery (avm or cli), make a PR to the
  `anchor-book` repo if necessary
```

File: anchor/docs/content/docs/updates/meta.json

```json
{
  "title": "Anchor Project Updates",
  "pages": ["release-notes", "changelog", "contribution-guide"]
}
```

File: anchor/docs/content/docs/index.mdx

```mdx
---
title: Introduction
description:
  Anchor is a development framework for building secure Solana programs (smart
  contracts)
---

import { Download, PanelsTopLeft, Database, Terminal } from "lucide-react";

Anchor is the leading development framework for building Solana programs (smart
contracts) and simplifies the process of writing, testing, deploying, and
interacting with Solana programs.

The Anchor framework helps developers build production-ready applications faster
while reducing potential vulnerabilities through built-in security features.

## Where to start?

<Cards>

<Card icon={<Download className="text-purple-300" />} title='Installation' href='/docs/installation'>

Step-by-step guide to install Anchor framework. Set up your local development
environment.

</Card>

<Card icon={<PanelsTopLeft className="text-blue-300" />} title='Quickstart' href='/docs/quickstart/solpg'>

Quickstart guide to start building Solana programs with Anchor. Start building
directly in your browser. No installation required.

</Card>

</Cards>
```

File: anchor/docs/content/docs/installation.mdx

````mdx
---
title: Installation
description:
  Learn how to install Rust, the Solana CLI, and Anchor Framework on Windows
  (WSL), Linux, or Mac.
---

import { Accordion, Accordions } from "fumadocs-ui/components/accordion";

This section covers the steps to set up your local environment for Solana
development.

## Quick Installation

On Mac and Linux, run this single command to install all dependencies.

```shell title="Terminal"
curl --proto '=https' --tlsv1.2 -sSfL https://solana-install.solana.workers.dev | bash
```
````

<Callout type="warn">
  Windows Users: You must first install WSL (see [Install
  Dependencies](#install-dependencies)). Then run the command above in the
  Ubuntu (Linux) terminal.
</Callout>

After installation, you should see output similar to the following:

```
Installed Versions:
Rust: rustc 1.85.0 (4d91de4e4 2025-02-17)
Solana CLI: solana-cli 2.1.15 (src:53545685; feat:3271415109, client:Agave)
Anchor CLI: anchor-cli 0.31.0
Node.js: v23.9.0
Yarn: 1.22.1

Installation complete. Please restart your terminal to apply all changes.
```

<Callout>

If the quick installation command above doesn't work, please refer to the
[Install Dependencies](#install-dependencies) section below for instructions to
install each dependency individually.

If the quick install command runs successfully, skip to the
[Solana CLI Basics](#solana-cli-basics) and
[Anchor CLI Basics](#anchor-cli-basics) sections below.

</Callout>

## Install Dependencies

The instructions below will guide you through installing each dependency
individually.

- Windows users must first install WSL (Windows subsystem for Linux) and then
  install the dependencies specified in the Linux section below.
- Linux users should first install the dependencies specified in the Linux
  section below.
- Mac users should start with the Rust installation instructions below.

<Accordions>
<Accordion title="Windows Subsystem for Linux (WSL)">

To develop Solana programs on Windows **you must use
[WSL](https://learn.microsoft.com/en-us/windows/wsl/install)** (Windows
subsystem for Linux). All additional dependencies must be installed through the
Linux terminal.

Once WSL is installed, install the dependencies specified in the Linux section
below before proceeding to install Rust, Solana CLI, and Anchor CLI.

To install WSL, run the following command in Windows PowerShell:

```shell title="Terminal"
wsl --install
```

The install process will prompt you to create a default user account.

![WSL Install](/docs/installation/wsl-install.png)

By default, WSL installs Ubuntu. You can open a Linux terminal by searching
"Ubuntu" in the Search bar.

![WSL Ubuntu](/docs/installation/wsl-ubuntu-search.png)

If your Ubuntu terminal looks like the image below, you may encounter an issue
where `ctrl + v` (paste keyboard shortcut) doesn't work in the terminal.

![Ubuntu Terminal](/docs/installation/wsl-ubuntu-terminal-1.png)

If you encounter this issue, open Windows Terminal by searching for "Terminal"
in the Search bar.

![Windows Terminal](/docs/installation/wsl-windows-terminal.png)

Next, close the Windows Terminal and reopen a Linux terminal by searching for
Ubuntu again. The terminal should now look like the image below, where
`ctrl + v` (paste keyboard shortcut) works.

![Ubuntu Terminal](/docs/installation/wsl-ubuntu-terminal-2.png)

If you are using VS Code, the
[WSL extension](https://code.visualstudio.com/docs/remote/wsl-tutorial) enables
you to use WSL and VS Code together.

![WSL Setup in VS Code](/docs/installation/wsl-vscode.png)

You should then see the following in the VS Code status bar:

![WSL: Ubuntu](/docs/installation/wsl-vscode-ubuntu.png)

Once you have WSL set up, all additional dependencies **must** be installed
through the Ubuntu (Linux) terminal.

To install the required Solana dependencies, first try running the
[quick installation](#quick-installation) command above in the Ubuntu (Linux)
terminal.

<Callout>

If the quick install command doesn't work, install the dependencies specified in
the Linux section below before proceeding to the individual steps for installing
Rust, Solana CLI, and Anchor CLI.

If the quick install command runs successfully, skip to the
[Solana CLI Basics](#solana-cli-basics) and
[Anchor CLI Basics](#anchor-cli-basics) sections below.

</Callout>

</Accordion>
<Accordion title="Linux">

The following dependencies are required for the Anchor CLI installation.

First, run the following command:

```shell title="Terminal"
sudo apt-get update
```

Next, install the following dependencies:

```shell title="Terminal"
sudo apt-get install -y \
    build-essential \
    pkg-config \
    libudev-dev llvm libclang-dev \
    protobuf-compiler libssl-dev
```

If you encounter the following error when installing `protobuf-compiler`, make
sure you first run `sudo apt-get update`:

```
Package protobuf-compiler is not available, but is referred to by another package.
This may mean that the package is missing, has been obsoleted, or
is only available from another source
```

</Accordion>
</Accordions>
<Steps>
<Step>

### Install Rust

Solana programs are written in the
[Rust programming language](https://www.rust-lang.org/).

The recommended installation method for Rust is
[rustup](https://www.rust-lang.org/tools/install).

Run the following command to install Rust:

```shell title="Terminal"
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
```

You should see the following message after the installation completes:

<Accordions>
<Accordion title="Successful Rust Install Message">

```
Rust is installed now. Great!

To get started you may need to restart your current shell.
This would reload your PATH environment variable to include
Cargo's bin directory ($HOME/.cargo/bin).

To configure your current shell, you need to source
the corresponding env file under $HOME/.cargo.

This is usually done by running one of the following (note the leading DOT):
. "$HOME/.cargo/env"            # For sh/bash/zsh/ash/dash/pdksh
source "$HOME/.cargo/env.fish"  # For fish
```

</Accordion>
</Accordions>

Run the following command to reload your PATH environment variable to include
Cargo's bin directory:

```shell title="Terminal"
. "$HOME/.cargo/env"
```

To verify that the installation was successful, check the Rust version:

```shell title="Terminal"
rustc --version
```

You should see output similar to the following:

```
rustc 1.84.1 (e71f9a9a9 2025-01-27)
```

</Step>
<Step>

### Install the Solana CLI

The Solana CLI provides all the tools required to build and deploy Solana
programs.

Install the Solana CLI tool suite using the official install command:

```shell title="Terminal"
sh -c "$(curl -sSfL https://release.anza.xyz/stable/install)"
```

You can replaceÂ `stable`Â with the release tag matching the software version of
your desired release (i.e. `v2.0.3`), or use one of the three symbolic channel
names:Â `stable`,Â `beta`, orÂ `edge`.

If it is your first time installing the Solana CLI, you may see the following
message prompting you to add a `PATH` environment variable:

```
Close and reopen your terminal to apply the PATH changes or run the following in your existing shell:

export PATH="/Users/test/.local/share/solana/install/active_release/bin:$PATH"
```

<Tabs groupId="language" items={["Linux", "Mac"]}>
<Tab value="Linux">

If you are using a Linux or WSL terminal, you can add the `PATH` environment
variable to your shell configuration file by running the command logged from the
installation or by restarting your terminal.

```shell title="Terminal"
export PATH="$HOME/.local/share/solana/install/active_release/bin:$PATH"
```

</Tab>
<Tab value="Mac">

If you're on Mac using `zsh`, running the default `export PATH` command logged
from the installation does not persist once you close your terminal.

Instead, you can add the PATH to your shell configuration file by running the
following command:

```shell title="Terminal"
echo 'export PATH="$HOME/.local/share/solana/install/active_release/bin:$PATH"' >> ~/.zshrc
```

Then run the following command to refresh the terminal session or restart your
terminal.

```shell title="Terminal"
source ~/.zshrc
```

</Tab>
</Tabs>

To verify that the installation was successful, check the Solana CLI version:

```shell title="Terminal"
solana --version
```

You should see output similar to the following:

```
solana-cli 2.0.26 (src:3dccb3e7; feat:607245837, client:Agave)
```

You can view all available versions on the
[Agave Github repo](https://github.com/anza-xyz/agave/releases).

<Callout>

Agave is the validator client from [Anza](https://www.anza.xyz/), formerly known
as Solana Labs validator client.

</Callout>

To later update the Solana CLI to the latest version, you can use the following
command:

```shell title="Terminal"
agave-install update
```

</Step>
<Step>

### Install Anchor CLI

[Anchor](https://www.anchor-lang.com/) is a framework for developing Solana
programs. The Anchor framework leverages Rust macros to simplify the process of
writing Solana programs.

There are two ways to install the Anchor CLI and tooling:

1. Anchor Version Manager (AVM) - Recommended installation method
2. Without AVM - Install directly from GitHub

<Tabs groupId="anchor" items={["AVM", "Without AVM"]}>
<Tab value="AVM">

The Anchor version manager (AVM) allows you to install and manage different
Anchor versions on your system and easily update Anchor versions in the future.

Install AVM with the following command:

```shell title="Terminal"
cargo install --git https://github.com/coral-xyz/anchor avm --force
```

Check that AVM was installed successfully:

```shell title="Terminal"
avm --version
```

Install the latest version of Anchor CLI using AVM:

```shell title="Terminal"
avm install latest
avm use latest
```

Alternatively, you can install a specific version of Anchor CLI by specifying
the version number:

```shell title="Terminal"
avm install 0.31.0
avm use 0.31.0
```

<Callout type="info">

Don't forget to run the `avm use` command to declare which Anchor CLI version
should be used on your system.

- If you installed the `latest` version, run `avm use latest`.
- If you installed the version `0.31.0`, run `avm use 0.31.0`.

</Callout>

</Tab>

<Tab value="Without AVM">

Install a specific version of the Anchor CLI with the following command:

```shell title="Terminal"
cargo install --git https://github.com/coral-xyz/anchor --tag v0.31.0 anchor-cli
```

</Tab>
</Tabs>

To verify that the installation was successful, check the Anchor CLI version:

```shell title="Terminal"
anchor --version
```

You should see output similar to the following:

```
anchor-cli 0.31.0
```

<Callout type="warn">

When installing the Anchor CLI on Linux or WSL, you may encounter this error:

```
error: could not exec the linker cc = note: Permission denied (os error 13)
```

If you see this error message, follow these steps:

1. Install the dependencies listed in the
   [Linux](/docs/intro/installation#install-dependencies) section at the top of
   this page.
2. Retry installing the Anchor CLI.

</Callout>

#### Node.js and Yarn

Node.js and Yarn are required to run the default Anchor project test file
(TypeScript) created with the `anchor init` command. (Rust test template is also
available using `anchor init --test-template rust`)

<Accordions>
<Accordion title="Node Installation">

The recommended way to install node is using
[Node Version Manager (nvm)](https://github.com/nvm-sh/nvm).

Install nvm using the following command:

```shell title="Terminal"
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash
```

Restart your terminal and verify that nvm is installed:

```shell title="Terminal"
command -v nvm
```

Next, use `nvm` to install node:

```shell title="Terminal"
nvm install node
```

To verify that the installation was successful, check the Node version:

```shell title="Terminal"
node --version
```

You should see output similar to the following:

```
v23.7.0
```

</Accordion>
<Accordion title="Yarn Installation">

Install Yarn:

```shell title="Terminal"
npm install --global yarn
```

To verify that the installation was successful, check the Yarn version:

```shell title="Terminal"
yarn --version
```

You should the following output:

```
1.22.1
```

</Accordion>
</Accordions>

<Callout type="warn">

When running `anchor build`, if you encounter the following errors:

<Accordions>
<Accordion title="error: not a directory">

```
error: not a directory: '.../solana-release/bin/sdk/sbf/dependencies/platform-tools/rust/lib'
```

Try these solutions:

1. Force install using the following command:

```shell title="Terminal"
cargo build-sbf --force-tools-install
```

2. If the solution above doesn't work, clear the Solana cache:

```shell title="Terminal"
rm -rf ~/.cache/solana/*
```

</Accordion>

<Accordion title="lock file version 4 requires `-Znext-lockfile-bump">
You can fix this by changing the version field of `Cargo.lock` file from 4 to 3:

```diff title="Cargo.lock"
-version = 4
+version = 3
```

See [this issue](https://github.com/coral-xyz/anchor/issues/3392) for more
information.

</Accordion>

</Accordions>

After applying the solution above, attempt to run `anchor build` again.

</Callout>

<Callout type="warn">

When running `anchor test` after creating a new Anchor project on Linux or WSL,
you may encounter the following errors if Node.js or Yarn are not installed:

```
Permission denied (os error 13)
```

```
No such file or directory (os error 2)
```

</Callout>

</Step>
</Steps>

## Solana CLI Basics

This section will walk through some common Solana CLI commands to get you
started.

<Steps>
<Step>

### Solana Config

To see your current config:

```shell
solana config get
```

You should see output similar to the following:

```
Config File: /Users/test/.config/solana/cli/config.yml
RPC URL: https://api.mainnet-beta.solana.com
WebSocket URL: wss://api.mainnet-beta.solana.com/ (computed)
Keypair Path: /Users/test/.config/solana/id.json
Commitment: confirmed
```

The RPC URL and Websocket URL specific the Solana cluster the CLI will make
requests to. By default this will be mainnet-beta.

You can update the Solana CLI cluster using the following commands:

```
solana config set --url mainnet-beta
solana config set --url devnet
solana config set --url localhost
solana config set --url testnet
```

You can also use the following short options:

```
solana config set -um    # For mainnet-beta
solana config set -ud    # For devnet
solana config set -ul    # For localhost
solana config set -ut    # For testnet
```

The Keypair Path specifies the location of the default wallet used by the Solana
CLI (to pay transaction fees and deploy programs). The default path is
`~/.config/solana/id.json`. The next step walks through how to generate a
keypair at the default location.

</Step>
<Step>

### Create Wallet

To interact with the Solana network using the Solana CLI, you need a Solana
wallet funded with SOL.

To generate a keypair at the default Keypair Path, run the following command:

```shell
solana-keygen new
```

You should see output similar to the following:

```
Generating a new keypair

For added security, enter a BIP39 passphrase

NOTE! This passphrase improves security of the recovery seed phrae NOT the
keypair file itself, which is stored as insecure plain text

BIP39 Passphrase (empty for none):

Wrote new keypair to /Users/test/.config/solana/id.json
===========================================================================
pubkey: 8dBTPrjnkXyuQK3KDt9wrZBfizEZijmmUQXVHpFbVwGT
===========================================================================
Save this seed phrase and your BIP39 passphrase to recover your new keypair:
cream bleak tortoise ocean nasty game gift forget fancy salon mimic amazing
===========================================================================
```

<Callout type="note">

If you already have a file system wallet saved at the default location, this
command will **NOT** override it unless you explicitly force override using the
`--force` flag.

</Callout>

Once a keypair is generated, you can get the address (public key) of the keypair
with the following command:

```shell
solana address
```

</Step>
<Step>

### Airdrop SOL

Once you've set up your local wallet, request an airdrop of SOL to fund your
wallet. You need SOL to pay for transaction fees and to deploy programs.

Set your cluster to the devnet:

```shell
solana config set -ud
```

Then request an airdrop of devnet SOL:

```shell
solana airdrop 2
```

To check your wallet's SOL balance, run the following command:

```shell
solana balance
```

<Callout>

The `solana airdrop` command is currently limited to 5 SOL per request on
devnet. Errors are likely due to rate limits.

Alternatively, you can get devnet SOL using the
[Solana Web Faucet](https://faucet.solana.com).

</Callout>
</Step>
<Step>

### Run Local Validator

The Solana CLI comes with the
[test validator](https://docs.solanalabs.com/cli/examples/test-validator)
built-in. Running a local validator will allow you to deploy and test your
programs locally.

In a separate terminal, run the following command to start a local validator:

```shell
solana-test-validator
```

Make sure to update the Solana CLI config to localhost before commands.

```shell
solana config set -ul
```

</Step>
</Steps>

## Anchor CLI Basics

This section will walk through some common Anchor CLI commands to get you
started. For more information on the Anchor CLI, see the
[Anchor documentation](https://www.anchor-lang.com/docs).

<Steps>
<Step>

### Initialize Project

To create a new Anchor project, run the following command:

```shell title="Terminal"
anchor init <project-name>
```

For example, to create a project called `my-project`, run:

```shell title="Terminal"
anchor init my-project
```

This command creates a new directory with the project name and initializes a new
Anchor project with a basic Rust program and TypeScript test template.

Navigate to the project directory:

```shell title="Terminal"
cd <project-name>
```

See the Anchor project's
[file structure](https://www.anchor-lang.com/docs/quickstart/local#project-file-structure).

</Step>

<Step>
### Build Program

To build your project, run the following command:

```shell title="Terminal"
anchor build
```

The compiled program can be found in the `/target/deploy` directory.

</Step>
<Step>

### Deploy Program

To deploy your project, run the following command:

```shell title="Terminal"
anchor deploy
```

This command will deploy your program to the `cluster` specified in the
[`Anchor.toml`](https://www.anchor-lang.com/docs/references/anchor-toml) file.

</Step>
<Step>

### Test Program

To test your project, run the following command:

```shell title="Terminal"
anchor test
```

<Callout>

This command builds, deploys, and runs the tests for your project.

When using `localnet` as the `cluster` in `Anchor.toml`, Anchor automatically
starts a local validator, deploys your program, runs tests, and then stops the
validator.

</Callout>

</Step>
</Steps>

## Shell Completions

Shell completions can be generated for [`bash`](#bash), [`fish`](#fish) and
[`zsh`](#zsh).

### Bash

```shell title="Terminal"
mkdir -p $HOME/.local/share/bash-completion/completions
anchor completions bash > $HOME/.local/share/bash-completion/completions/anchor
avm completions bash > $HOME/.local/share/bash-completion/completions/avm
exec bash
```

### Fish

```shell title="Terminal"
mkdir -p $HOME/.config/fish/completions
anchor completions fish > $HOME/.config/fish/completions/anchor.fish
avm completions fish > $HOME/.config/fish/completions/avm.fish
source $HOME/.config/fish/config.fish
```

### Zsh

First ensure the following is in your `.zshrc` file. If using `oh-my-zsh` this
step can be skipped.

```shell title="Terminal"
autoload -U compinit
compinit -i
```

Next run:

```shell title="Terminal"
anchor completions zsh | sudo tee /usr/local/share/zsh/site-functions/_anchor
avm completions zsh | sudo tee /usr/local/share/zsh/site-functions/_avm
exec zsh
```

````

File: anchor/docs/content/docs/meta.json
```json
{
  "title": "docs",
  "description": "The description of root folder",
  "pages": [
    "---Getting Started---",
    "installation",
    "quickstart",

    "---Core Concepts---",
    "basics",
    "clients",
    "testing",
    "features",

    "---SPL Tokens---",
    "tokens",

    "---References---",
    "references",
    "updates",
    "contribution"
  ]
}

````

</file_contents>
